/******/ (() => { // webpackBootstrap
/******/ 	var __webpack_modules__ = ({

/***/ 7221:
/***/ ((__unused_webpack_module, __unused_webpack___webpack_exports__, __webpack_require__) => {

"use strict";

// NAMESPACE OBJECT: ./src/blocks/components/icon/icons.js
var icons_namespaceObject = {};
__webpack_require__.r(icons_namespaceObject);
__webpack_require__.d(icons_namespaceObject, {
  "alignBottom": () => (alignBottom),
  "alignCenter": () => (alignCenter),
  "alignLeft": () => (alignLeft),
  "alignMiddle": () => (alignMiddle),
  "alignRight": () => (alignRight),
  "alignSpaceBetween": () => (alignSpaceBetween),
  "alignTop": () => (alignTop),
  "arrowDown": () => (arrowDown),
  "arrowLeft": () => (arrowLeft),
  "arrowRight": () => (arrowRight),
  "arrowUp": () => (arrowUp),
  "bar": () => (bar),
  "barsO": () => (barsO),
  "behance": () => (behance),
  "blogger": () => (blogger),
  "button": () => (icons_button),
  "buttons": () => (buttons),
  "carousel": () => (carousel),
  "cartO": () => (cartO),
  "check": () => (check),
  "chevronDown": () => (chevronDown),
  "chevronDownCircle": () => (chevronDownCircle),
  "chevronLeft": () => (chevronLeft),
  "chevronRight": () => (chevronRight),
  "chevronUp": () => (chevronUp),
  "chevronUpCircle": () => (chevronUpCircle),
  "close": () => (icons_close),
  "codeopen": () => (codeopen),
  "cog": () => (cog),
  "color": () => (color),
  "column": () => (column),
  "copy": () => (copy),
  "counter": () => (counter),
  "delicious": () => (delicious),
  "desktop": () => (desktop),
  "devianart": () => (devianart),
  "divider": () => (divider),
  "dribble": () => (dribble),
  "envelopeO": () => (envelopeO),
  "eyeO": () => (eyeO),
  "facebook": () => (facebook),
  "faq": () => (faq),
  "filled": () => (filled),
  "form": () => (icons_form),
  "gradient": () => (gradient),
  "heading": () => (heading),
  "icon": () => (icon),
  "iconList": () => (iconList),
  "image": () => (icons_image),
  "infoBox": () => (infoBox),
  "instagramO": () => (instagramO),
  "link": () => (icons_link),
  "linkO": () => (linkO),
  "linkedin": () => (linkedin),
  "lock": () => (lock),
  "map": () => (map),
  "mapMarkerO": () => (mapMarkerO),
  "medium": () => (medium),
  "minus": () => (minus),
  "mobile": () => (mobile),
  "outline": () => (outline),
  "paperPlaneO": () => (paperPlaneO),
  "paragraph": () => (paragraph),
  "paste": () => (paste),
  "pencil": () => (pencil),
  "phoneO": () => (phoneO),
  "pinterest": () => (pinterest),
  "plain": () => (plain),
  "play": () => (play),
  "plus": () => (plus),
  "questionMark": () => (questionMark),
  "quora": () => (quora),
  "quoteLeft": () => (quoteLeft),
  "quoteRight": () => (quoteRight),
  "rating": () => (rating),
  "recorderO": () => (recorderO),
  "reddit": () => (reddit),
  "removeO": () => (removeO),
  "reply": () => (reply),
  "reset": () => (icons_reset),
  "rss": () => (rss),
  "searchMinus": () => (searchMinus),
  "searchO": () => (searchO),
  "section": () => (section),
  "sendO": () => (sendO),
  "socialIcons": () => (socialIcons),
  "spacing": () => (spacing),
  "star": () => (star),
  "tablet": () => (tablet),
  "teams": () => (teams),
  "testimonial": () => (testimonial),
  "textAlignCenter": () => (textAlignCenter),
  "textAlignJustify": () => (textAlignJustify),
  "textAlignLeft": () => (textAlignLeft),
  "textAlignRight": () => (textAlignRight),
  "thumbsUpO": () => (thumbsUpO),
  "timeO": () => (timeO),
  "toggleOff": () => (toggleOff),
  "toggleOn": () => (toggleOn),
  "trash": () => (trash),
  "tumblr": () => (tumblr),
  "twitch": () => (twitch),
  "twitter": () => (twitter),
  "unLink": () => (unLink),
  "upload": () => (upload),
  "userO": () => (userO),
  "video": () => (video),
  "vimeo": () => (vimeo),
  "wordpress": () => (wordpress),
  "yelp": () => (yelp),
  "youtubePlay": () => (youtubePlay)
});

// NAMESPACE OBJECT: ./node_modules/css-tree/lib/generator/token-before.js
var token_before_namespaceObject = {};
__webpack_require__.r(token_before_namespaceObject);
__webpack_require__.d(token_before_namespaceObject, {
  "safe": () => (safe),
  "spec": () => (spec)
});

// NAMESPACE OBJECT: ./node_modules/css-tree/lib/lexer/trace.js
var trace_namespaceObject = {};
__webpack_require__.r(trace_namespaceObject);
__webpack_require__.d(trace_namespaceObject, {
  "getTrace": () => (getTrace),
  "isKeyword": () => (isKeyword),
  "isProperty": () => (isProperty),
  "isType": () => (isType)
});

// NAMESPACE OBJECT: ./node_modules/css-tree/lib/syntax/node/AnPlusB.js
var AnPlusB_namespaceObject = {};
__webpack_require__.r(AnPlusB_namespaceObject);
__webpack_require__.d(AnPlusB_namespaceObject, {
  "generate": () => (AnPlusB_generate),
  "name": () => (AnPlusB_name),
  "parse": () => (AnPlusB_parse),
  "structure": () => (structure)
});

// NAMESPACE OBJECT: ./node_modules/css-tree/lib/syntax/node/Atrule.js
var Atrule_namespaceObject = {};
__webpack_require__.r(Atrule_namespaceObject);
__webpack_require__.d(Atrule_namespaceObject, {
  "generate": () => (Atrule_generate),
  "name": () => (Atrule_name),
  "parse": () => (Atrule_parse),
  "structure": () => (Atrule_structure),
  "walkContext": () => (walkContext)
});

// NAMESPACE OBJECT: ./node_modules/css-tree/lib/syntax/node/AtrulePrelude.js
var AtrulePrelude_namespaceObject = {};
__webpack_require__.r(AtrulePrelude_namespaceObject);
__webpack_require__.d(AtrulePrelude_namespaceObject, {
  "generate": () => (AtrulePrelude_generate),
  "name": () => (AtrulePrelude_name),
  "parse": () => (AtrulePrelude_parse),
  "structure": () => (AtrulePrelude_structure),
  "walkContext": () => (AtrulePrelude_walkContext)
});

// NAMESPACE OBJECT: ./node_modules/css-tree/lib/syntax/node/AttributeSelector.js
var AttributeSelector_namespaceObject = {};
__webpack_require__.r(AttributeSelector_namespaceObject);
__webpack_require__.d(AttributeSelector_namespaceObject, {
  "generate": () => (AttributeSelector_generate),
  "name": () => (AttributeSelector_name),
  "parse": () => (AttributeSelector_parse),
  "structure": () => (AttributeSelector_structure)
});

// NAMESPACE OBJECT: ./node_modules/css-tree/lib/syntax/node/Block.js
var Block_namespaceObject = {};
__webpack_require__.r(Block_namespaceObject);
__webpack_require__.d(Block_namespaceObject, {
  "generate": () => (Block_generate),
  "name": () => (Block_name),
  "parse": () => (Block_parse),
  "structure": () => (Block_structure),
  "walkContext": () => (Block_walkContext)
});

// NAMESPACE OBJECT: ./node_modules/css-tree/lib/syntax/node/Brackets.js
var Brackets_namespaceObject = {};
__webpack_require__.r(Brackets_namespaceObject);
__webpack_require__.d(Brackets_namespaceObject, {
  "generate": () => (Brackets_generate),
  "name": () => (Brackets_name),
  "parse": () => (Brackets_parse),
  "structure": () => (Brackets_structure)
});

// NAMESPACE OBJECT: ./node_modules/css-tree/lib/syntax/node/CDC.js
var CDC_namespaceObject = {};
__webpack_require__.r(CDC_namespaceObject);
__webpack_require__.d(CDC_namespaceObject, {
  "generate": () => (CDC_generate),
  "name": () => (CDC_name),
  "parse": () => (CDC_parse),
  "structure": () => (CDC_structure)
});

// NAMESPACE OBJECT: ./node_modules/css-tree/lib/syntax/node/CDO.js
var CDO_namespaceObject = {};
__webpack_require__.r(CDO_namespaceObject);
__webpack_require__.d(CDO_namespaceObject, {
  "generate": () => (CDO_generate),
  "name": () => (CDO_name),
  "parse": () => (CDO_parse),
  "structure": () => (CDO_structure)
});

// NAMESPACE OBJECT: ./node_modules/css-tree/lib/syntax/node/ClassSelector.js
var ClassSelector_namespaceObject = {};
__webpack_require__.r(ClassSelector_namespaceObject);
__webpack_require__.d(ClassSelector_namespaceObject, {
  "generate": () => (ClassSelector_generate),
  "name": () => (ClassSelector_name),
  "parse": () => (ClassSelector_parse),
  "structure": () => (ClassSelector_structure)
});

// NAMESPACE OBJECT: ./node_modules/css-tree/lib/syntax/node/Combinator.js
var Combinator_namespaceObject = {};
__webpack_require__.r(Combinator_namespaceObject);
__webpack_require__.d(Combinator_namespaceObject, {
  "generate": () => (Combinator_generate),
  "name": () => (Combinator_name),
  "parse": () => (Combinator_parse),
  "structure": () => (Combinator_structure)
});

// NAMESPACE OBJECT: ./node_modules/css-tree/lib/syntax/node/Comment.js
var Comment_namespaceObject = {};
__webpack_require__.r(Comment_namespaceObject);
__webpack_require__.d(Comment_namespaceObject, {
  "generate": () => (Comment_generate),
  "name": () => (Comment_name),
  "parse": () => (Comment_parse),
  "structure": () => (Comment_structure)
});

// NAMESPACE OBJECT: ./node_modules/css-tree/lib/syntax/node/Declaration.js
var Declaration_namespaceObject = {};
__webpack_require__.r(Declaration_namespaceObject);
__webpack_require__.d(Declaration_namespaceObject, {
  "generate": () => (Declaration_generate),
  "name": () => (Declaration_name),
  "parse": () => (Declaration_parse),
  "structure": () => (Declaration_structure),
  "walkContext": () => (Declaration_walkContext)
});

// NAMESPACE OBJECT: ./node_modules/css-tree/lib/syntax/node/DeclarationList.js
var DeclarationList_namespaceObject = {};
__webpack_require__.r(DeclarationList_namespaceObject);
__webpack_require__.d(DeclarationList_namespaceObject, {
  "generate": () => (DeclarationList_generate),
  "name": () => (DeclarationList_name),
  "parse": () => (DeclarationList_parse),
  "structure": () => (DeclarationList_structure)
});

// NAMESPACE OBJECT: ./node_modules/css-tree/lib/syntax/node/Dimension.js
var Dimension_namespaceObject = {};
__webpack_require__.r(Dimension_namespaceObject);
__webpack_require__.d(Dimension_namespaceObject, {
  "generate": () => (Dimension_generate),
  "name": () => (Dimension_name),
  "parse": () => (Dimension_parse),
  "structure": () => (Dimension_structure)
});

// NAMESPACE OBJECT: ./node_modules/css-tree/lib/syntax/node/Function.js
var Function_namespaceObject = {};
__webpack_require__.r(Function_namespaceObject);
__webpack_require__.d(Function_namespaceObject, {
  "generate": () => (Function_generate),
  "name": () => (Function_name),
  "parse": () => (Function_parse),
  "structure": () => (Function_structure),
  "walkContext": () => (Function_walkContext)
});

// NAMESPACE OBJECT: ./node_modules/css-tree/lib/syntax/node/Hash.js
var Hash_namespaceObject = {};
__webpack_require__.r(Hash_namespaceObject);
__webpack_require__.d(Hash_namespaceObject, {
  "generate": () => (Hash_generate),
  "name": () => (Hash_name),
  "parse": () => (Hash_parse),
  "structure": () => (Hash_structure),
  "xxx": () => (xxx)
});

// NAMESPACE OBJECT: ./node_modules/css-tree/lib/syntax/node/Identifier.js
var Identifier_namespaceObject = {};
__webpack_require__.r(Identifier_namespaceObject);
__webpack_require__.d(Identifier_namespaceObject, {
  "generate": () => (Identifier_generate),
  "name": () => (Identifier_name),
  "parse": () => (Identifier_parse),
  "structure": () => (Identifier_structure)
});

// NAMESPACE OBJECT: ./node_modules/css-tree/lib/syntax/node/IdSelector.js
var IdSelector_namespaceObject = {};
__webpack_require__.r(IdSelector_namespaceObject);
__webpack_require__.d(IdSelector_namespaceObject, {
  "generate": () => (IdSelector_generate),
  "name": () => (IdSelector_name),
  "parse": () => (IdSelector_parse),
  "structure": () => (IdSelector_structure)
});

// NAMESPACE OBJECT: ./node_modules/css-tree/lib/syntax/node/MediaFeature.js
var MediaFeature_namespaceObject = {};
__webpack_require__.r(MediaFeature_namespaceObject);
__webpack_require__.d(MediaFeature_namespaceObject, {
  "generate": () => (MediaFeature_generate),
  "name": () => (MediaFeature_name),
  "parse": () => (MediaFeature_parse),
  "structure": () => (MediaFeature_structure)
});

// NAMESPACE OBJECT: ./node_modules/css-tree/lib/syntax/node/MediaQuery.js
var MediaQuery_namespaceObject = {};
__webpack_require__.r(MediaQuery_namespaceObject);
__webpack_require__.d(MediaQuery_namespaceObject, {
  "generate": () => (MediaQuery_generate),
  "name": () => (MediaQuery_name),
  "parse": () => (MediaQuery_parse),
  "structure": () => (MediaQuery_structure)
});

// NAMESPACE OBJECT: ./node_modules/css-tree/lib/syntax/node/MediaQueryList.js
var MediaQueryList_namespaceObject = {};
__webpack_require__.r(MediaQueryList_namespaceObject);
__webpack_require__.d(MediaQueryList_namespaceObject, {
  "generate": () => (MediaQueryList_generate),
  "name": () => (MediaQueryList_name),
  "parse": () => (MediaQueryList_parse),
  "structure": () => (MediaQueryList_structure)
});

// NAMESPACE OBJECT: ./node_modules/css-tree/lib/syntax/node/Nth.js
var Nth_namespaceObject = {};
__webpack_require__.r(Nth_namespaceObject);
__webpack_require__.d(Nth_namespaceObject, {
  "generate": () => (Nth_generate),
  "name": () => (Nth_name),
  "parse": () => (Nth_parse),
  "structure": () => (Nth_structure)
});

// NAMESPACE OBJECT: ./node_modules/css-tree/lib/syntax/node/Number.js
var Number_namespaceObject = {};
__webpack_require__.r(Number_namespaceObject);
__webpack_require__.d(Number_namespaceObject, {
  "generate": () => (Number_generate),
  "name": () => (Number_name),
  "parse": () => (Number_parse),
  "structure": () => (Number_structure)
});

// NAMESPACE OBJECT: ./node_modules/css-tree/lib/syntax/node/Operator.js
var Operator_namespaceObject = {};
__webpack_require__.r(Operator_namespaceObject);
__webpack_require__.d(Operator_namespaceObject, {
  "generate": () => (Operator_generate),
  "name": () => (Operator_name),
  "parse": () => (Operator_parse),
  "structure": () => (Operator_structure)
});

// NAMESPACE OBJECT: ./node_modules/css-tree/lib/syntax/node/Parentheses.js
var Parentheses_namespaceObject = {};
__webpack_require__.r(Parentheses_namespaceObject);
__webpack_require__.d(Parentheses_namespaceObject, {
  "generate": () => (Parentheses_generate),
  "name": () => (Parentheses_name),
  "parse": () => (Parentheses_parse),
  "structure": () => (Parentheses_structure)
});

// NAMESPACE OBJECT: ./node_modules/css-tree/lib/syntax/node/Percentage.js
var Percentage_namespaceObject = {};
__webpack_require__.r(Percentage_namespaceObject);
__webpack_require__.d(Percentage_namespaceObject, {
  "generate": () => (Percentage_generate),
  "name": () => (Percentage_name),
  "parse": () => (Percentage_parse),
  "structure": () => (Percentage_structure)
});

// NAMESPACE OBJECT: ./node_modules/css-tree/lib/syntax/node/PseudoClassSelector.js
var PseudoClassSelector_namespaceObject = {};
__webpack_require__.r(PseudoClassSelector_namespaceObject);
__webpack_require__.d(PseudoClassSelector_namespaceObject, {
  "generate": () => (PseudoClassSelector_generate),
  "name": () => (PseudoClassSelector_name),
  "parse": () => (PseudoClassSelector_parse),
  "structure": () => (PseudoClassSelector_structure),
  "walkContext": () => (PseudoClassSelector_walkContext)
});

// NAMESPACE OBJECT: ./node_modules/css-tree/lib/syntax/node/PseudoElementSelector.js
var PseudoElementSelector_namespaceObject = {};
__webpack_require__.r(PseudoElementSelector_namespaceObject);
__webpack_require__.d(PseudoElementSelector_namespaceObject, {
  "generate": () => (PseudoElementSelector_generate),
  "name": () => (PseudoElementSelector_name),
  "parse": () => (PseudoElementSelector_parse),
  "structure": () => (PseudoElementSelector_structure),
  "walkContext": () => (PseudoElementSelector_walkContext)
});

// NAMESPACE OBJECT: ./node_modules/css-tree/lib/syntax/node/Ratio.js
var Ratio_namespaceObject = {};
__webpack_require__.r(Ratio_namespaceObject);
__webpack_require__.d(Ratio_namespaceObject, {
  "generate": () => (Ratio_generate),
  "name": () => (Ratio_name),
  "parse": () => (Ratio_parse),
  "structure": () => (Ratio_structure)
});

// NAMESPACE OBJECT: ./node_modules/css-tree/lib/syntax/node/Raw.js
var Raw_namespaceObject = {};
__webpack_require__.r(Raw_namespaceObject);
__webpack_require__.d(Raw_namespaceObject, {
  "generate": () => (Raw_generate),
  "name": () => (Raw_name),
  "parse": () => (Raw_parse),
  "structure": () => (Raw_structure)
});

// NAMESPACE OBJECT: ./node_modules/css-tree/lib/syntax/node/Rule.js
var Rule_namespaceObject = {};
__webpack_require__.r(Rule_namespaceObject);
__webpack_require__.d(Rule_namespaceObject, {
  "generate": () => (Rule_generate),
  "name": () => (Rule_name),
  "parse": () => (Rule_parse),
  "structure": () => (Rule_structure),
  "walkContext": () => (Rule_walkContext)
});

// NAMESPACE OBJECT: ./node_modules/css-tree/lib/syntax/node/Selector.js
var Selector_namespaceObject = {};
__webpack_require__.r(Selector_namespaceObject);
__webpack_require__.d(Selector_namespaceObject, {
  "generate": () => (Selector_generate),
  "name": () => (Selector_name),
  "parse": () => (Selector_parse),
  "structure": () => (Selector_structure)
});

// NAMESPACE OBJECT: ./node_modules/css-tree/lib/syntax/node/SelectorList.js
var SelectorList_namespaceObject = {};
__webpack_require__.r(SelectorList_namespaceObject);
__webpack_require__.d(SelectorList_namespaceObject, {
  "generate": () => (SelectorList_generate),
  "name": () => (SelectorList_name),
  "parse": () => (SelectorList_parse),
  "structure": () => (SelectorList_structure),
  "walkContext": () => (SelectorList_walkContext)
});

// NAMESPACE OBJECT: ./node_modules/css-tree/lib/syntax/node/String.js
var String_namespaceObject = {};
__webpack_require__.r(String_namespaceObject);
__webpack_require__.d(String_namespaceObject, {
  "generate": () => (String_generate),
  "name": () => (String_name),
  "parse": () => (String_parse),
  "structure": () => (String_structure)
});

// NAMESPACE OBJECT: ./node_modules/css-tree/lib/syntax/node/StyleSheet.js
var StyleSheet_namespaceObject = {};
__webpack_require__.r(StyleSheet_namespaceObject);
__webpack_require__.d(StyleSheet_namespaceObject, {
  "generate": () => (StyleSheet_generate),
  "name": () => (StyleSheet_name),
  "parse": () => (StyleSheet_parse),
  "structure": () => (StyleSheet_structure),
  "walkContext": () => (StyleSheet_walkContext)
});

// NAMESPACE OBJECT: ./node_modules/css-tree/lib/syntax/node/TypeSelector.js
var TypeSelector_namespaceObject = {};
__webpack_require__.r(TypeSelector_namespaceObject);
__webpack_require__.d(TypeSelector_namespaceObject, {
  "generate": () => (TypeSelector_generate),
  "name": () => (TypeSelector_name),
  "parse": () => (TypeSelector_parse),
  "structure": () => (TypeSelector_structure)
});

// NAMESPACE OBJECT: ./node_modules/css-tree/lib/syntax/node/UnicodeRange.js
var UnicodeRange_namespaceObject = {};
__webpack_require__.r(UnicodeRange_namespaceObject);
__webpack_require__.d(UnicodeRange_namespaceObject, {
  "generate": () => (UnicodeRange_generate),
  "name": () => (UnicodeRange_name),
  "parse": () => (UnicodeRange_parse),
  "structure": () => (UnicodeRange_structure)
});

// NAMESPACE OBJECT: ./node_modules/css-tree/lib/syntax/node/Url.js
var Url_namespaceObject = {};
__webpack_require__.r(Url_namespaceObject);
__webpack_require__.d(Url_namespaceObject, {
  "generate": () => (Url_generate),
  "name": () => (Url_name),
  "parse": () => (Url_parse),
  "structure": () => (Url_structure)
});

// NAMESPACE OBJECT: ./node_modules/css-tree/lib/syntax/node/Value.js
var Value_namespaceObject = {};
__webpack_require__.r(Value_namespaceObject);
__webpack_require__.d(Value_namespaceObject, {
  "generate": () => (Value_generate),
  "name": () => (Value_name),
  "parse": () => (Value_parse),
  "structure": () => (Value_structure)
});

// NAMESPACE OBJECT: ./node_modules/css-tree/lib/syntax/node/WhiteSpace.js
var WhiteSpace_namespaceObject = {};
__webpack_require__.r(WhiteSpace_namespaceObject);
__webpack_require__.d(WhiteSpace_namespaceObject, {
  "generate": () => (WhiteSpace_generate),
  "name": () => (WhiteSpace_name),
  "parse": () => (WhiteSpace_parse),
  "structure": () => (WhiteSpace_structure)
});

// NAMESPACE OBJECT: ./node_modules/css-tree/lib/syntax/node/index.js
var node_namespaceObject = {};
__webpack_require__.r(node_namespaceObject);
__webpack_require__.d(node_namespaceObject, {
  "AnPlusB": () => (AnPlusB_namespaceObject),
  "Atrule": () => (Atrule_namespaceObject),
  "AtrulePrelude": () => (AtrulePrelude_namespaceObject),
  "AttributeSelector": () => (AttributeSelector_namespaceObject),
  "Block": () => (Block_namespaceObject),
  "Brackets": () => (Brackets_namespaceObject),
  "CDC": () => (CDC_namespaceObject),
  "CDO": () => (CDO_namespaceObject),
  "ClassSelector": () => (ClassSelector_namespaceObject),
  "Combinator": () => (Combinator_namespaceObject),
  "Comment": () => (Comment_namespaceObject),
  "Declaration": () => (Declaration_namespaceObject),
  "DeclarationList": () => (DeclarationList_namespaceObject),
  "Dimension": () => (Dimension_namespaceObject),
  "Function": () => (Function_namespaceObject),
  "Hash": () => (Hash_namespaceObject),
  "IdSelector": () => (IdSelector_namespaceObject),
  "Identifier": () => (Identifier_namespaceObject),
  "MediaFeature": () => (MediaFeature_namespaceObject),
  "MediaQuery": () => (MediaQuery_namespaceObject),
  "MediaQueryList": () => (MediaQueryList_namespaceObject),
  "Nth": () => (Nth_namespaceObject),
  "Number": () => (Number_namespaceObject),
  "Operator": () => (Operator_namespaceObject),
  "Parentheses": () => (Parentheses_namespaceObject),
  "Percentage": () => (Percentage_namespaceObject),
  "PseudoClassSelector": () => (PseudoClassSelector_namespaceObject),
  "PseudoElementSelector": () => (PseudoElementSelector_namespaceObject),
  "Ratio": () => (Ratio_namespaceObject),
  "Raw": () => (Raw_namespaceObject),
  "Rule": () => (Rule_namespaceObject),
  "Selector": () => (Selector_namespaceObject),
  "SelectorList": () => (SelectorList_namespaceObject),
  "String": () => (String_namespaceObject),
  "StyleSheet": () => (StyleSheet_namespaceObject),
  "TypeSelector": () => (TypeSelector_namespaceObject),
  "UnicodeRange": () => (UnicodeRange_namespaceObject),
  "Url": () => (Url_namespaceObject),
  "Value": () => (Value_namespaceObject),
  "WhiteSpace": () => (WhiteSpace_namespaceObject)
});

// NAMESPACE OBJECT: ./node_modules/css-tree/lib/syntax/scope/index.js
var scope_namespaceObject = {};
__webpack_require__.r(scope_namespaceObject);
__webpack_require__.d(scope_namespaceObject, {
  "AtrulePrelude": () => (atrulePrelude),
  "Selector": () => (selector),
  "Value": () => (value)
});

// NAMESPACE OBJECT: ./node_modules/css-tree/lib/syntax/node/index-parse.js
var index_parse_namespaceObject = {};
__webpack_require__.r(index_parse_namespaceObject);
__webpack_require__.d(index_parse_namespaceObject, {
  "AnPlusB": () => (AnPlusB_parse),
  "Atrule": () => (Atrule_parse),
  "AtrulePrelude": () => (AtrulePrelude_parse),
  "AttributeSelector": () => (AttributeSelector_parse),
  "Block": () => (Block_parse),
  "Brackets": () => (Brackets_parse),
  "CDC": () => (CDC_parse),
  "CDO": () => (CDO_parse),
  "ClassSelector": () => (ClassSelector_parse),
  "Combinator": () => (Combinator_parse),
  "Comment": () => (Comment_parse),
  "Declaration": () => (Declaration_parse),
  "DeclarationList": () => (DeclarationList_parse),
  "Dimension": () => (Dimension_parse),
  "Function": () => (Function_parse),
  "Hash": () => (Hash_parse),
  "IdSelector": () => (IdSelector_parse),
  "Identifier": () => (Identifier_parse),
  "MediaFeature": () => (MediaFeature_parse),
  "MediaQuery": () => (MediaQuery_parse),
  "MediaQueryList": () => (MediaQueryList_parse),
  "Nth": () => (Nth_parse),
  "Number": () => (Number_parse),
  "Operator": () => (Operator_parse),
  "Parentheses": () => (Parentheses_parse),
  "Percentage": () => (Percentage_parse),
  "PseudoClassSelector": () => (PseudoClassSelector_parse),
  "PseudoElementSelector": () => (PseudoElementSelector_parse),
  "Ratio": () => (Ratio_parse),
  "Raw": () => (Raw_parse),
  "Rule": () => (Rule_parse),
  "Selector": () => (Selector_parse),
  "SelectorList": () => (SelectorList_parse),
  "String": () => (String_parse),
  "StyleSheet": () => (StyleSheet_parse),
  "TypeSelector": () => (TypeSelector_parse),
  "UnicodeRange": () => (UnicodeRange_parse),
  "Url": () => (Url_parse),
  "Value": () => (Value_parse),
  "WhiteSpace": () => (WhiteSpace_parse)
});

// NAMESPACE OBJECT: ./node_modules/csso/lib/syntax.js
var lib_syntax_namespaceObject = {};
__webpack_require__.r(lib_syntax_namespaceObject);
__webpack_require__.d(lib_syntax_namespaceObject, {
  "compress": () => (compress),
  "find": () => (syntax_find),
  "findAll": () => (syntax_findAll),
  "findLast": () => (syntax_findLast),
  "fromPlainObject": () => (syntax_fromPlainObject),
  "generate": () => (syntax_generate),
  "lexer": () => (syntax_lexer),
  "parse": () => (syntax_parse),
  "specificity": () => (prepare_specificity),
  "toPlainObject": () => (syntax_toPlainObject),
  "tokenize": () => (syntax_tokenize),
  "walk": () => (syntax_walk)
});

;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/defineProperty.js
function _defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}
;// CONCATENATED MODULE: external ["wp","blocks"]
const external_wp_blocks_namespaceObject = window["wp"]["blocks"];
;// CONCATENATED MODULE: external ["wp","element"]
const external_wp_element_namespaceObject = window["wp"]["element"];
;// CONCATENATED MODULE: ./src/blocks/components/element/index.js

/* harmony default export */ const components_element = (function (_ref) {
  var tagName = _ref.tagName,
      htmlAttrs = _ref.htmlAttrs,
      children = _ref.children;
  return (0,external_wp_element_namespaceObject.createElement)(tagName, htmlAttrs, children);
});
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithHoles.js
function _arrayWithHoles(arr) {
  if (Array.isArray(arr)) return arr;
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArrayLimit.js
function _iterableToArrayLimit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];

  if (_i == null) return;
  var _arr = [];
  var _n = true;
  var _d = false;

  var _s, _e;

  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);

      if (i && _arr.length === i) break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null) _i["return"]();
    } finally {
      if (_d) throw _e;
    }
  }

  return _arr;
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayLikeToArray.js
function _arrayLikeToArray(arr, len) {
  if (len == null || len > arr.length) len = arr.length;

  for (var i = 0, arr2 = new Array(len); i < len; i++) {
    arr2[i] = arr[i];
  }

  return arr2;
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/unsupportedIterableToArray.js

function _unsupportedIterableToArray(o, minLen) {
  if (!o) return;
  if (typeof o === "string") return _arrayLikeToArray(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor) n = o.constructor.name;
  if (n === "Map" || n === "Set") return Array.from(o);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableRest.js
function _nonIterableRest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/slicedToArray.js




function slicedToArray_slicedToArray(arr, i) {
  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();
}
// EXTERNAL MODULE: ./node_modules/classnames/index.js
var classnames = __webpack_require__(4184);
var classnames_default = /*#__PURE__*/__webpack_require__.n(classnames);
;// CONCATENATED MODULE: external ["wp","data"]
const external_wp_data_namespaceObject = window["wp"]["data"];
;// CONCATENATED MODULE: ./src/blocks/components/tab-panel/index.js



function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }





var inspectorTabState = new Map();

var TabPanel = function TabPanel(_ref) {
  var _tabs$length;

  var tabs = _ref.children,
      _ref$hasIcon = _ref.hasIcon,
      hasIcon = _ref$hasIcon === void 0 ? false : _ref$hasIcon,
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? '' : _ref$className,
      label = _ref.label,
      _ref$root = _ref.root,
      root = _ref$root === void 0 ? false : _ref$root,
      _ref$block = _ref.block,
      _ref$block$name = _ref$block.name,
      name = _ref$block$name === void 0 ? '' : _ref$block$name,
      _ref$block$attributes = _ref$block.attributes.clientId,
      clientId = _ref$block$attributes === void 0 ? '' : _ref$block$attributes;

  if ('widgets' === window.pagenow || 'customize' === window.pagenow) {
    tabs = tabs.filter(function (tab) {
      var _tab$props;

      return 'Layout' !== (tab === null || tab === void 0 ? void 0 : (_tab$props = tab.props) === null || _tab$props === void 0 ? void 0 : _tab$props.tabTitle);
    });
  }

  var _useState = (0,external_wp_element_namespaceObject.useState)(root ? 'Settings' : tabs[0].props.tabTitle),
      _useState2 = slicedToArray_slicedToArray(_useState, 2),
      active = _useState2[0],
      setActive = _useState2[1];

  var id = name + '/' + clientId;
  (0,external_wp_element_namespaceObject.useEffect)(function () {
    var _inspectorTabState$ge;

    if (!root) return;

    if ((_inspectorTabState$ge = inspectorTabState.get(id)) !== null && _inspectorTabState$ge !== void 0 && _inspectorTabState$ge.tab && active !== inspectorTabState.get(id).tab) {
      setActive(inspectorTabState.get(id).tab);
    }
  }, []);
  return /*#__PURE__*/React.createElement("div", {
    className: classnames_default()('blockart-tab-panel', {
      'has-icon': hasIcon
    }, className)
  }, /*#__PURE__*/React.createElement("div", {
    className: "blockart-tab-panel-head",
    "data-sticky": !!root
  }, label && /*#__PURE__*/React.createElement("label", {
    htmlFor: "blockart-tab-panel"
  }, label), /*#__PURE__*/React.createElement("div", {
    className: "blockart-tab-panel-menu",
    role: "group",
    "data-grid": (_tabs$length = tabs.length) !== null && _tabs$length !== void 0 ? _tabs$length : 0
  }, tabs.map(function (tab) {
    var tabTitle = tab.props.tabTitle;
    return /*#__PURE__*/React.createElement("button", {
      key: tabTitle,
      className: classnames_default()('blockart-tab-panel-menu-item', {
        'is-active': tabTitle === active
      }),
      onClick: function onClick() {
        if (root) {
          var _inspectorTabState$ge2;

          var current = (_inspectorTabState$ge2 = inspectorTabState.get(tab)) !== null && _inspectorTabState$ge2 !== void 0 ? _inspectorTabState$ge2 : {};
          inspectorTabState.set(id, _objectSpread(_objectSpread({}, current), {}, {
            tab: tabTitle
          }));
          setActive(tabTitle);
        } else {
          setActive(tabTitle);
        }
      }
    }, /*#__PURE__*/React.createElement("span", {
      className: "blockart-tab-panel-menu-item-title"
    }, tabTitle));
  }))), /*#__PURE__*/React.createElement("div", {
    className: "blockart-tab-panel-body"
  }, tabs.map(function (tab) {
    return /*#__PURE__*/React.createElement("div", {
      key: tab.props.tabTitle,
      style: {
        display: tab.props.tabTitle === active ? 'block' : 'none'
      },
      "data-inspector-tab": root ? tab.props.tabTitle : null
    }, tab);
  })));
};

/* harmony default export */ const tab_panel = ((0,external_wp_data_namespaceObject.withSelect)(function (select) {
  return {
    block: select('core/block-editor').getSelectedBlock()
  };
})(function (props) {
  return props !== null && props !== void 0 && props.block ? /*#__PURE__*/React.createElement(TabPanel, props) : null;
}));
;// CONCATENATED MODULE: ./src/blocks/components/tab/index.js
/* harmony default export */ const tab = (function (_ref) {
  var children = _ref.children;
  return /*#__PURE__*/React.createElement(React.Fragment, null, Array.isArray(children) ? children.map(function (child) {
    return child;
  }) : children);
});
;// CONCATENATED MODULE: external ["wp","compose"]
const external_wp_compose_namespaceObject = window["wp"]["compose"];
;// CONCATENATED MODULE: ./src/blocks/hoc/with-client-id.js



/* harmony default export */ const with_client_id = ((0,external_wp_compose_namespaceObject.createHigherOrderComponent)(function (Component) {
  return function (props) {
    var attributes = props.attributes,
        setAttributes = props.setAttributes,
        clientId = props.clientId,
        name = props.name;
    (0,external_wp_element_namespaceObject.useEffect)(function () {
      var ID = clientId.substr(0, 8);

      var _name$split = name.split('/'),
          _name$split2 = slicedToArray_slicedToArray(_name$split, 2),
          _name$split2$ = _name$split2[1],
          blockName = _name$split2$ === void 0 ? 'blockart' : _name$split2$;

      if (!attributes.clientId) {
        setAttributes({
          clientId: ID
        });
      } else if (attributes.clientId !== ID) {
        if (document.querySelectorAll(".blockart-".concat(blockName, "-").concat(attributes.clientId)).length > 1) {
          setAttributes({
            clientId: ID
          });
        }
      }
    }, []);
    return /*#__PURE__*/React.createElement(Component, props);
  };
}, 'withClientId'));
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/extends.js
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };
  return _extends.apply(this, arguments);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/typeof.js
function typeof_typeof(obj) {
  "@babel/helpers - typeof";

  return typeof_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) {
    return typeof obj;
  } : function (obj) {
    return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
  }, typeof_typeof(obj);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/arrayWithoutHoles.js

function _arrayWithoutHoles(arr) {
  if (Array.isArray(arr)) return _arrayLikeToArray(arr);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/iterableToArray.js
function _iterableToArray(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/nonIterableSpread.js
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toConsumableArray.js




function _toConsumableArray(arr) {
  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();
}
;// CONCATENATED MODULE: external ["wp","keycodes"]
const external_wp_keycodes_namespaceObject = window["wp"]["keycodes"];
;// CONCATENATED MODULE: external ["wp","i18n"]
const external_wp_i18n_namespaceObject = window["wp"]["i18n"];
;// CONCATENATED MODULE: external ["wp","keyboardShortcuts"]
const external_wp_keyboardShortcuts_namespaceObject = window["wp"]["keyboardShortcuts"];
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/objectWithoutPropertiesLoose.js
function _objectWithoutPropertiesLoose(source, excluded) {
  if (source == null) return {};
  var target = {};
  var sourceKeys = Object.keys(source);
  var key, i;

  for (i = 0; i < sourceKeys.length; i++) {
    key = sourceKeys[i];
    if (excluded.indexOf(key) >= 0) continue;
    target[key] = source[key];
  }

  return target;
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js

function _objectWithoutProperties(source, excluded) {
  if (source == null) return {};
  var target = _objectWithoutPropertiesLoose(source, excluded);
  var key, i;

  if (Object.getOwnPropertySymbols) {
    var sourceSymbolKeys = Object.getOwnPropertySymbols(source);

    for (i = 0; i < sourceSymbolKeys.length; i++) {
      key = sourceSymbolKeys[i];
      if (excluded.indexOf(key) >= 0) continue;
      if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;
      target[key] = source[key];
    }
  }

  return target;
}
;// CONCATENATED MODULE: external ["wp","components"]
const external_wp_components_namespaceObject = window["wp"]["components"];
;// CONCATENATED MODULE: ./src/blocks/components/icon/icons.js

var arrowDown = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M17.9 15.2H13V2h-2v13.1H6.1L12 22l5.9-6.8z"
}));
var arrowLeft = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M2 12l6.9 6v-5H22v-2H8.9V6L2 12z"
}));
var arrowRight = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M21.8 12l-7-6v5H2v2h12.8v5l7-6z"
}));
var arrowUp = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M13 22V9h5l-6-7-6.1 7h5v12.9H13v.1z"
}));
var textAlignLeft = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M3,19.94H21V22H3Zm0-4.45,12.28,0v2L3,17.47ZM3,10.9l17.81,0v2.22L3,13ZM3,2,21,2v2H3ZM3,6.51l12.27,0,0,2L3,8.47Z"
}));
var textAlignRight = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M3,19.94H21V22H3Zm5.7-4.45,12.28,0v2l-12.28,0ZM3.13,10.9l17.81,0v2.22L3.13,13ZM3,2,21,2v2H3ZM8.71,6.51,21,6.56l0,2-12.26,0Z"
}));
var textAlignCenter = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M3,19.94H21V22H3Zm3-4.45,12,0v2l-12,0ZM3,10.9l17.81,0v2.22L3,13ZM3,2,21,2v2H3ZM6,6.51l12,0,0,2-12,0Z"
}));
var textAlignJustify = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M3,15.53H21V17.6H3ZM6,20l12,0v2L6,22ZM3,10.9l17.81,0v2.22L3,13ZM3,2,21,2v2H3ZM3,6.51l18,0,0,2-18,0Z"
}));
var alignTop = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M20 7.5H4v13h16Zm-18-3h20m0 1H2v-2h20Z"
}));
var alignMiddle = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M22 11h-4V2H6v9H2v2h4v9h12v-9h4v-2z"
}));
var alignBottom = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M20 16.5H4v-13h16Zm-18 3h20m0-1H2v2h20Z"
}));
var alignSpaceBetween = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M6 4v16h12V4ZM3 22V2m1 0v20H2V2Zm17 20V2m1 0v20h-2V2Z"
}));
var alignCenter = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Rect, {
  x: "11",
  y: "2",
  width: "2",
  height: "20"
}), /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Rect, {
  x: "3",
  y: "6",
  width: "18",
  height: "12"
}));
var alignLeft = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Rect, {
  x: "3",
  y: "2",
  width: "2",
  height: "20"
}), /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Rect, {
  x: "7",
  y: "6",
  width: "14",
  height: "12"
}));
var alignRight = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Rect, {
  x: "19",
  y: "2",
  width: "2",
  height: "20"
}), /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Rect, {
  x: "3",
  y: "6",
  width: "14",
  height: "12"
}));
var chevronDown = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M20.5 6.2L12 14.7 3.5 6.2 2 7.8l10 10 9.9-10-1.4-1.6z"
}));
var chevronLeft = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M16.3 2l-10 10.1 10 10 1.4-1.4-8.5-8.6 8.6-8.7L16.3 2z"
}));
var chevronRight = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M6.6 3.4l8.7 8.6-8.7 8.7L8 22.1 18 12 8 2 6.6 3.4z"
}));
var chevronUp = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M2 16.1l1.4 1.4L12 8.9l8.6 8.6 1.4-1.4-10-10-10 10z"
}));
var questionMark = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M12 4C9.243 4 7 6.243 7 9h2c0-1.654 1.346-3 3-3s3 1.346 3 3c0 1.069-.454 1.465-1.481 2.255-.382.294-.813.626-1.226 1.038C10.981 13.604 10.995 14.897 11 15v2h2v-2.009c0-.024.023-.601.707-1.284.32-.32.682-.598 1.031-.867C15.798 12.024 17 11.1 17 9c0-2.757-2.243-5-5-5zm-1 14h2v2h-2z"
}));
var removeO = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M5 20c0 1.1.9 2 2 2h10c1.1 0 2-.9 2-2V8h2V6h-4V4c0-1.1-.9-2-2-2H9c-1.2 0-2 .9-2 2v2H3v2h2v12zM9 4h6v2H9V4zM7.9 8h9v12H7V8h.9z"
}), /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M9.4 10.7h1.7v7H9.4v-7zm3.4 0h1.7v7h-1.7v-7z"
}));
var toggleOff = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M8 9c-1.6 0-3 1.4-3 3s1.4 3 3 3 3-1.4 3-3-1.4-3-3-3z"
}), /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M16 6H8c-3.3 0-6 2.7-6 6s2.7 6 6 6h8c3.3 0 6-2.7 6-6s-2.7-6-6-6zm0 10H8c-2.2 0-4-1.8-4-4s1.8-4 4-4h8c2.2 0 4 1.8 4 4s-1.8 4-4 4zm4-4h1-1z"
}));
var toggleOn = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M16 6H8c-3.3 0-6 2.7-6 6s2.7 6 6 6h8c3.3 0 6-2.7 6-6s-2.7-6-6-6zm0 9c-1.6 0-3-1.4-3-3s1.4-3 3-3 3 1.4 3 3-1.4 3-3 3z"
}));
var unLink = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M12,22.14a4.67,4.67,0,0,0,3.27-1.33,4.57,4.57,0,0,0,1.21-3.27l-.06-3.69H14.59l.06,3.69A2.63,2.63,0,0,1,12,20.33a2.54,2.54,0,0,1-2.53-2.79l.06-3.69-2-.06-.06,3.69A4.6,4.6,0,0,0,12,22.14ZM16.54,6.46a4.48,4.48,0,1,0-9,0l.06,3.69H9.53L9.47,6.46a2.59,2.59,0,1,1,5.17,0l-.06,3.69h1.9C16.54,10.09,16.54,6.46,16.54,6.46Z"
}));
var chevronUpCircle = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M22 12c0 5.5-4.5 10-10 10S2 17.5 2 12 6.5 2 12 2s10 4.5 10 10zM2.5 12c0 5.3 4.3 9.5 9.5 9.5s9.5-4.3 9.5-9.5-4.2-9.5-9.5-9.5c-5.2 0-9.5 4.3-9.5 9.5z",
  fill: "#e2e8f0"
}), /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M7.7 14.9l4.3-4.3 4.3 4.3.8-.8-5-5-5 5 .6.8z",
  fill: "#64748b"
}));
var chevronDownCircle = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M12,22A10,10,0,1,1,22,12,10,10,0,0,1,12,22ZM12,2.49A9.51,9.51,0,1,0,21.51,12,9.53,9.53,0,0,0,12,2.49Z",
  fill: "#e2e8f0"
}), /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M16.28,9.1,12,13.35,7.78,9.1,7,9.9l5,5L17,9.9Z",
  fill: "#64748b"
}));
var cog = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M12 16c2.2 0 4-1.8 4-4s-1.8-4-4-4-4 1.8-4 4 1.8 4 4 4zm0-6c1.1 0 2 .9 2 2s-.9 2-2 2-2-.9-2-2 .9-2 2-2z"
}), /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M2.8 16.1l1 1.7c.5.9 1.8 1.3 2.7.7l.5-.3c.6.5 1.2.8 1.9 1.1v.7c0 1.1.9 2 2 2h2c1.1 0 2-.9 2-2v-.6c.7-.3 1.3-.7 1.9-1.1l.5.3c.9.5 2.2.2 2.7-.7l1-1.7c.6-1 .2-2.2-.7-2.7l-.5-.3c.1-.7.1-1.5 0-2.2l.5-.3c1-.6 1.3-1.8.7-2.7l-1-1.7c-.5-.9-1.8-1.3-2.7-.7l-.5.3c-.6-.5-1.2-.8-1.9-1.1V4c0-1.1-.9-2-2-2h-2C9.9 2 9 2.9 9 4v.6c-.7.3-1.3.7-1.9 1.1l-.5-.3c-.9-.5-2.2-.2-2.8.7l-1 1.7c-.6 1-.2 2.2.7 2.7l.5.3c-.1.7-.1 1.5 0 2.2l-.5.3c-.9.7-1.2 1.9-.7 2.8zm3.4-2.7c-.1-.5-.2-.9-.2-1.4 0-.5.1-.9.2-1.4.1-.4-.1-.9-.5-1.1l-1.1-.6 1-1.7 1.1.7c.4.1.9.1 1.2-.2.7-.7 1.5-1.2 2.4-1.4.4-.1.7-.5.7-1V4h2v1.3c0 .4.3.8.7 1 .9.3 1.7.8 2.4 1.4.3.3.8.3 1.2.1l1.1-.7 1 1.7-1.1.6c-.4.2-.6.7-.5 1.1.1.5.2.9.2 1.4 0 .5-.1.9-.2 1.4-.1.4.1.9.5 1.1l1.1.6-1 1.7-1.1-.7c-.4-.2-.9-.2-1.2.1-.7.6-1.5 1.1-2.4 1.4-.4.1-.7.5-.7 1v1.3h-2v-1.3c0-.4-.3-.8-.7-1-.9-.3-1.7-.8-2.4-1.4-.3-.1-.8-.1-1.2.1l-1.1.7-1-1.7 1.1-.7c.4-.2.6-.7.5-1.1z"
}));
var color = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M19.9 14.7c-.1.1-2.2 2.2-2.2 3.8 0 1.6 1 2.6 2.2 2.7 1 0 2.2-1 2.2-2.7 0-1.6-2.1-3.7-2.2-3.8zM8.7 21.2c.4.4.9.6 1.5.6s1.1-.2 1.5-.6l7.5-7.5-.8-.8-8.3-8.3-2.3-2.5-1.5 1.4L8.8 6l-6.1 6.1c-.4.4-.6.9-.6 1.5s.2 1.1.6 1.5l6 6.1zm1.7-13.7l6 6-12.2.1 6.2-6.1z"
}));
var desktop = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M20 2.6H4c-1.1 0-2 .9-2 2v11c0 1.1.9 2 2 2h7v2H8v2h8v-2h-3v-2h7c1.1 0 2-.9 2-2v-11c0-1.1-.9-2-2-2zm-16 11v-9h16v9H4z"
}));
var gradient = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  version: "1.1",
  id: "prefix__Layer_1",
  xmlns: "http://www.w3.org/2000/svg",
  x: "0",
  y: "0",
  viewBox: "0 0 24 24",
  xmlSpace: "preserve"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  className: "prefix__st0",
  d: "M3 2v20M22 3H2M22 21H2M21 2v20",
  stroke: "#000",
  strokeWidth: "2",
  strokeMiterlimit: "10"
}), /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M4 4v16h16C14 15 8 11 4 4z",
  fillRule: "evenodd",
  clipRule: "evenodd"
}), /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M12.3 4H4c4 7 10 11 16 16V4h-7.7",
  fillRule: "evenodd",
  clipRule: "evenodd",
  fill: "#fff"
}));
var icons_image = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M19.9 2.2H4.3c-1.2 0-2 .8-2 2v15.6c0 1.2.7 2.1 2 2.1h15.6c1.2 0 2-.8 2-2V4.3c-.1-1.3-.8-2.1-2-2.1zM4.3 19.8V4.2h15.6v15.6H4.3z"
}), /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M10.1 14l-1-1-3 4h12l-5-7-3 4z"
}));
var icons_link = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M3.6 20.3c1 1 2.4 1.6 3.8 1.6s2.7-.7 3.7-1.7l3-3.1-1.4-1.4-3 3.1c-1.3 1.3-3.3 1.3-4.6 0s-1.3-3.3 0-4.6l3.1-3-1.4-1.5-3.1 3c-2.1 2.2-2.2 5.5-.1 7.6zm16.7-9.2c2.1-2.1 2.2-5.4.1-7.5s-5.4-2-7.5.1l-3 3.1 1.4 1.4 3-3.1c1.3-1.3 3.3-1.3 4.6 0 1.3 1.3 1.3 3.3 0 4.6l-3.1 3 1.4 1.4c.1 0 3.1-3 3.1-3z"
}), /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M8.7 16.6l-1.4-1.4 8.5-8.5 1.4 1.4-8.5 8.5z"
}));
var lock = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M12,22.14a4.67,4.67,0,0,0,3.27-1.33,4.57,4.57,0,0,0,1.21-3.27l-.06-3.69H14.59l.06,3.69A2.63,2.63,0,0,1,12,20.33a2.54,2.54,0,0,1-2.53-2.79l.06-3.69-2-.06-.06,3.69A4.6,4.6,0,0,0,12,22.14ZM16.54,6.46a4.48,4.48,0,1,0-9,0l.06,3.69H9.53L9.47,6.46a2.59,2.59,0,1,1,5.17,0l-.06,3.69h1.9C16.54,10.09,16.54,6.46,16.54,6.46Z"
}), /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M13,17.15H11V6.85h2Z"
}));
var mobile = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M16.9 2h-10c-1.1 0-2 .9-2 2v16c0 1.1.9 2 2 2h10c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2zm-10 18V4h10v16h-10z"
}), /*#__PURE__*/React.createElement("circle", {
  cx: "11.9",
  cy: "18",
  r: "1"
}));
var tablet = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M20 2H4c-1.1 0-2 .9-2 2v16c0 1.1.8 2 1.9 2h16c1.1 0 2-.9 2-2V4c.1-1.1-.8-2-1.9-2zM4 20V4h15.8v16H4z"
}), /*#__PURE__*/React.createElement("circle", {
  cx: "12",
  cy: "18",
  r: "1"
}));
var play = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M2.1 2v20L22 12 2.1 2z"
}));
var icons_reset = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M19.9 10.1c-.2-.5-.5-1-.8-1.5l-1.7 1.1c.5.7.8 1.5 1 2.3.2.9.2 1.8 0 2.6-.1.4-.2.8-.4 1.2-.2.4-.4.8-.6 1.1-.5.7-1.1 1.3-1.8 1.8s-1.5.8-2.3 1c-.9.2-1.8.2-2.6 0-1.3-.3-2.4-.9-3.3-1.8-.6-.4-1.1-1.1-1.4-1.9-.2-.4-.3-.8-.4-1.2-.3-1.3-.1-2.7.4-3.9.3-.8.8-1.5 1.4-2.1.6-.6 1.3-1.1 2-1.4.4-.2.8-.3 1.2-.4h.3v3l5-4-5-4v2.9c-.1.1-.4.1-.6.1-1.1.3-2.2.7-3.1 1.3C3.8 8.6 2.5 13 4.1 16.8c.4 1 1.1 1.9 1.8 2.7.8.8 1.7 1.4 2.7 1.8 1.6.7 3.4.8 5.1.5 2.8-.6 5.1-2.5 6.2-5.1.2-.5.4-1.1.5-1.6.2-1.1.2-2.3 0-3.4-.1-.5-.3-1.1-.5-1.6z"
}));
var star = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M21.9 9.2c-.1-.4-.5-.6-.9-.7L15.3 8l-2.5-5.5c-.2-.5-.8-.7-1.3-.5-.2.1-.4.3-.5.5L8.6 8.1l-5.7.4c-.5 0-.9.5-.9 1.1 0 .2.1.5.3.6l4.2 4.1L5 20.8c-.1.5.2 1.1.7 1.2.3 0 .6 0 .9-.2l5.4-3.6 5.4 3.6c.5.3 1.1.2 1.4-.3.2-.2.2-.5.2-.8l-1.8-6.4 4.5-4.1c.3-.2.4-.6.2-1z"
}));
var upload = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M11 15h2V9h3l-4-5-4 5h3v6z"
}), /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M20 18H4v-7H2v7c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2v-7h-2v7z"
}));
var pencil = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  viewBox: "0 0 24 24",
  xmlns: "http://www.w3.org/2000/svg"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M3 22H3.3L7.7 20.9L8.2 20.6L21.4 7.3C21.8 6.9 22 6.3 22 5.8C22 5.3 21.7 4.7 21.4 4.3L19.7 2.6C18.9 1.8 17.4 1.8 16.7 2.6L3.4 15.8C3.2 16 3.1 16.1 3.1 16.3L2.1 20.6C2 20.9 2.1 21.4 2.4 21.6C2.5 21.9 2.7 22 3 22ZM18.2 4.1L19.9 5.8L18.2 7.5L16.5 5.8L18.2 4.1ZM5.1 17.1L14.8 7.4L16.5 9.1L6.8 18.8L4.5 19.4L5.1 17.1Z"
}));
var trash = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M5 20c0 1.1.9 2 2 2h10c1.1 0 2-.9 2-2V8h2V6h-4V4c0-1.1-.9-2-2-2H9c-1.2 0-2 .9-2 2v2H3v2h2v12zM9 4h6v2H9V4zM7.9 8h9v12H7V8h.9z"
}), /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M9.4 10.7h1.7v7H9.4v-7zm3.4 0h1.7v7h-1.7v-7z"
}));
var filled = /*#__PURE__*/React.createElement("svg", {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement("path", {
  d: "M21.2 8H2.8a.8.8 0 0 0-.8.8v6.4a.8.8 0 0 0 .8.8h18.4a.8.8 0 0 0 .8-.8V8.8a.8.8 0 0 0-.8-.8Zm-1.7 4.5h-15a.5.5 0 0 1 0-1h15a.5.5 0 0 1 0 1Z"
}));
var outline = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M19.5 11.5h-15a.5.5 0 0 0 0 1h15a.5.5 0 0 0 0-1Z"
}), /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Rect, {
  width: "19",
  height: "8",
  x: "2.5",
  y: "8",
  fill: "none",
  stroke: "currentColor",
  strokeMiterlimit: "10",
  rx: ".8"
}));
var plain = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  viewBox: "0 0 24 24",
  xmlns: "http://www.w3.org/2000/svg"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M21 13H3a1 1 0 0 1-1-1 1 1 0 0 1 1-1h18a1 1 0 0 1 1 1 1 1 0 0 1-1 1Z"
}));
var linkO = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  fill: "none",
  stroke: "currentColor",
  strokeLinecap: "round",
  strokeLinejoin: "round",
  strokeWidth: ".5",
  d: "M2.26 14.28h19.48"
}), /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M21 12H3a1 1 0 0 1-1-1 1 1 0 0 1 1-1h18a1 1 0 0 1 1 1 1 1 0 0 1-1 1Z"
}));
var paste = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M20 11V5a2 2 0 00-2-2h-3a1 1 0 00-1-1H8a1 1 0 00-1 1H4a2 2 0 00-2 2v13a2 2 0 002 2h7a2 2 0 002 2h7a2 2 0 002-2v-7a2 2 0 00-2-2zm-9 2v5H4V5h3v2h8V5h3v6h-5a2 2 0 00-2 2zm2 7v-7h7v7z"
}));
var copy = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M20 2H10a2 2 0 00-2 2v4H4a2 2 0 00-2 2v10a2 2 0 002 2h10a2 2 0 002-2v-4h4a2 2 0 002-2V4a2 2 0 00-2-2zM4 20V10h10v10zm16-6h-4v-4a2 2 0 00-2-2h-4V4h10z"
}));
var iconList = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M7.1 9H21c.5 0 1-.5 1-1s-.5-1-1-1H7.1C6.5 7 6 7.4 6 8s.5 1 1.1 1zM21 11H7.1c-.6 0-1.1.4-1.1 1s.5 1 1.1 1H21c.6 0 1.1-.4 1.1-1s-.6-1-1.1-1zM21 15H7.1c-.6 0-1.1.5-1.1 1 0 .6.5 1 1.1 1H21c.6 0 1.1-.4 1.1-1-.1-.5-.6-1-1.1-1zM3.3 7.6L3.1 7H3l-.1.1-.2.5h-.6c-.1 0-.1.1-.1.1v.1l.4.4-.1.7c0 .1 0 .1.1.1h.1l.5-.4.5.4h.1v-.1l-.1-.7.5-.4v-.1s0-.1-.1-.1h-.6zM3.3 11.6l-.2-.5c0-.1-.1-.1-.1-.1l-.1.1-.2.5h-.6c-.1 0-.1.1-.1.2v.1l.4.4-.1.6c0 .1 0 .1.1.1h.1l.5-.4.5.4h.1v-.1l-.2-.6.6-.5v-.1s0-.1-.1-.1h-.6zM3.3 15.6l-.2-.5c0-.1-.1-.1-.1-.1l-.1.1-.2.5h-.6c-.1.1-.1.1-.1.2v.1l.4.4-.1.6c0 .1 0 .1.1.1h.1l.5-.4.5.4h.1v-.1l-.2-.6.6-.5v-.1s0-.1-.1-.1h-.6z"
}));
var socialIcons = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M6 15c.9 0 1.7-.3 2.4-.9l6.3 3.6c-.1.3-.1.6-.1.9 0 1.9 1.6 3.5 3.5 3.6 1.9 0 3.5-1.6 3.6-3.5 0-1.9-1.6-3.5-3.5-3.6-.9 0-1.8.3-2.4.9l-6.3-3.6c.1-.2.1-.5.1-.8l6.1-3.5c1.4 1.3 3.6 1.2 4.9-.2s1.2-3.6-.2-4.9-3.6-1.2-4.9.2c-.6.6-.9 1.5-.9 2.4 0 .3 0 .6.1.8L8.9 9.6c-1-1.6-3.2-2.1-4.8-1S2 11.8 3 13.4c.7 1 1.8 1.6 3 1.6zm12 2c.8 0 1.5.7 1.5 1.5S18.8 20 18 20s-1.5-.7-1.5-1.5.6-1.5 1.5-1.5zm0-13c.8 0 1.5.7 1.5 1.5S18.8 7 18 7s-1.5-.7-1.5-1.5S17.1 4 18 4zM6 10c.8 0 1.5.7 1.5 1.5S6.8 13 6 13s-1.5-.7-1.5-1.5S5.1 10 6 10z"
}));
var infoBox = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M22 4V3c0-.6-.4-1-1-1H3c-.6 0-1 .4-1 1v18c0 .6.4 1 1 1h18c.6 0 1-.4 1-1V4zM4 4h16v16H4V4z"
}), /*#__PURE__*/React.createElement("circle", {
  cx: "12",
  cy: "7.5",
  r: "2"
}), /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M15 10.5H9c-.6 0-1 .4-1 1s.4 1 1 1h6c.6 0 1-.4 1-1s-.5-1-1-1zM11 18.5h2c.6 0 1-.4 1-1s-.4-1-1-1h-2c-.6 0-1 .4-1 1 0 .5.4 1 1 1zM6 14.5c0 .6.4 1 1 1h10c.6 0 1-.4 1-1s-.4-1-1-1H7c-.6 0-1 .5-1 1z"
}));
var icons_button = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  viewBox: "0 0 24 24",
  xmlns: "http://www.w3.org/2000/svg"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "m4 7a2 2 0 0 0-2 2v6a2 2 0 0 0 2 2h16a2 2 0 0 0 2-2v-6a2 2 0 0 0-2-2zm16 8h-16v-6h16z",
  fill: "#2563eb"
}), /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M18,12h0a.94.94,0,0,0-1-1H7a.94.94,0,0,0-1,1H6a.94.94,0,0,0,1,1H17A.94.94,0,0,0,18,12Z",
  fill: "#2563eb"
}));
var carousel = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M4 19.3h2c0 1.1.9 2.1 2 2.1h8c1.1 0 2-.9 2-2.1h2c1.1 0 2-.9 2-2.1V6.7c0-1.1-.9-2.1-2-2.1h-2c0-1.1-.9-2.1-2-2.1H8c-1.1 0-2 .9-2 2.1H4c-1.1.1-2 1-2 2.1v10.5c0 1.2.9 2.1 2 2.1zM20 6.5v11h-2v-11h2zM7.9 4h8v16H8L7.9 4zM4 6.5h2v11H4v-11z"
}));
var counter = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M20.1 8.3l.9-.9c.4-.4.4-1 0-1.4-.4-.4-1-.4-1.4 0l-1 1c-1-.6-2.3-1-3.6-1-3.9 0-7 3.1-7 7.1 0 3.7 3.2 6.9 6.9 6.9 3.9 0 7.1-3.1 7.1-7 0-1.8-.7-3.4-1.9-4.7zM15 18c-2.8 0-5-2.2-5-5s2.2-5 5-5 5 2.2 5 5-2.2 5-5 5z"
}), /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M15 10c.6 0 1 .4 1 1v2c0 .5-.4 1-1 1-.5 0-1-.4-1-1v-2c0-.6.4-1 1-1zm-1-7h2c.5 0 1 .4 1 1 0 .5-.4 1-1 1h-2c-.5 0-1-.4-1-1s.4-1 1-1zM4 8h2c.5 0 1 .4 1 1 0 .5-.4 1-1 1H4c-.5 0-1-.4-1-1s.4-1 1-1zm0 8h2c.5 0 1 .4 1 1 0 .5-.4 1-1 1H4c-.5 0-1-.4-1-1s.4-1 1-1zm-1-4h2c.5 0 1 .4 1 1 0 .5-.4 1-1 1H3c-.5 0-1-.4-1-1s.4-1 1-1z"
}));
var divider = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M2 10.9h20v2H2v-2z"
}));
var faq = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M12 6.4c-2 0-3.5 1.6-3.5 3.5h1.4c0-1.2 1-2.1 2.1-2.1s2.1 1 2.1 2.1c0 .8-.3 1-1 1.6-.3.2-.6.4-.9.7-.9.9-.9 1.8-.9 1.9v1.4h1.4v-1.4s0-.4.5-.9c.2-.2.5-.4.7-.6.7-.6 1.6-1.2 1.6-2.7 0-2-1.5-3.5-3.5-3.5zm-.7 9.9h1.4v1.4h-1.4v-1.4z"
}), /*#__PURE__*/React.createElement("circle", {
  cx: "12",
  cy: "12",
  r: "9",
  fill: "none",
  stroke: "#000",
  strokeWidth: "2",
  strokeMiterlimit: "10"
}));
var icons_form = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M4 2c-1.1 0-2 .9-2 2v2c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2V4c0-1.1-.9-2-2-2H4zm16 4H4V4h16v2zM2 10.9v5c0 1.1.9 2 2 2h16c1.1 0 2-.9 2-2v-5c0-1.1-.9-2-2-2H4c-1.1.1-2 1-2 2zM20 16H4v-5h16v5zM3 22h5c.6 0 1-.4 1-1s-.4-1-1-1H3c-.6 0-1 .4-1 1s.4 1 1 1z"
}));
var map = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M12 14c2.206 0 4-1.794 4-4s-1.794-4-4-4-4 1.794-4 4 1.794 4 4 4zm0-6c1.103 0 2 .897 2 2s-.897 2-2 2-2-.897-2-2 .897-2 2-2z"
}), /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M11.42 21.814a.998.998 0 0 0 1.16 0C12.884 21.599 20.029 16.44 20 10c0-4.411-3.589-8-8-8S4 5.589 4 9.995c-.029 6.445 7.116 11.604 7.42 11.819zM12 4c3.309 0 6 2.691 6 6.005.021 4.438-4.388 8.423-6 9.73-1.611-1.308-6.021-5.294-6-9.735 0-3.309 2.691-6 6-6z"
}));
var heading = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  viewBox: "0 0 24 24",
  xmlns: "http://www.w3.org/2000/svg"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "m17 19v-14a1 1 0 0 0-1-1 1 1 0 0 0-1 1v6h-6v-6a1 1 0 0 0-1-1 0.94 0.94 0 0 0-1 1v14a1 1 0 0 0 1 1 1 1 0 0 0 1-1v-6h6v6a1 1 0 0 0 1 1 0.94 0.94 0 0 0 1-1z",
  fill: "#2563eb"
}));
var icon = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "m6.516 14.323-1.49 6.452a.998.998 0 0 0 1.529 1.057L12 18.202l5.445 3.63a1.001 1.001 0 0 0 1.517-1.106l-1.829-6.4 4.536-4.082a1 1 0 0 0-.59-1.74l-5.701-.454-2.467-5.461a.998.998 0 0 0-1.822 0L8.622 8.05l-5.701.453a1 1 0 0 0-.619 1.713l4.214 4.107zm2.853-4.326a.998.998 0 0 0 .832-.586L12 5.43l1.799 3.981a.998.998 0 0 0 .832.586l3.972.315-3.271 2.944c-.284.256-.397.65-.293 1.018l1.253 4.385-3.736-2.491a.995.995 0 0 0-1.109 0l-3.904 2.603 1.05-4.546a1 1 0 0 0-.276-.94l-3.038-2.962 4.09-.326z"
}));
var paragraph = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M9.15 17h2.3v4.1a.9.9 0 00.9.9.9.9 0 00.9-.9v-17h2.8v17a.9.9 0 00.9.9h.1a.9.9 0 00.9-.9v-17h3.1a.9.9 0 00.9-.9V3a.9.9 0 00-.9-.9h-12a7.2 7.2 0 00-7 7.5 7.2 7.2 0 007.1 7.4zm-.1-12.9h2.3V15h-2.2a5.79 5.79 0 01-5.1-5.5 5.69 5.69 0 015-5.45z",
  fill: "#2563eb"
}));
var rating = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M22 8.8c-.1-.2-.2-.3-.5-.4l-3-.2-1.3-2.9c-.1-.3-.5-.4-.7-.3-.1.1-.2.1-.3.3l-1.3 2.9-3 .2c-.3 0-.5.3-.5.6 0 .1.1.2.2.3l2.2 2.2-.8 3.4c-.1.3.1.6.4.6.1 0 .3 0 .4-.1l2.9-1.9 2.9 1.9c.2.2.6.1.7-.1.1-.1.1-.3.1-.4l-1-3.4 2.4-2.2c.2-.1.2-.3.2-.5z"
}), /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M12.6 9.2c-.1-.2-.2-.3-.5-.4l-3-.2-1.3-2.9c-.1-.3-.4-.4-.7-.3-.1.1-.2.1-.3.3L5.5 8.6l-3 .2c-.3 0-.5.3-.5.6 0 .1.1.2.2.3l2.2 2.2-.8 3.4c-.1.3.1.6.4.7.1 0 .3 0 .4-.1L7.3 14l2.9 1.9c.2.2.6.1.7-.1.1-.1.1-.3.1-.4L10 12l2.4-2.2c.2-.2.3-.4.2-.6z"
}), /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M18.7 10c-.1-.3-.3-.5-.6-.5l-4-.3-1.7-3.9c-.2-.3-.6-.5-1-.3-.2.1-.3.2-.4.4L9.3 9.2l-4 .3c-.4 0-.7.4-.6.8 0 .2.1.3.2.5l3 2.9-1.1 4.6c-.1.3.1.7.5.7.2 0 .4 0 .6-.1l3.8-2.6 3.8 2.6c.3.2.8.1 1-.2.1-.2.1-.4.1-.6l-1.3-4.5 3.2-2.9c.2-.1.3-.4.2-.7z",
  stroke: "#fff",
  strokeMiterlimit: "10"
}));
var section = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M4 2a2 2 0 00-2 2v3a2 2 0 002 2h16a2 2 0 002-2V4a2 2 0 00-2-2zm16 5H4V4h16zM2 12v8a2 2 0 002 2h16a2 2 0 002-2v-8a2 2 0 00-2-2H4a2 2 0 00-2 2zm18 0v8H4v-8zm-9 5H9v-2h2v-2h2v2h2v2h-2v2h-2z",
  fill: "#2563eb"
}));
var spacing = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  viewBox: "0 0 24 24",
  xmlns: "http://www.w3.org/2000/svg"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M21,2H3A1,1,0,0,0,2,3H2A.94.94,0,0,0,3,4H21a.94.94,0,0,0,1-1h0A.94.94,0,0,0,21,2Z",
  fill: "#2563eb"
}), /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M2,21H2a.94.94,0,0,0,1,1H21a.94.94,0,0,0,1-1h0a.94.94,0,0,0-1-1H3A.94.94,0,0,0,2,21Z",
  fill: "#2563eb"
}), /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M9,15V9A.94.94,0,0,0,8,8H8A1,1,0,0,0,7,9v6a.94.94,0,0,0,1,1H8A1,1,0,0,0,9,15Z",
  fill: "#2563eb"
}), /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M17,15V9a.94.94,0,0,0-1-1h0a.94.94,0,0,0-1,1v6a.94.94,0,0,0,1,1h0A1.08,1.08,0,0,0,17,15Z",
  fill: "#2563eb"
}), /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M13,17V7a.94.94,0,0,0-1-1h0a.94.94,0,0,0-1,1V17a.94.94,0,0,0,1,1h0A.94.94,0,0,0,13,17Z",
  fill: "#2563eb"
}));
var teams = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M12 10c1.151 0 2-.848 2-2s-.849-2-2-2c-1.15 0-2 .848-2 2s.85 2 2 2zm0 1c-2.209 0-4 1.612-4 3.6v.386h8V14.6c0-1.988-1.791-3.6-4-3.6z"
}), /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M19 2H5c-1.103 0-2 .897-2 2v13c0 1.103.897 2 2 2h4l3 3 3-3h4c1.103 0 2-.897 2-2V4c0-1.103-.897-2-2-2zm-5 15l-2 2-2-2H5V4h14l.002 13H14z"
}));
var testimonial = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M19.7 1.5H4.3c-1.2 0-2.2 1-2.2 2.2v12.9c0 1.2 1 2.2 2.2 2.2h3.9l3.8 3.7 3.8-3.7h3.9c1.2 0 2.2-1 2.2-2.2V3.7c0-1.2-1-2.2-2.2-2.2zm0 15.1h-4.9L12 19.4l-2.8-2.8H4.3V3.7h15.4v12.9z"
}), /*#__PURE__*/React.createElement("circle", {
  cx: "7.5",
  cy: "10.1",
  r: "1.5"
}), /*#__PURE__*/React.createElement("circle", {
  cx: "12",
  cy: "10.1",
  r: "1.5"
}), /*#__PURE__*/React.createElement("circle", {
  cx: "16.5",
  cy: "10.1",
  r: "1.5"
}));
var video = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M8.8 8.8v6.5l6.4-3.2-6.4-3.3z"
}), /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M21 18.3H3c-.6 0-1-.4-1-1V6.7c0-.6.4-1 1-1h18c.6 0 1 .4 1 1v10.6c0 .6-.5 1-1 1z",
  fill: "none",
  stroke: "#000",
  strokeWidth: "2",
  strokeMiterlimit: "10"
}));
var column = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M2 6h20v12H2z",
  fill: "#2563eb"
}), /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  fill: "#fff",
  d: "M4 8h2.91v8H4zM8.36 8h2.91v8H8.36zM12.73 8h2.91v8h-2.91zM17.09 8H20v8h-2.91z"
}));
var barsO = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M21.9 7.5h-6v-5H8v7H2v11.9h20l-.1-13.9zM4 11.4h4v7.9H4v-7.9zm6-.9v-6h4v14.9h-4v-8.9zm9.9 8.9h-4V9.5h4v9.9z"
}));
var cartO = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M21.8 7.3c-.2-.3-.5-.4-.8-.4H7.3L6.2 4.2C5.8 3.4 5.1 3 4.4 3H2v2h2.3L9 16.3c.2.3.5.6 1 .6h8c.4 0 .8-.3 1-.6l2.9-8c.1-.3 0-.6-.1-1zm-4.5 7.6h-6.6L8.2 9h11.3l-2.2 5.9z"
}), /*#__PURE__*/React.createElement("circle", {
  cx: "10.5",
  cy: "19.5",
  r: "1.5"
}), /*#__PURE__*/React.createElement("circle", {
  cx: "17.4",
  cy: "19.5",
  r: "1.5"
}));
var envelopeO = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M21.5 4.2h-19c-.3 0-.5.2-.5.4v14.7c0 .2.2.4.4.4h19c.2 0 .4-.2.4-.4V4.6c.2-.2 0-.4-.3-.4zm-1.5 2v.5l-8 6-8-6v-.5h16zM4 17.8V9.1l7.4 5.6c.2.2.4.2.6.2s.4-.1.6-.2L20 9.1v8.7H4z"
}));
var eyeO = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M12 17.9c-4.2 0-7.9-2.1-9.9-5.5-.2-.3-.2-.6 0-.9C4.1 8.2 7.8 6 12 6s7.9 2.1 9.9 5.5c.2.3.2.6 0 .9-2 3.4-5.7 5.5-9.9 5.5zM3.9 12c1.6 2.6 4.8 4.2 8.1 4.2s6.4-1.6 8.1-4.2c-1.6-2.6-4.7-4.2-8.1-4.2S5.6 9.4 3.9 12zm8.1 3.3c-1.8 0-3.3-1.5-3.3-3.3s1.5-3.3 3.3-3.3 3.3 1.5 3.3 3.3-1.5 3.3-3.3 3.3zm0-4.9c-.9 0-1.6.8-1.6 1.6 0 .9.8 1.6 1.6 1.6s1.6-.8 1.6-1.6c0-.9-.7-1.6-1.6-1.6z"
}));
var instagramO = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M12 8c-2.3 0-4 1.8-4 4 0 2.3 1.8 4 4 4 2.3 0 4-1.8 4-4 0-2.3-1.7-4-4-4zm0 6.6c-1.5 0-2.6-1.1-2.6-2.6s1.1-2.6 2.6-2.6 2.6 1.1 2.6 2.6-1.1 2.6-2.6 2.6z"
}), /*#__PURE__*/React.createElement("circle", {
  cx: "16.2",
  cy: "7.8",
  r: "1"
}), /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M21.4 5.5c-.5-1.3-1.6-2.4-2.9-2.9-.8-.3-1.6-.4-2.4-.4C15 2 14.7 2 12 2s-3 0-4.1.1c-.9 0-1.6.2-2.4.4-1.4.5-2.4 1.6-2.9 3-.3.7-.5 1.5-.5 2.3C2 8.9 2 9.3 2 12s0 3 .1 4.1c0 .9.2 1.6.4 2.4.5 1.3 1.6 2.4 2.9 2.9.8.3 1.6.4 2.4.5 1.2.1 1.5.1 4.2.1s3 0 4.1-.1c.9 0 1.6-.2 2.4-.4 1.3-.5 2.4-1.6 2.9-2.9.3-.8.4-1.6.4-2.4.1-1 .1-1.4.1-4.1s0-3-.1-4.1c.1-1-.1-1.8-.4-2.5zm-1.3 10.4c0 .6-.1 1.3-.3 1.9-.3.9-1 1.6-1.9 1.9-.6.3-1.2.3-1.8.3-1 .1-1.4.1-4.1.1s-2.9 0-4.1-.1c-.6 0-1.2-.1-1.8-.3-.9-.3-1.6-1-1.9-1.9-.3-.6-.3-1.2-.3-1.8-.1-1-.1-1.4-.1-4.1s0-2.9.1-4.1c0-.6.1-1.3.3-1.9.3-.9 1-1.6 1.9-1.9.6-.3 1.2-.3 1.8-.3h4.2c2.8 0 2.9 0 4.1.1.6 0 1.2.1 1.8.3.9.3 1.6 1 1.9 1.9.3.6.3 1.2.3 1.8.1 1 .1 1.4.1 4.1-.2 2.7-.2 3-.2 4z"
}));
var mapMarkerO = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M12 13.7c1.9 0 3.5-1.6 3.5-3.5S13.9 6.8 12 6.8s-3.5 1.6-3.5 3.5 1.6 3.4 3.5 3.4zm0-5.2c1 0 1.7.8 1.7 1.7S13 12 12 12s-1.7-.8-1.7-1.7.7-1.8 1.7-1.8z"
}), /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M11.4 21.9c.2.1.3.2.6.2s.4-.1.6-.2c.3-.2 7.5-5.4 7.4-11.9 0-4.5-3.6-8-8-8s-8 3.6-8 8c0 6.5 7.1 11.6 7.4 11.9zM12 4c3.3 0 6 2.7 6 6 0 4.5-4.4 8.5-6 9.8-1.7-1.3-6-5.3-6-9.8 0-3.3 2.7-6 6-6z"
}));
var phoneO = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M21.9 17.9l-5.5-5.5-2.3 2.3c-.8-.3-2.2-.8-3-1.6s-1.4-2.3-1.6-3l2.3-2.3-5.7-5.7-3.4 3.4c-.5.5-.6 1-.6 1.5 0 1.5.4 6.5 4.4 10.5s9.1 4.4 10.5 4.4c.5 0 1-.2 1.5-.6l3.4-3.4zm-4.9 2c-1.3 0-5.6-.3-9.1-3.8S4.1 8.2 4.1 7l2.1-2.1 2.7 2.7-1.4 1.3c-.3.3-.3.6-.3 1 0 .1.6 2.9 2.3 4.6s4.5 2.3 4.6 2.3c.3.1.7 0 1-.3l1.3-1.3 2.7 2.7-2.1 2z"
}));
var paperPlaneO = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M21.6 2.2c-.3-.2-.7-.3-1-.1l-18 8.4c-.4.2-.6.5-.6 1s.3.8.6 1L8.3 15v7l6.2-4.4 5.1 2.2c.2.1.3.1.4.1.2 0 .3-.1.5-.2.3-.2.5-.5.5-.9L22 3c0-.2-.2-.6-.4-.8zM19 17.3l-5.6-2.4 3.3-6.5-8.1 4.4-3-1.4 14.2-6.7-.8 12.6z"
}));
var quoteLeft = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M3.6 6.3C5 4.8 7.2 4 10 4h1v2.8l-.8.2c-1.4.2-2.3.8-2.8 1.6-.4.4-.5 1-.5 1.4h3c.5 0 1 .4 1 1v7c0 1.1-.9 2-2 2H3c-.5 0-1-.4-1-1v-8s-.2-2.7 1.6-4.7zM20 20h-6c-.5 0-1-.4-1-1v-7.9c0-.1-.2-2.8 1.7-4.8C16.1 4.8 18.3 4 21.1 4h1v2.7l-.9.3c-1.4.3-2.3.8-2.9 1.6-.3.5-.4 1-.4 1.4h3c.5 0 1 .4 1 1v7c.1 1.1-.8 2-1.9 2z"
}));
var quoteRight = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M20.3 17.7C22.2 15.6 22 13 22 13V5c0-.5-.4-1-1-1h-6c-1.1 0-2 .9-2 2v7c0 .5.4 1 1 1h3c0 .4-.1.9-.4 1.4-.5.8-1.5 1.3-2.9 1.7l-.7.1V20h1c2.8 0 4.9-.8 6.3-2.3zm-11 0C11.2 15.6 11 13 11 13V5c0-.5-.4-1-1-1H4c-1.1 0-2 .9-2 2v7c0 .5.4 1 1 1h3c0 .4-.1.9-.4 1.4-.5.8-1.5 1.3-2.9 1.7l-.7.1V20h1c2.8 0 4.9-.8 6.3-2.3z"
}));
var recorderO = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M18 10c0-1.1-.9-2-2-2h-1.4l-2.4-4c-.3-.6-1-1-1.7-1H5v2h5.4l1.8 3H4c-1.1 0-2 .9-2 2v8.9c0 1.1.9 2 2 2h12c1.1 0 2-.9 2-2v-3l4 2V11l-4 2v-3zm-2 8.9H4V10h12v8.9z"
}), /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M7 15.1h6v2H7v-2z"
}));
var searchMinus = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M6.8 9.3h7V11h-7V9.3z"
}), /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M10.6 19.1c2 0 3.8-.7 5.2-1.8l4.7 4.7 1.5-1.5-4.7-4.7c1.1-1.5 1.8-3.3 1.8-5.2 0-4.7-3.8-8.5-8.5-8.5S2 5.9 2 10.6s3.9 8.5 8.6 8.5zm0-15c3.6 0 6.4 2.9 6.4 6.4S14.1 17 10.6 17s-6.4-3-6.4-6.5 2.9-6.4 6.4-6.4z"
}));
var searchO = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M10.6 19.1c2 0 3.8-.7 5.2-1.8l4.7 4.7 1.5-1.5-4.7-4.7c1.1-1.5 1.8-3.3 1.8-5.2 0-4.7-3.8-8.6-8.6-8.6S2 5.8 2 10.6s3.8 8.5 8.6 8.5zm0-15c3.6 0 6.5 2.9 6.5 6.5s-3 6.4-6.5 6.4-6.4-3-6.4-6.5 2.9-6.4 6.4-6.4z"
}));
var sendO = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M21.3 11L3.5 2.7c-.3-.2-.8-.1-1.1.2-.3.2-.5.6-.4 1L4 12l-2 8.1c-.1.4 0 .8.3 1 .2.2.4.3.7.3.2 0 .3 0 .4-.1l18-8.3c.3-.2.6-.5.6-1s-.4-.8-.7-1zM4.6 18.5l.8-3.5 6-3-6-3-.8-3.5L18.4 12 4.6 18.5z"
}));
var thumbsUpO = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M19.7 8.5h-5.5l1.1-3.3c.2-.6.1-1.3-.3-1.8-.3-.5-1-.9-1.6-.9h-1.6c-.3 0-.6.2-.8.3L6.5 8.5H4c-1.1 0-2 .9-2 2v8.9c0 1.1.9 2 2 2h13.2c.9 0 1.6-.5 1.9-1.3l2.8-7.3c0-.1.1-.3.1-.3v-2c-.3-1.1-1.1-2-2.3-2zM4 10.5h2v8.9H4v-8.9zm15.7 1.8L17 19.4H7.9V9.8l4.4-5.3h1.1l-1.6 4.6c0 .4 0 .7.2.9.2.3.5.4.8.4h6.9v1.9z"
}));
var timeO = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M12 2C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2zm0 18c-4.4 0-8-3.6-8-8s3.6-8 8-8 8 3.6 8 8-3.6 8-8 8z"
}), /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M12 6H9.8v8.6H18v-2.2h-6V6z"
}));
var userO = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M12 2C9.1 2 6.7 4.4 6.7 7.3S9 12.6 12 12.6s5.3-2.3 5.3-5.3S14.9 2 12 2zm0 8.4c-1.7 0-3.1-1.4-3.1-3.1s1.4-3.2 3.1-3.2 3.1 1.4 3.1 3.1-1.4 3.2-3.1 3.2zM21.5 22v-1c0-4.1-3.3-7.4-7.4-7.4H9.9c-4.1 0-7.4 3.3-7.4 7.4v1h2.1v-1c0-2.9 2.3-5.3 5.3-5.3h4.2c2.9 0 5.3 2.3 5.3 5.3v1h2.1z"
}));
var youtubePlay = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M3.7 2v20l16.7-10L3.7 2z"
}));
var bar = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M2 5h10v2H2V5zm0 6h20v2H2v-2zm10 6h10v2H12v-2z"
}));
var behance = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M7.8 6c.6 0 1.2.1 1.6.2.5.1 1 .3 1.2.5.3.3.6.6.9 1 .2.4.3.9.3 1.4s-.2 1.1-.4 1.6c-.3.4-.7.8-1.2 1 .8.3 1.3.6 1.6 1.1.3.6.6 1.1.6 2 0 .6-.1 1.1-.3 1.6-.3.4-.6.9-1 1-.4.3-1 .5-1.4.7-.5.2-1 .2-1.6.2H2V6h5.8zm-.4 5c.5 0 1-.1 1.1-.3.3-.3.5-.6.5-1 0-.3-.1-.5-.2-.7 0-.3-.1-.4-.3-.5-.1-.2-.3-.3-.6-.3-.1-.1-.4-.1-.7-.1H4.8V11h2.6zm.2 5.2c.3 0 .5 0 .8-.1.3-.1.4-.2.7-.3.1-.1.3-.3.3-.5.1-.2.2-.5.2-.9 0-.7-.2-1-.5-1.3-.3-.3-.9-.4-1.4-.4H4.8v3.4l2.8.1c0-.1 0 0 0 0zm8.6 0c.3.3 1 .5 1.6.5.5 0 1-.1 1.2-.3.3-.3.6-.5.7-.8h2.2c-.3 1-.9 1.8-1.6 2.3-.8.5-1.6.7-2.6.7-.7 0-1.3-.1-1.9-.3s-1-.6-1.4-1c-.4-.4-.7-1-1-1.5-.3-.6-.3-1.2-.3-1.9s.1-1.2.3-1.8c.3-.6.5-1 1-1.5s1-.8 1.4-1c.6-.3 1.1-.3 1.8-.3.8 0 1.4.2 2 .4.6.3 1 .7 1.4 1.1.3.5.6 1 .8 1.6.3.6.3 1.2.3 1.9h-6.4c-.1.8.1 1.4.5 1.9zm2.7-4.7c-.3-.3-.8-.5-1.4-.5-.4 0-.8.1-1 .2-.3.2-.5.3-.6.5-.2.2-.3.4-.3.7-.1.3-.1.4-.1.6h3.9c.1-.7-.2-1.2-.5-1.5zM15 6.9h5v1.2h-5V6.9z"
}));
var blogger = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M21.9 10.6c-.1-.3-.3-.7-.5-.9-.1 0-.6-.1-1.1-.1-.9 0-1-.1-1.3-.3-.4-.3-.6-.5-.6-1.3 0-1.5-.6-2.9-1.8-4.1-.9-.9-1.8-1.5-3-1.8-.3-.1-.9-.1-2.8-.2-3.2.1-3.8.1-4.9.5-1.8.9-3.2 2.5-3.7 4.6-.1.4-.1 1-.2 4.6 0 4.5 0 5.2.3 6.1.3.8.4 1.2 1 1.8 1 1.2 2.4 2.1 3.7 2.4.7.1 8.8.2 9.7 0 1.5-.2 2.6-.8 3.7-1.9.8-.8 1.2-1.7 1.6-2.8.1-.4.2-.7.2-3.5-.2-1.9-.2-2.8-.3-3.1zM7.6 7.7c.3-.3.4-.3 2.6-.3 2 0 2 0 2.4.2.4.2.6.5.6 1s-.2.7-.5 1c-.2.1-.3.2-2.3.2-1.2 0-2.1 0-2.3-.1-.8-.3-1.1-1.4-.5-2zm8.5 9l-.6.1H12c-3 0-3.9 0-4.1-.1-.3-.2-.6-.5-.7-.9 0-.3.2-.7.4-1 .3-.3.4-.3 4.4-.3s4 0 4.4.3c.5.6.4 1.6-.3 1.9z"
}));
var check = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M7.7 16.8l-4.3-4.1L2 14.1l5.7 5.4L21.9 5.9l-1.5-1.4L7.7 16.8z"
}));
var icons_close = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M12 10.6L3.4 2 2 3.3l8.6 8.6L2 20.4l1.4 1.4 8.6-8.5 8.5 8.5 1.4-1.4-8.5-8.5L22 3.5l-1.4-1.3-8.6 8.4z"
}));
var codeopen = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M21.6 8.6l-.3-.3-9.1-6c-.3-.2-.6-.2-.9 0l-9.1 6c0 .1-.1.2-.2.3v6.5c0 .2 0 .3.2.4.1.1.2.2.3.2l9.1 6c.1.1.3.2.4.2s.3-.1.4-.2l9.1-6 .3-.3c.1-.2.2-.3.2-.4V9c-.2-.1-.3-.3-.4-.4zm-8.9-4.1l6.9 4.6-3.2 2.1-3.7-2.5c-.1-.1 0-4.2 0-4.2zm-1.6 0v4.2l-3.7 2.5L4.3 9l6.8-4.5zm-7.5 6L6 12.1l-2.4 1.6v-3.2zm7.5 9.2l-6.9-4.6L7.4 13l3.7 2.5v4.2zm.8-5.6L8.8 12l3.1-2.1L15 12l-3.1 2.1zm.8 5.6v-4.3l3.7-2.5 3.2 2.2-6.9 4.6zm7.5-6l-2.4-1.6 2.4-1.6v3.2z"
}));
var delicious = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M21.9 3.6c0-.1 0-.1-.1-.2 0-.1-.1-.2-.1-.3-.1-.1-.1-.2-.2-.3l-.3-.3-.1-.1c-.1 0-.1-.1-.2-.1s-.2-.1-.2-.1c-.1 0-.2-.1-.2-.1-.3-.1-.5-.1-.6-.1H4.1C3 2 2 3 2 4.1v15.7c0 .2 0 .4.1.5.1.3.3.7.5.9l.1.1c.3.2.6.4.9.5.2.2.4.2.5.2h15.7c1.2 0 2.1-1 2.1-2.1V4.1c.1-.1.1-.3 0-.5zm-1.3 16.3c0 .4-.3.7-.7.7H12V12H3.4V4.1c0-.4.3-.7.7-.7H12V12h8.6v7.9z"
}));
var devianart = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M18 2h-3.5l-.3.3-1.7 3.3-.6.4H6v5h3.3l.3.3-3.5 7V22h3.5l.3-.3 1.7-3.3.5-.3H18V13h-3.3l-.3-.3 3.5-7C18 5.7 18 2 18 2z"
}));
var dribble = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M20.7 6.9c-.9-1.6-2.1-2.8-3.6-3.6S13.8 2 12 2s-3.5.4-5 1.3c-1.5 1-2.7 2.2-3.6 3.6S2 10.2 2 12s.4 3.5 1.3 5 2.1 2.8 3.6 3.6c1.6.9 3.2 1.3 5 1.3s3.5-.4 5-1.3c1.6-.9 2.8-2.1 3.6-3.6s1.3-3.2 1.3-5-.3-3.5-1.1-5.1zM12 3.6c2 0 3.7.6 5.3 1.9-.9 1.2-2.3 2.2-4.1 3-1-1.8-2.1-3.4-3.2-4.6.6-.2 1.3-.3 2-.3zM5.5 6.8c.8-1 1.6-1.6 2.7-2.3 1.2 1.2 2.3 2.7 3.3 4.5-2 .6-4.1.9-6.3.9H3.8c.5-1.1 1-2.2 1.7-3.1zM3.7 12v-.4h1.1c2.7 0 5.1-.3 7.5-1.1.2.3.3.8.6 1.2-1.3.3-2.7 1-4.1 2.2s-2.4 2.3-3 3.6c-1.4-1.6-2.1-3.4-2.1-5.5zm8.3 8.3c-1.9 0-3.6-.6-5.1-1.7.6-1.2 1.6-2.3 2.8-3.4 1.2-1 2.5-1.7 3.7-2 .8 2.2 1.3 4.3 1.6 6.6-1 .3-2 .5-3 .5zm7-4c-.7 1-1.6 1.9-2.6 2.6-.3-2.1-.7-4.1-1.4-6.1 1-.1 1.7-.1 2.5-.1s1.6 0 2.7.1c0 1.3-.5 2.5-1.2 3.5zm-1.2-4.9c-1.1 0-2.3.1-3.2.2-.3-.7-.5-1.2-.7-1.6 2.1-.9 3.6-2 4.4-3.3 1.2 1.4 1.8 3 2 4.9-.8-.2-1.6-.2-2.5-.2z"
}));
var facebook = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M13.7 13.3V22H9.6v-8.7H6.5V9.7h3.1V6.9c0-3.1 2-4.9 4.9-4.9 1.3 0 3 .3 3 .3v3h-1.7c-1.6 0-2 1-2 1.9v2.4h3.3l-.6 3.7h-2.8z"
}));
var linkedin = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M6.6 4.9C6.6 6 5.6 7 4.3 7 3 6.9 2.1 6 2.1 4.9s1-2.1 2.3-2.1c1.3 0 2.2.9 2.2 2.1zM2.1 21h4.6V8.2H2.1V21zM17 7.9c-2.2 0-3.3 1.2-3.8 2.2V8.2H8.9C9 9.4 8.9 21 8.9 21h4.2v-7.1c0-.4 0-.8.2-1 .3-.8 1-1.6 2.2-1.6 1.6 0 2.2 1.1 2.2 2.9v6.9H22v-7.6c-.1-3.8-2.1-5.6-5-5.6z",
  fillRule: "evenodd",
  clipRule: "evenodd"
}));
var medium = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M4.4 7.3c0-.3-.1-.5-.3-.7L2.3 4.4v-.3h5.8l4.5 9.8 3.9-9.8H22v.3L20.4 6c-.2.1-.2.3-.2.4v11.1c0 .2 0 .3.2.4l1.6 1.6v.3h-7.8v-.3l1.6-1.6c.2-.2.2-.2.2-.4v-9l-4.5 11.3h-.6L5.7 8.5v7.6c0 .3.1.6.3.9l2.1 2.5v.3H2v-.3L4.1 17c.3-.3.3-.5.3-.9V7.3z"
}));
var minus = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M2 11h20v2H2v-2z"
}));
var pinterest = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M11.9 2.1C6.4 2.1 2 6.5 2 12.1c0 4.3 2.6 7.8 6.3 9.3-.1-.8-.2-2 0-2.9.2-.8 1.1-4.9 1.1-4.9s-.3-.6-.3-1.5c0-1.4.8-2.4 1.8-2.4.9 0 1.3.6 1.3 1.4 0 .9-.5 2.2-.9 3.3-.3 1 .5 1.8 1.5 1.8 1.7 0 3.1-1.9 3.1-4.6 0-2.4-1.7-4.1-4.2-4.1-2.9 0-4.5 2.2-4.5 4.3 0 .9.3 1.7.8 2.3.1.1.1.2.1.3-.1.3-.3 1-.3 1.1-.1.2-.2.3-.3.2-1.2-.6-2-2.4-2-3.9 0-3.1 2.3-6.1 6.6-6.1 3.5 0 6.2 2.4 6.2 5.7 0 3.5-2.2 6.2-5.2 6.2-1 0-2-.5-2.3-1.1 0 0-.5 1.9-.6 2.3-.3.9-.9 2-1.2 2.6 1 .3 1.9.4 3 .4 5.6 0 10-4.4 10-10s-4.6-9.7-10.1-9.7"
}));
var plus = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M22 11h-9.1V2h-2v9H2v2h9v9h2v-9h9v-2z"
}));
var quora = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M12.5 17.5c-.7-1.4-1.5-2.7-3.1-2.7-.3 0-.6.1-.9.2L8 14c.7-.6 1.7-1 3.1-1 2.1 0 3.2 1 4.1 2.4.5-1.1.8-2.6.8-4.5 0-4.7-1.5-7.1-4.9-7.1s-4.8 2.4-4.8 7.1c0 4.6 1.5 7 4.8 7 .5-.2 1-.2 1.4-.4zm.9 1.7c-.7.2-1.5.3-2.3.3-4.5 0-8.8-3.6-8.8-8.7C2.3 5.6 6.7 2 11.1 2c4.5 0 8.9 3.6 8.9 8.8 0 3-1.4 5.3-3.3 6.8.6 1 1.3 1.6 2.2 1.6 1 0 1.4-.8 1.5-1.4h1.3c.1.8-.3 4.2-4 4.2-2.3 0-3.4-1.3-4.3-2.8z"
}));
var reddit = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement("circle", {
  cx: "10",
  cy: "12.9",
  r: ".9"
}), /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M13.8 15c-.5.3-1.2.5-1.8.5-.6 0-1.3-.2-1.8-.5-.1-.1-.2-.1-.3 0-.1.1-.1.3 0 .3.6.4 1.4.7 2.2.7s1.6-.2 2.2-.7c.1-.1.1-.3 0-.3-.2-.1-.4-.1-.5 0zm.2-3c-.5 0-.9.3-.9.9 0 .5.3.9.9.9h.1c.5 0 .9-.4.9-.9-.1-.5-.5-.9-1-.9z"
}), /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M12 2C6.5 2 2 6.4 2 12c0 5.5 4.5 10 10 10s10-4.5 10-10c0-5.6-4.5-10-10-10zm5.8 11.3v.4c0 2.3-2.6 4.1-5.8 4.1S6.2 16 6.2 13.7v-.4c-.2-.1-.3-.2-.5-.3-.6-.5-.6-1.5-.1-2.1s1.5-.6 2.1-.1c1.1-.8 2.5-1.2 3.9-1.2l.8-3.5c0-.2.2-.3.3-.3l2.4.5c.3-.1.6-.3.9-.4.5-.1 1 .3 1.1.9.1.5-.3 1-.9 1.1-.5.1-1-.3-1.1-.9L13 6.6l-.6 3.1c1.4 0 2.7.4 3.8 1.2.3-.3.6-.4 1-.4.8 0 1.5.6 1.5 1.4 0 .6-.4 1.1-.9 1.4z"
}));
var reply = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M10.5 10.9h6.2v7.2h2V10c0-.6-.5-1.1-1.1-1.1h-7.1v-3L5.4 10l5 4.1.1-3.2z"
}));
var rss = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M22 22C22 11 13 2 2 2v2.7c9.6 0 17.3 7.7 17.3 17.3H22z"
}), /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M12.7 22h2.7C15.3 14.6 9.4 8.7 2 8.7v2.7c5.9-.1 10.7 4.7 10.7 10.6z"
}), /*#__PURE__*/React.createElement("circle", {
  cx: "4.7",
  cy: "19.3",
  r: "2.7"
}));
var tumblr = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M14.3 22c-3 0-5.2-1.6-5.2-5.2v-5.9H6.4V7.7c3-.8 4.3-3.4 4.4-5.6h3.1v5.1h3.6v3.7h-3.6V16c0 1.6.8 2.1 2 2.1h1.7V22h-3.3z"
}));
var twitch = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M4.4 2L3 5.5v14h4.8v1.6l2.7.9 2.5-2.5h3.9l5.2-5.2V2H4.4zm15.8 11.3l-2.9 3h-4.8L10 18.9v-2.5H6V3.9h14.3l-.1 9.4zm-3-6v5.2h-1.8V7.3h1.8zm-4.7 0v5.2h-1.8V7.3h1.8z"
}));
var twitter = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M8.3 20c7.6 0 11.6-6.2 11.6-11.6v-.5c.9-.6 1.5-1.3 2.1-2.1-.8.3-1.6.6-2.3.7.9-.5 1.5-1.3 1.8-2.2-.9.5-1.6.9-2.6 1-1.6-1.6-4.1-1.7-5.8-.2-1.1.9-1.6 2.4-1.2 3.8-3.3-.1-6.3-1.7-8.3-4.2-1.2 1.7-.7 4 1.1 5.3-.6 0-1.3-.2-1.8-.5v.1c0 1.9 1.4 3.6 3.3 4-.6.2-1.2.2-1.8.1.5 1.6 2.1 2.8 3.8 2.8-1.4 1.1-3.3 1.7-5.1 1.7-.3 0-.7 0-1-.1C4 19.4 6.1 20 8.3 20"
}));
var vimeo = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M21 10.4c-2 4.3-7 10.3-10.1 10.3-3 0-3.5-6.5-5.1-10.9C5 7.7 4.5 8.2 3 9.2L2 8c2.3-2 4.5-4.3 5.9-4.4 1.6-.2 2.5 1 2.9 3.2.4 3 1.1 7.7 2.3 7.7.9 0 3.1-3.7 3.2-5 .2-1.9-1.4-2-2.9-1.4C15.7.8 25 2.1 21 10.4z"
}));
var wordpress = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M19.9 7.7C20.6 9 21 10.4 21 12c0 3.3-1.8 6.2-4.4 7.7l2.8-7.9c.5-1.3.7-2.3.7-3.2-.2-.3-.2-.6-.2-.9m-6.7 0c.5 0 1-.1 1-.1.5-.1.4-.8-.1-.8 0 0-1.5.1-2.4.1-.9 0-2.3-.1-2.3-.1-.4 0-.5.8 0 .8 0 0 .4.1 1 .1l1.4 3.8-2 5.9-3.4-9.7c.5 0 1-.1 1-.1.6 0 .5-.7.1-.6H4.4C6.1 4.6 8.9 3 12 3c2.3 0 4.4.9 6.1 2.3H18c-.9 0-1.5.8-1.5 1.6s.5 1.4.9 2.1c.3.6.8 1.4.8 2.5 0 .8-.3 1.7-.7 2.9l-.9 3-3.4-9.7zM12 21c-.9 0-1.7-.1-2.5-.3l2.7-7.8 2.8 7.6c0 .1 0 .1.1.1-1 .2-2.1.4-3.1.4m-9-9c0-1.3.3-2.5.8-3.7L8.1 20C5 18.6 3 15.6 3 12m9-10C6.5 2 2 6.5 2 12s4.5 10 10 10 10-4.5 10-10S17.5 2 12 2"
}));
var yelp = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M19.6 17.3c-.1.8-1.7 2.9-2.5 3.2-.3.1-.5.1-.7-.1-.1-.1-.3-.3-2-3.2l-.5-.9c-.2-.3-.2-.7.1-1 .3-.3.6-.4 1-.3l1.3.4c3 1 3.1 1 3.2 1.1.1.2.2.5.1.8zm-6-4.5c-.2-.3-.2-.7 0-1l.9-1.1c1.8-2.5 1.9-2.6 2.1-2.7.2-.2.4-.2.7 0 .7.3 2.2 2.5 2.3 3.4 0 .3-.1.5-.3.7-.2.1-.3.2-3.7 1-.5.2-.9.2-1 .3-.4 0-.8-.2-1-.6zm-2.1-1.3c-.2.1-.7.2-1.3-.8 0 0-4.1-6.4-4.2-6.7-.1-.1 0-.3.2-.6.6-.6 3.9-1.6 4.8-1.4.3.1.5.3.5.5.1.3.4 6.3.5 7.7.2 1.1-.3 1.3-.5 1.3zm.6 6.6c0 3.1 0 3.2-.1 3.4-.1.3-.3.4-.6.4-.8.2-3.3-.8-3.8-1.4-.1-.2-.2-.3-.2-.4v-.3c.1-.2.2-.3 2.4-3l.7-.8c.3-.3.6-.3 1-.3.3.2.6.4.5.8v1.6zm-6.9-2c-.3 0-.4-.2-.6-.4-.1-.2-.2-.4-.2-.9-.1-1 0-2.7.3-3.2.2-.3.3-.3.6-.3.2 0 .3.1 3.6 1.4l1 .3c.3.1.5.4.5.9 0 .3-.3.7-.6.8l-1.3.4c-3 1-3.1 1-3.3 1z"
}));
var buttons = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M19.27 12.91H4.73a1.83 1.83 0 0 0-1.82 1.82v5.45A1.83 1.83 0 0 0 4.73 22h14.54a1.83 1.83 0 0 0 1.82-1.82v-5.45a1.83 1.83 0 0 0-1.82-1.82Zm0 7.27H4.73v-5.45h14.54Z"
}), /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M7.45 18.36h9.1a.91.91 0 0 0 0-1.81h-9.1a.91.91 0 0 0 0 1.81ZM19.27 2H4.73a1.83 1.83 0 0 0-1.82 1.82v5.45a1.83 1.83 0 0 0 1.82 1.82h14.54a1.83 1.83 0 0 0 1.82-1.82V3.82A1.83 1.83 0 0 0 19.27 2Zm0 7.27H4.73V3.82h14.54Z"
}), /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M7.45 7.45h9.1a.85.85 0 0 0 .9-.9.85.85 0 0 0-.9-.91h-9.1a.85.85 0 0 0-.9.91.85.85 0 0 0 .9.9Z"
}));
;// CONCATENATED MODULE: ./src/blocks/utils/utils.js
/**
 * Gets the string representation of `arg`.
 *
 * @param {*} arg Function argument
 * @return {string} A string representation of `arg`
 */
var repr = function repr(arg) {
  return Object.prototype.toString.call(arg);
};
/**
 * Check if `arg` ia an array.
 *
 * @param {*} arg Function argument.
 * @return {boolean} Returns true if `arg` is an Array else false.
 */

var isArray = function isArray(arg) {
  return Array.isArray ? Array.isArray(arg) : repr(arg) === '[object Array]';
};
/**
 * Checks if `arg` is an object.
 *
 * @param {*} arg Function argument.
 * @return {boolean} Returns true if `arg` is an object.
 */

var isObject = function isObject(arg) {
  return repr(arg) === '[object Object]';
};
/**
 * Checks if `arg` is null.
 *
 * @param {*} arg :: unknown function argument
 * @return {boolean} :: returns true if `arg` is of type Null, false otherwise
 */

var isNull = function isNull(arg) {
  return repr(arg) === '[object Null]';
};
/**
 * Checks if `arg` is undefined.
 *
 * @param {*} arg Function argument
 * @return {boolean} Returns true if `arg` is of type Undefined, false otherwise
 */

var isUndefined = function isUndefined(arg) {
  try {
    return typeof arg === 'undefined';
  } catch (e) {
    if (e instanceof ReferenceError) {
      return true;
    }

    throw e;
  }
};
/**
 * Checks if `arg` is a string.
 *
 * @param {*} arg Function argument
 * @return {boolean} Returns true if `arg` is a String, false otherwise
 */

var isString = function isString(arg) {
  return repr(arg) === '[object String]';
};
/**
 * Checks if `arg` is an empty string, array, or object.
 *
 * @param {*} arg Function argument
 * @return {boolean} Returns true if `arg` is an empty string,
 *  array, or object. Also returns true is `arg` is null or
 *  undefined. Returns true otherwise.
 */

var isEmpty = function isEmpty(arg) {
  return isUndefined(arg) || isNull(arg) || isString(arg) && arg.length === 0 || isArray(arg) && arg.length === 0 || isObject(arg) && Object.keys(arg).length === 0;
};
/**
 * Uppercase first letter.
 *
 * @param {string} string String argument
 * @return {string} String with uppercase first letter.
 */

var ucFirst = function ucFirst(string) {
  return string.charAt(0).toUpperCase() + string.slice(1);
};
var getSiblings = function getSiblings(el) {
  if (el.parentNode === null) return [];
  return Array.from(el.parentNode.children).filter(function (child) {
    return child !== el;
  });
};
;// CONCATENATED MODULE: ./src/blocks/utils/css/meets-conditions.js
/* harmony default export */ const meets_conditions = (function (settings, selectData) {
  var depends = true;

  if (selectData !== null && selectData !== void 0 && selectData.condition) {
    selectData.condition.forEach(function (data) {
      var previous = depends;

      if (data.relation === '==' || data.relation === '===') {
        if (typeof data.value === 'string' || typeof data.value === 'number' || typeof data.value === 'boolean') {
          depends = settings[data.key] === data.value;
        } else {
          depends = !!data.value.includes(settings[data.key]);
        }
      } else if (data.relation === '!=' || data.relation === '!==') {
        if (typeof data.value === 'string' || typeof data.value === 'number' || typeof data.value === 'boolean') {
          depends = settings[data.key] !== data.value;
        } else {
          var selected = false;
          data.value.forEach(function (arrData) {
            if (settings[data.key] !== arrData) {
              selected = true;
            }
          });

          if (selected) {
            depends = true;
          }
        }
      }

      if (previous === false) {
        depends = false;
      }
    });
  }

  return depends;
});
;// CONCATENATED MODULE: ./src/blocks/utils/css/replace-placeholders.js

/* harmony default export */ const replace_placeholders = (function (str, placeholders) {
  Object.entries(placeholders).forEach(function (_ref) {
    var _ref2 = slicedToArray_slicedToArray(_ref, 2),
        tag = _ref2[0],
        value = _ref2[1];

    str = str.replaceAll("{{".concat(tag, "}}"), value);
  });
  return str;
});
;// CONCATENATED MODULE: ./src/blocks/constants/index.js

var DEVICES = {
  desktop: (0,external_wp_i18n_namespaceObject.__)('Desktop', 'blockart'),
  tablet: (0,external_wp_i18n_namespaceObject.__)('Tablet', 'blockart'),
  mobile: (0,external_wp_i18n_namespaceObject.__)('Mobile', 'blockart')
};
var DIMENSIONS_PROPERTIES = {
  top: (0,external_wp_i18n_namespaceObject.__)('Top', 'blockart'),
  right: (0,external_wp_i18n_namespaceObject.__)('Right', 'blockart'),
  bottom: (0,external_wp_i18n_namespaceObject.__)('Bottom', 'blockart'),
  left: (0,external_wp_i18n_namespaceObject.__)('Left', 'blockart')
};
;// CONCATENATED MODULE: ./src/blocks/utils/css/border-css.js



/* harmony default export */ const border_css = (function (props) {
  var settingValue = props.settingValue,
      settingDef = props.settingDef,
      blockName = props.blockName,
      blockID = props.blockID;
  var styles = settingDef === null || settingDef === void 0 ? void 0 : settingDef.style;
  settingValue = Object.assign({}, {
    type: 'none',
    size: {},
    radius: {},
    color: ''
  }, settingValue);
  var css = {
    allDevice: [],
    desktop: [],
    tablet: [],
    mobile: []
  };
  var tempCSS = {
    allDevice: [],
    desktop: [],
    tablet: [],
    mobile: []
  };
  var tempAllDeviceCSS = '';

  if (!styles) {
    return css;
  }

  styles.forEach(function (style) {
    if (!meets_conditions(props.settings, style)) {
      return;
    }

    var selector = replace_placeholders(style.selector, {
      WRAPPER: ".blockart-".concat(blockName, "-").concat(blockID)
    });

    if ('none' !== settingValue.type) {
      tempAllDeviceCSS += "".concat(settingValue.color ? "border-color: ".concat(settingValue.color, ";") : '', " border-style: ").concat(settingValue.type, ";");
      tempCSS.desktop.push(tempAllDeviceCSS);

      if (settingValue.size) {
        Object.keys(DEVICES).forEach(function (device) {
          if (!settingValue.size[device]) {
            return;
          }

          if ('undefined' === typeof settingValue.size[device].right && 'undefined' === typeof settingValue.size[device].top && 'undefined' === typeof settingValue.size[device].bottom && 'undefined' === typeof settingValue.size[device].left) {
            return;
          }

          var unit = settingValue.size[device].unit || 'px';
          var top = settingValue.size[device].top || 0;
          var right = settingValue.size[device].right || 0;
          var bottom = settingValue.size[device].bottom || 0;
          var left = settingValue.size[device].left || 0;
          tempCSS[device].push("border-width: ".concat(top).concat(unit, " ").concat(right).concat(unit, " ").concat(bottom).concat(unit, " ").concat(left).concat(unit, ";"));
        });
      }
    }

    if (settingValue.radius) {
      Object.keys(DEVICES).forEach(function (device) {
        if (!settingValue.radius[device]) {
          return;
        }

        if ('undefined' === typeof settingValue.radius[device].right && 'undefined' === typeof settingValue.radius[device].top && 'undefined' === typeof settingValue.radius[device].bottom && 'undefined' === typeof settingValue.radius[device].left) {
          return;
        }

        var unit = settingValue.radius[device].unit || 'px';
        var top = settingValue.radius[device].top || 0;
        var right = settingValue.radius[device].right || 0;
        var bottom = settingValue.radius[device].bottom || 0;
        var left = settingValue.radius[device].left || 0;
        tempCSS[device].push("border-radius: ".concat(top).concat(unit, " ").concat(right).concat(unit, " ").concat(bottom).concat(unit, " ").concat(left).concat(unit, ";"));
      });
    }

    Object.keys(css).forEach(function (type) {
      if (tempCSS[type].length > 0) {
        css[type].push("".concat(selector, "{ ").concat(tempCSS[type].join(''), " }"));
      }
    });
  });
  return css;
});
;// CONCATENATED MODULE: ./src/blocks/utils/css/dimension-css.js



/* harmony default export */ const dimension_css = (function (props) {
  var settingValue = props.settingValue,
      settingDef = props.settingDef,
      blockName = props.blockName,
      blockID = props.blockID;
  var styles = settingDef === null || settingDef === void 0 ? void 0 : settingDef.style;
  var css = {
    allDevice: [],
    desktop: [],
    tablet: [],
    mobile: []
  };

  if (!styles) {
    return css;
  }

  styles.forEach(function (style) {
    if (!meets_conditions(props.settings, style)) {
      return;
    }

    var selector = replace_placeholders(style.selector, {
      WRAPPER: ".blockart-".concat(blockName, "-").concat(blockID)
    });

    if (settingValue) {
      if (Object.keys(settingValue).some(function (v) {
        return Object.keys(DEVICES).includes(v);
      })) {
        Object.keys(DEVICES).forEach(function (device) {
          if (!settingValue[device]) {
            return;
          }

          if (!Object.keys(settingValue[device]).some(function (v) {
            return ['top', 'right', 'bottom', 'left', 'unit'].includes(v);
          })) {
            return;
          }

          var unit = settingValue[device].unit || 'px';
          var top = settingValue[device].top || 0;
          var right = settingValue[device].right || 0;
          var bottom = settingValue[device].bottom || 0;
          var left = settingValue[device].left || 0;
          css[device].push(replace_placeholders(selector, {
            VALUE: "".concat(top).concat(unit, " ").concat(right).concat(unit, " ").concat(bottom).concat(unit, " ").concat(left).concat(unit)
          }));
        });
      } else {
        if (!Object.keys(settingValue).some(function (v) {
          return ['top', 'right', 'bottom', 'left', 'unit'].includes(v);
        })) {
          return;
        }

        var unit = settingValue.unit || 'px';
        var top = settingValue.top || 0;
        var right = settingValue.right || 0;
        var bottom = settingValue.bottom || 0;
        var left = settingValue.left || 0;
        css.allDevice.push(replace_placeholders(selector, {
          VALUE: "".concat(top).concat(unit, " ").concat(right).concat(unit, " ").concat(bottom).concat(unit, " ").concat(left).concat(unit)
        }));
      }
    }
  });
  return css;
});
;// CONCATENATED MODULE: ./src/blocks/utils/css/background-css.js




var backgroundImageCSS = function backgroundImageCSS() {
  var _data$image;

  var data = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var cssForDevices = {
    allDevice: [],
    desktop: [],
    tablet: [],
    mobile: []
  };

  if (data !== null && data !== void 0 && (_data$image = data.image) !== null && _data$image !== void 0 && _data$image.url) {
    cssForDevices.desktop.push('background-image: url(' + data.image.url + ');');
  }

  if (data.attachment && 'default' !== data.attachment) {
    cssForDevices.desktop.push('background-attachment: ' + data.attachment + ';');
  }

  Object.keys(DEVICES).forEach(function (device) {
    var customSizeKey = 'customSize' + (device.charAt(0).toUpperCase() + device.slice(1));

    if (data.position && data.position[device] && 'default' !== data.position[device]) {
      cssForDevices[device].push("background-position: ".concat(data.position[device], ";"));
    }

    if (data.repeat && data.repeat[device] && 'default' !== data.repeat[device]) {
      cssForDevices[device].push("background-repeat: ".concat(data.repeat[device], ";"));
    }

    if (data.size && data.size[device] && 'default' !== data.size[device]) {
      if ('custom' !== data.size[device]) {
        cssForDevices[device].push("background-size: ".concat(data.size[device], ";"));
      }

      if ('custom' === data.size[device] && data[customSizeKey]) {
        cssForDevices[device].push("background-size: ".concat(data[customSizeKey].value + (data[customSizeKey].unit || ''), " auto;"));
      }
    }
  });
  return cssForDevices;
};

/* harmony default export */ const background_css = (function (props) {
  var settingValue = props.settingValue,
      settingDef = props.settingDef,
      blockName = props.blockName,
      blockID = props.blockID;
  var styles = settingDef === null || settingDef === void 0 ? void 0 : settingDef.style;
  var css = {
    allDevice: [],
    desktop: [],
    tablet: [],
    mobile: []
  };

  if (!styles) {
    return css;
  }

  styles.forEach(function (style) {
    if (!meets_conditions(props.settings, style)) {
      return;
    }

    var selector = replace_placeholders(style.selector, {
      WRAPPER: ".blockart-".concat(blockName, "-").concat(blockID)
    });
    settingValue.type = settingValue.type || 'color';
    var imageData = backgroundImageCSS(settingValue.image) || css;

    if (settingValue.color) {
      imageData.desktop.push("background-color: ".concat(settingValue.color, ";"));
    }

    Object.keys(css).forEach(function (type) {
      if (imageData[type].length > 0) {
        css[type].push("".concat(selector, "{ ").concat(imageData[type].join(''), " }"));
      }
    });
  });
  return css;
});
;// CONCATENATED MODULE: ./src/blocks/utils/css/box-shadow-css.js


/* harmony default export */ const box_shadow_css = (function (props) {
  var settingValue = props.settingValue,
      settingDef = props.settingDef,
      blockName = props.blockName,
      blockID = props.blockID;
  settingValue = Object.assign({}, {
    position: 'outline',
    horizontalX: 0,
    verticalY: 0,
    blur: 10,
    spread: 0,
    color: 'rgba(0,0,0, 0.5)'
  }, settingValue);
  var styles = settingDef === null || settingDef === void 0 ? void 0 : settingDef.style;
  var css = {
    allDevice: [],
    desktop: [],
    tablet: [],
    mobile: []
  };

  if (!styles || !settingValue.enable) {
    return css;
  }

  styles.forEach(function (style) {
    if (!meets_conditions(props.settings, style)) {
      return;
    }

    var selector = replace_placeholders(style.selector, {
      WRAPPER: ".blockart-".concat(blockName, "-").concat(blockID)
    });
    css.allDevice.push(selector + '{ box-shadow:' + (settingValue.position && 'inset' === settingValue.position ? settingValue.position : '') + ' ' + (settingValue.horizontalX ? settingValue.horizontalX : 0) + 'px ' + (settingValue.verticalY ? settingValue.verticalY : 0) + 'px ' + (settingValue.blur ? settingValue.blur : 0) + 'px ' + (settingValue.spread ? settingValue.spread : 0) + 'px ' + (settingValue.color || '#000') + '; }');
  });
  return css;
});
;// CONCATENATED MODULE: ./src/blocks/utils/css/advanced-css.js


/* harmony default export */ const advanced_css = (function (props) {
  var settingValue = props.settingValue,
      settingDef = props.settingDef,
      blockName = props.blockName,
      blockID = props.blockID,
      context = props.context;
  var styles = settingDef === null || settingDef === void 0 ? void 0 : settingDef.style;
  var css = {
    allDevice: [],
    desktop: [],
    tablet: [],
    mobile: []
  };

  if (!styles) {
    return css;
  }

  styles.forEach(function (style) {
    if (!meets_conditions(props.settings, style)) {
      return;
    }

    var selector = replace_placeholders(style.selector, {
      WRAPPER: ".blockart-".concat(blockName, "-").concat(blockID)
    });

    if (settingValue && 'save' === context) {
      css.allDevice.push(selector);
    }
  });
  return css;
});
;// CONCATENATED MODULE: ./src/blocks/utils/css/general-css.js




/* harmony default export */ const general_css = (function (props) {
  var settingValue = props.settingValue,
      settingDef = props.settingDef,
      blockName = props.blockName,
      blockID = props.blockID;
  var styles = settingDef === null || settingDef === void 0 ? void 0 : settingDef.style;
  var css = {
    allDevice: [],
    desktop: [],
    tablet: [],
    mobile: []
  };

  if (!styles) {
    return css;
  }

  styles.forEach(function (style) {
    if (!meets_conditions(props.settings, style)) {
      return;
    }

    var selector = replace_placeholders(style.selector, {
      WRAPPER: ".blockart-".concat(blockName, "-").concat(blockID)
    });

    if ('object' === typeof_typeof(settingValue) && settingValue) {
      if (['desktop', 'tablet', 'mobile'].some(function (d) {
        return Object.keys(settingValue).includes(d);
      })) {
        Object.keys(DEVICES).forEach(function (device) {
          if (settingValue[device]) {
            if ('object' === typeof_typeof(settingValue[device])) {
              if (settingValue[device].value) {
                css[device].push(replace_placeholders(selector, {
                  VALUE: settingValue[device].value + settingValue[device].unit || 'px'
                }));
              }
            } else {
              css[device].push(replace_placeholders(selector, {
                VALUE: settingValue[device]
              }));
            }
          }
        });
      } else {
        var _ref, _settingValue$value;

        css.allDevice.push(replace_placeholders(selector, {
          VALUE: (_ref = ((_settingValue$value = settingValue === null || settingValue === void 0 ? void 0 : settingValue.value) !== null && _settingValue$value !== void 0 ? _settingValue$value : 0) + (settingValue === null || settingValue === void 0 ? void 0 : settingValue.unit)) !== null && _ref !== void 0 ? _ref : 'px'
        }));
      }
    } else if (settingValue) {
      css.allDevice.push(replace_placeholders(selector, {
        VALUE: settingValue
      }));
    }
  });
  return css;
});
;// CONCATENATED MODULE: ./src/blocks/utils/css/typography-css.js



/* harmony default export */ const typography_css = (function (props) {
  var settingValue = props.settingValue,
      settingDef = props.settingDef,
      blockName = props.blockName,
      blockID = props.blockID;
  var styles = settingDef === null || settingDef === void 0 ? void 0 : settingDef.style;
  var css = {
    allDevice: [],
    desktop: [],
    tablet: [],
    mobile: []
  },
      tempCSS = {
    allDevice: [],
    desktop: [],
    tablet: [],
    mobile: []
  };
  var font = '';

  if (!styles) {
    return css;
  }

  styles.forEach(function (style) {
    if (!meets_conditions(props.settings, style)) {
      return;
    }

    var selector = replace_placeholders(style.selector, {
      WRAPPER: ".blockart-".concat(blockName, "-").concat(blockID)
    });

    if (settingValue.family && settingValue.family !== 'Default') {
      font += "@import url('https://fonts.googleapis.com/css?family=".concat(settingValue.family.replace(' ', '+'), ":").concat(settingValue.weight || 400, "&display=swap');");
      tempCSS.desktop.push("font-family: ".concat(settingValue.family, ", ").concat(settingValue.type || 'sans-serif', ";"));
    }

    if (settingValue.weight) {
      tempCSS.desktop.push("font-weight: ".concat(settingValue.weight, ";"));
    }

    if (settingValue.transform && 'default' !== settingValue.transform) {
      tempCSS.desktop.push("text-transform: ".concat(settingValue.transform, ";"));
    }

    if (settingValue.decoration && 'default' !== settingValue.decoration) {
      tempCSS.desktop.push("text-decoration: ".concat(settingValue.decoration, ";"));
    }

    Object.keys(DEVICES).forEach(function (device) {
      if (settingValue.size && settingValue.size[device]) {
        if (settingValue.size[device].value) {
          tempCSS[device].push("font-size: ".concat(settingValue.size[device].value).concat(settingValue.size[device].unit || 'px', ";"));
        }
      }

      if (settingValue.lineHeight && settingValue.lineHeight[device]) {
        if (settingValue.lineHeight[device].value) {
          tempCSS[device].push("line-height: ".concat(settingValue.lineHeight[device].value).concat(settingValue.lineHeight[device].unit || 'px', ";"));
        }
      }

      if (settingValue.letterSpacing && settingValue.letterSpacing[device]) {
        if (settingValue.letterSpacing[device].value) {
          tempCSS[device].push("letter-spacing: ".concat(settingValue.letterSpacing[device].value).concat(settingValue.letterSpacing[device].unit || 'px'));
        }
      }
    });
    Object.keys(css).forEach(function (type) {
      if (tempCSS[type].length > 0) {
        css[type].push("".concat(selector, "{ ").concat(tempCSS[type].join(''), " }"));
      }
    });

    if (font) {
      css.allDevice.unshift(font);
    }
  });
  return css;
});
;// CONCATENATED MODULE: ./src/blocks/utils/css/generate-block-css.js



function generate_block_css_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function generate_block_css_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? generate_block_css_ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : generate_block_css_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }









var settingStyleGenerators = {
  empty: function empty() {
    return {
      allDevice: [],
      desktop: [],
      tablet: [],
      mobile: []
    };
  },
  border: function border(props) {
    return border_css(props);
  },
  dimension: function dimension(props) {
    return dimension_css(props);
  },
  background: function background(props) {
    return background_css(props);
  },
  boxShadow: function boxShadow(props) {
    return box_shadow_css(props);
  },
  typography: function typography(props) {
    return typography_css(props);
  },
  advanced: function advanced(props) {
    return advanced_css(props);
  },
  general: function general(props) {
    return general_css(props);
  }
};

var getSettingStyleGenerator = function getSettingStyleGenerator(settingName, settingValue) {
  if (settingValue !== null && settingValue !== void 0 && settingValue.border) {
    return settingStyleGenerators.border;
  } else if (settingValue !== null && settingValue !== void 0 && settingValue.background) {
    return settingStyleGenerators.background;
  } else if (settingValue !== null && settingValue !== void 0 && settingValue.typography) {
    return settingStyleGenerators.typography;
  } else if (settingValue !== null && settingValue !== void 0 && settingValue.boxShadow) {
    return settingStyleGenerators.boxShadow;
  } else if (settingValue !== null && settingValue !== void 0 && settingValue.dimension) {
    return settingStyleGenerators.dimension;
  } else if (['hideOnDesktop', 'hideOnTablet', 'hideOnMobile', 'colReverseOnTablet', 'colReverseOnMobile'].includes(settingName)) {
    return settingStyleGenerators.advanced;
  }

  return settingStyleGenerators.general;
};

/* harmony default export */ const generate_block_css = (function (_ref) {
  var settings = _ref.settings,
      blockName = _ref.blockName,
      blockID = _ref.blockID,
      _ref$deviceType = _ref.deviceType,
      deviceType = _ref$deviceType === void 0 ? 'desktop' : _ref$deviceType,
      _ref$context = _ref.context,
      context = _ref$context === void 0 ? 'editor' : _ref$context;

  if (!blockID) {
    return '';
  }

  var cssForDevices = {
    allDevice: [],
    desktop: [],
    tablet: [],
    mobile: []
  };
  var attributesDef = (0,external_wp_blocks_namespaceObject.getBlockType)('blockart/' + ('button' === blockName ? 'button-inner' : 'buttons' === blockName ? 'button' : blockName)).attributes;
  var defaultSettings = Object.entries(attributesDef).reduce(function (acc, _ref2) {
    var _ref3 = slicedToArray_slicedToArray(_ref2, 2),
        key = _ref3[0],
        value = _ref3[1];

    if (value !== null && value !== void 0 && value["default"]) {
      acc[key] = value["default"];
    }

    return acc;
  }, {});
  Object.entries(settings).forEach(function (_ref4) {
    var _ref5 = slicedToArray_slicedToArray(_ref4, 2),
        settingName = _ref5[0],
        settingValue = _ref5[1];

    var attributeDef = attributesDef[settingName];
    var settingStyle = attributeDef === null || attributeDef === void 0 ? void 0 : attributeDef.style;

    if (!settingStyle) {
      return;
    }

    var settingStyleGenerator = getSettingStyleGenerator(settingName, settingValue);

    if (!settingStyleGenerator) {
      return;
    }

    var settingCSSForDevices = settingStyleGenerator({
      blockID: blockID,
      settingDef: attributeDef,
      settingName: settingName,
      settingValue: settingValue,
      settings: generate_block_css_objectSpread(generate_block_css_objectSpread({}, defaultSettings), settings),
      blockName: blockName,
      context: context
    });
    cssForDevices.allDevice = cssForDevices.allDevice.concat(settingCSSForDevices.allDevice);
    cssForDevices.desktop = cssForDevices.desktop.concat(settingCSSForDevices.desktop);
    cssForDevices.tablet = cssForDevices.tablet.concat(settingCSSForDevices.tablet);
    cssForDevices.mobile = cssForDevices.mobile.concat(settingCSSForDevices.mobile);
  });

  if (cssForDevices.allDevice.length > 0) {
    cssForDevices.allDevice.forEach(function (str, index) {
      if (str.includes('@import')) {
        cssForDevices.allDevice.splice(index, 1);

        if ('editor' === context) {
          cssForDevices.allDevice.unshift(str);
        }
      }
    });
  }

  if (context === 'editor') {
    var css = cssForDevices.allDevice.join('');
    css += cssForDevices.desktop.join('');

    if (!_BLOCKART_.isNotPostEditor) {
      if ('desktop' !== deviceType) {
        css += cssForDevices.tablet.join('');
      }

      if ('mobile' === deviceType) {
        css += cssForDevices.mobile.join('');
      }
    }

    return css;
  }

  return cssForDevices;
});
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }

  if (info.done) {
    resolve(value);
  } else {
    Promise.resolve(value).then(_next, _throw);
  }
}

function _asyncToGenerator(fn) {
  return function () {
    var self = this,
        args = arguments;
    return new Promise(function (resolve, reject) {
      var gen = fn.apply(self, args);

      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }

      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }

      _next(undefined);
    });
  };
}
;// CONCATENATED MODULE: external "regeneratorRuntime"
const external_regeneratorRuntime_namespaceObject = window["regeneratorRuntime"];
var external_regeneratorRuntime_default = /*#__PURE__*/__webpack_require__.n(external_regeneratorRuntime_namespaceObject);
;// CONCATENATED MODULE: external ["wp","apiFetch"]
const external_wp_apiFetch_namespaceObject = window["wp"]["apiFetch"];
var external_wp_apiFetch_default = /*#__PURE__*/__webpack_require__.n(external_wp_apiFetch_namespaceObject);
;// CONCATENATED MODULE: ./src/blocks/utils/has-blockart-blocks.js
function _createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = has_blockart_blocks_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function has_blockart_blocks_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return has_blockart_blocks_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return has_blockart_blocks_arrayLikeToArray(o, minLen); }

function has_blockart_blocks_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

/**
 * Check if a block is BlockArt block.
 *
 * @param {Array} blocks All used blocks.
 * @return {boolean} True|False.
 */
var hasBlockArtBlocks = function hasBlockArtBlocks(blocks) {
  var _iterator = _createForOfIteratorHelper(blocks),
      _step;

  try {
    for (_iterator.s(); !(_step = _iterator.n()).done;) {
      var _ref, _block$name;

      var block = _step.value;
      var name = (_ref = (_block$name = block === null || block === void 0 ? void 0 : block.name) !== null && _block$name !== void 0 ? _block$name : block === null || block === void 0 ? void 0 : block.blockName) !== null && _ref !== void 0 ? _ref : '';

      if (-1 !== name.indexOf('blockart/')) {
        return true;
      }

      if (block.innerBlocks && block.innerBlocks.length > 0) {
        if (hasBlockArtBlocks(block.innerBlocks)) {
          return true;
        }
      }
    }
  } catch (err) {
    _iterator.e(err);
  } finally {
    _iterator.f();
  }

  return false;
};

/* harmony default export */ const has_blockart_blocks = (hasBlockArtBlocks);
;// CONCATENATED MODULE: ./node_modules/css-tree/lib/tokenizer/types.js
// CSS Syntax Module Level 3
// https://www.w3.org/TR/css-syntax-3/
const EOF = 0;                 // <EOF-token>
const Ident = 1;               // <ident-token>
const types_Function = 2;            // <function-token>
const AtKeyword = 3;           // <at-keyword-token>
const Hash = 4;                // <hash-token>
const types_String = 5;              // <string-token>
const BadString = 6;           // <bad-string-token>
const Url = 7;                 // <url-token>
const BadUrl = 8;              // <bad-url-token>
const Delim = 9;               // <delim-token>
const types_Number = 10;             // <number-token>
const Percentage = 11;         // <percentage-token>
const Dimension = 12;          // <dimension-token>
const WhiteSpace = 13;         // <whitespace-token>
const CDO = 14;                // <CDO-token>
const CDC = 15;                // <CDC-token>
const Colon = 16;              // <colon-token>     :
const Semicolon = 17;          // <semicolon-token> ;
const Comma = 18;              // <comma-token>     ,
const LeftSquareBracket = 19;  // <[-token>
const RightSquareBracket = 20; // <]-token>
const LeftParenthesis = 21;    // <(-token>
const RightParenthesis = 22;   // <)-token>
const LeftCurlyBracket = 23;   // <{-token>
const RightCurlyBracket = 24;  // <}-token>
const Comment = 25;

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/tokenizer/char-code-definitions.js
const char_code_definitions_EOF = 0;

// https://drafts.csswg.org/css-syntax-3/
//  4.2. Definitions

// digit
// A code point between U+0030 DIGIT ZERO (0) and U+0039 DIGIT NINE (9).
function isDigit(code) {
    return code >= 0x0030 && code <= 0x0039;
}

// hex digit
// A digit, or a code point between U+0041 LATIN CAPITAL LETTER A (A) and U+0046 LATIN CAPITAL LETTER F (F),
// or a code point between U+0061 LATIN SMALL LETTER A (a) and U+0066 LATIN SMALL LETTER F (f).
function isHexDigit(code) {
    return (
        isDigit(code) || // 0 .. 9
        (code >= 0x0041 && code <= 0x0046) || // A .. F
        (code >= 0x0061 && code <= 0x0066)    // a .. f
    );
}

// uppercase letter
// A code point between U+0041 LATIN CAPITAL LETTER A (A) and U+005A LATIN CAPITAL LETTER Z (Z).
function isUppercaseLetter(code) {
    return code >= 0x0041 && code <= 0x005A;
}

// lowercase letter
// A code point between U+0061 LATIN SMALL LETTER A (a) and U+007A LATIN SMALL LETTER Z (z).
function isLowercaseLetter(code) {
    return code >= 0x0061 && code <= 0x007A;
}

// letter
// An uppercase letter or a lowercase letter.
function isLetter(code) {
    return isUppercaseLetter(code) || isLowercaseLetter(code);
}

// non-ASCII code point
// A code point with a value equal to or greater than U+0080 <control>.
function isNonAscii(code) {
    return code >= 0x0080;
}

// name-start code point
// A letter, a non-ASCII code point, or U+005F LOW LINE (_).
function isNameStart(code) {
    return isLetter(code) || isNonAscii(code) || code === 0x005F;
}

// name code point
// A name-start code point, a digit, or U+002D HYPHEN-MINUS (-).
function char_code_definitions_isName(code) {
    return isNameStart(code) || isDigit(code) || code === 0x002D;
}

// non-printable code point
// A code point between U+0000 NULL and U+0008 BACKSPACE, or U+000B LINE TABULATION,
// or a code point between U+000E SHIFT OUT and U+001F INFORMATION SEPARATOR ONE, or U+007F DELETE.
function isNonPrintable(code) {
    return (
        (code >= 0x0000 && code <= 0x0008) ||
        (code === 0x000B) ||
        (code >= 0x000E && code <= 0x001F) ||
        (code === 0x007F)
    );
}

// newline
// U+000A LINE FEED. Note that U+000D CARRIAGE RETURN and U+000C FORM FEED are not included in this definition,
// as they are converted to U+000A LINE FEED during preprocessing.
// TODO: we doesn't do a preprocessing, so check a code point for U+000D CARRIAGE RETURN and U+000C FORM FEED
function isNewline(code) {
    return code === 0x000A || code === 0x000D || code === 0x000C;
}

// whitespace
// A newline, U+0009 CHARACTER TABULATION, or U+0020 SPACE.
function isWhiteSpace(code) {
    return isNewline(code) || code === 0x0020 || code === 0x0009;
}

//  4.3.8. Check if two code points are a valid escape
function char_code_definitions_isValidEscape(first, second) {
    // If the first code point is not U+005C REVERSE SOLIDUS (\), return false.
    if (first !== 0x005C) {
        return false;
    }

    // Otherwise, if the second code point is a newline or EOF, return false.
    if (isNewline(second) || second === char_code_definitions_EOF) {
        return false;
    }

    // Otherwise, return true.
    return true;
}

//  4.3.9. Check if three code points would start an identifier
function isIdentifierStart(first, second, third) {
    // Look at the first code point:

    // U+002D HYPHEN-MINUS
    if (first === 0x002D) {
        // If the second code point is a name-start code point or a U+002D HYPHEN-MINUS,
        // or the second and third code points are a valid escape, return true. Otherwise, return false.
        return (
            isNameStart(second) ||
            second === 0x002D ||
            char_code_definitions_isValidEscape(second, third)
        );
    }

    // name-start code point
    if (isNameStart(first)) {
        // Return true.
        return true;
    }

    // U+005C REVERSE SOLIDUS (\)
    if (first === 0x005C) {
        // If the first and second code points are a valid escape, return true. Otherwise, return false.
        return char_code_definitions_isValidEscape(first, second);
    }

    // anything else
    // Return false.
    return false;
}

//  4.3.10. Check if three code points would start a number
function isNumberStart(first, second, third) {
    // Look at the first code point:

    // U+002B PLUS SIGN (+)
    // U+002D HYPHEN-MINUS (-)
    if (first === 0x002B || first === 0x002D) {
        // If the second code point is a digit, return true.
        if (isDigit(second)) {
            return 2;
        }

        // Otherwise, if the second code point is a U+002E FULL STOP (.)
        // and the third code point is a digit, return true.
        // Otherwise, return false.
        return second === 0x002E && isDigit(third) ? 3 : 0;
    }

    // U+002E FULL STOP (.)
    if (first === 0x002E) {
        // If the second code point is a digit, return true. Otherwise, return false.
        return isDigit(second) ? 2 : 0;
    }

    // digit
    if (isDigit(first)) {
        // Return true.
        return 1;
    }

    // anything else
    // Return false.
    return 0;
}

//
// Misc
//

// detect BOM (https://en.wikipedia.org/wiki/Byte_order_mark)
function isBOM(code) {
    // UTF-16BE
    if (code === 0xFEFF) {
        return 1;
    }

    // UTF-16LE
    if (code === 0xFFFE) {
        return 1;
    }

    return 0;
}

// Fast code category
// Only ASCII code points has a special meaning, that's why we define a maps for 0..127 codes only
const CATEGORY = new Array(0x80);
const EofCategory = 0x80;
const WhiteSpaceCategory = 0x82;
const DigitCategory = 0x83;
const NameStartCategory = 0x84;
const NonPrintableCategory = 0x85;

for (let i = 0; i < CATEGORY.length; i++) {
    CATEGORY[i] =
        isWhiteSpace(i) && WhiteSpaceCategory ||
        isDigit(i) && DigitCategory ||
        isNameStart(i) && NameStartCategory ||
        isNonPrintable(i) && NonPrintableCategory ||
        i || EofCategory;
}

function charCodeCategory(code) {
    return code < 0x80 ? CATEGORY[code] : NameStartCategory;
}

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/tokenizer/utils.js


function getCharCode(source, offset) {
    return offset < source.length ? source.charCodeAt(offset) : 0;
}

function getNewlineLength(source, offset, code) {
    if (code === 13 /* \r */ && getCharCode(source, offset + 1) === 10 /* \n */) {
        return 2;
    }

    return 1;
}

function cmpChar(testStr, offset, referenceCode) {
    let code = testStr.charCodeAt(offset);

    // code.toLowerCase() for A..Z
    if (isUppercaseLetter(code)) {
        code = code | 32;
    }

    return code === referenceCode;
}

function cmpStr(testStr, start, end, referenceStr) {
    if (end - start !== referenceStr.length) {
        return false;
    }

    if (start < 0 || end > testStr.length) {
        return false;
    }

    for (let i = start; i < end; i++) {
        const referenceCode = referenceStr.charCodeAt(i - start);
        let testCode = testStr.charCodeAt(i);

        // testCode.toLowerCase() for A..Z
        if (isUppercaseLetter(testCode)) {
            testCode = testCode | 32;
        }

        if (testCode !== referenceCode) {
            return false;
        }
    }

    return true;
}

function findWhiteSpaceStart(source, offset) {
    for (; offset >= 0; offset--) {
        if (!isWhiteSpace(source.charCodeAt(offset))) {
            break;
        }
    }

    return offset + 1;
}

function findWhiteSpaceEnd(source, offset) {
    for (; offset < source.length; offset++) {
        if (!isWhiteSpace(source.charCodeAt(offset))) {
            break;
        }
    }

    return offset;
}

function findDecimalNumberEnd(source, offset) {
    for (; offset < source.length; offset++) {
        if (!isDigit(source.charCodeAt(offset))) {
            break;
        }
    }

    return offset;
}

//  4.3.7. Consume an escaped code point
function utils_consumeEscaped(source, offset) {
    // It assumes that the U+005C REVERSE SOLIDUS (\) has already been consumed and
    // that the next input code point has already been verified to be part of a valid escape.
    offset += 2;

    // hex digit
    if (isHexDigit(getCharCode(source, offset - 1))) {
        // Consume as many hex digits as possible, but no more than 5.
        // Note that this means 1-6 hex digits have been consumed in total.
        for (const maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
            if (!isHexDigit(getCharCode(source, offset))) {
                break;
            }
        }

        // If the next input code point is whitespace, consume it as well.
        const code = getCharCode(source, offset);
        if (isWhiteSpace(code)) {
            offset += getNewlineLength(source, offset, code);
        }
    }

    return offset;
}

// 4.3.11. Consume a name
// Note: This algorithm does not do the verification of the first few code points that are necessary
// to ensure the returned code points would constitute an <ident-token>. If that is the intended use,
// ensure that the stream starts with an identifier before calling this algorithm.
function consumeName(source, offset) {
    // Let result initially be an empty string.
    // Repeatedly consume the next input code point from the stream:
    for (; offset < source.length; offset++) {
        const code = source.charCodeAt(offset);

        // name code point
        if (char_code_definitions_isName(code)) {
            // Append the code point to result.
            continue;
        }

        // the stream starts with a valid escape
        if (char_code_definitions_isValidEscape(code, getCharCode(source, offset + 1))) {
            // Consume an escaped code point. Append the returned code point to result.
            offset = utils_consumeEscaped(source, offset) - 1;
            continue;
        }

        // anything else
        // Reconsume the current input code point. Return result.
        break;
    }

    return offset;
}

// 4.3.12. Consume a number
function consumeNumber(source, offset) {
    let code = source.charCodeAt(offset);

    // 2. If the next input code point is U+002B PLUS SIGN (+) or U+002D HYPHEN-MINUS (-),
    // consume it and append it to repr.
    if (code === 0x002B || code === 0x002D) {
        code = source.charCodeAt(offset += 1);
    }

    // 3. While the next input code point is a digit, consume it and append it to repr.
    if (isDigit(code)) {
        offset = findDecimalNumberEnd(source, offset + 1);
        code = source.charCodeAt(offset);
    }

    // 4. If the next 2 input code points are U+002E FULL STOP (.) followed by a digit, then:
    if (code === 0x002E && isDigit(source.charCodeAt(offset + 1))) {
        // 4.1 Consume them.
        // 4.2 Append them to repr.
        offset += 2;

        // 4.3 Set type to "number".
        // TODO

        // 4.4 While the next input code point is a digit, consume it and append it to repr.

        offset = findDecimalNumberEnd(source, offset);
    }

    // 5. If the next 2 or 3 input code points are U+0045 LATIN CAPITAL LETTER E (E)
    // or U+0065 LATIN SMALL LETTER E (e), ... , followed by a digit, then:
    if (cmpChar(source, offset, 101 /* e */)) {
        let sign = 0;
        code = source.charCodeAt(offset + 1);

        // ... optionally followed by U+002D HYPHEN-MINUS (-) or U+002B PLUS SIGN (+) ...
        if (code === 0x002D || code === 0x002B) {
            sign = 1;
            code = source.charCodeAt(offset + 2);
        }

        // ... followed by a digit
        if (isDigit(code)) {
            // 5.1 Consume them.
            // 5.2 Append them to repr.

            // 5.3 Set type to "number".
            // TODO

            // 5.4 While the next input code point is a digit, consume it and append it to repr.
            offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
        }
    }

    return offset;
}

//  4.3.14. Consume the remnants of a bad url
// ... its sole use is to consume enough of the input stream to reach a recovery point
// where normal tokenizing can resume.
function consumeBadUrlRemnants(source, offset) {
    // Repeatedly consume the next input code point from the stream:
    for (; offset < source.length; offset++) {
        const code = source.charCodeAt(offset);

        // U+0029 RIGHT PARENTHESIS ())
        // EOF
        if (code === 0x0029) {
            // Return.
            offset++;
            break;
        }

        if (char_code_definitions_isValidEscape(code, getCharCode(source, offset + 1))) {
            // Consume an escaped code point.
            // Note: This allows an escaped right parenthesis ("\)") to be encountered
            // without ending the <bad-url-token>. This is otherwise identical to
            // the "anything else" clause.
            offset = utils_consumeEscaped(source, offset);
        }
    }

    return offset;
}

//  4.3.7. Consume an escaped code point
// Note: This algorithm assumes that escaped is valid without leading U+005C REVERSE SOLIDUS (\)
function utils_decodeEscaped(escaped) {
    // Single char escaped that's not a hex digit
    if (escaped.length === 1 && !isHexDigit(escaped.charCodeAt(0))) {
        return escaped[0];
    }

    // Interpret the hex digits as a hexadecimal number.
    let code = parseInt(escaped, 16);

    if (
        (code === 0) ||                       // If this number is zero,
        (code >= 0xD800 && code <= 0xDFFF) || // or is for a surrogate,
        (code > 0x10FFFF)                     // or is greater than the maximum allowed code point
    ) {
        // ... return U+FFFD REPLACEMENT CHARACTER
        code = 0xFFFD;
    }

    // Otherwise, return the code point with that value.
    return String.fromCodePoint(code);
}

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/tokenizer/names.js
/* harmony default export */ const names = ([
    'EOF-token',
    'ident-token',
    'function-token',
    'at-keyword-token',
    'hash-token',
    'string-token',
    'bad-string-token',
    'url-token',
    'bad-url-token',
    'delim-token',
    'number-token',
    'percentage-token',
    'dimension-token',
    'whitespace-token',
    'CDO-token',
    'CDC-token',
    'colon-token',
    'semicolon-token',
    'comma-token',
    '[-token',
    ']-token',
    '(-token',
    ')-token',
    '{-token',
    '}-token'
]);

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/tokenizer/adopt-buffer.js
const MIN_SIZE = 16 * 1024;

function adoptBuffer(buffer = null, size) {
    if (buffer === null || buffer.length < size) {
        return new Uint32Array(Math.max(size + 1024, MIN_SIZE));
    }

    return buffer;
};

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/tokenizer/OffsetToLocation.js



const N = 10;
const F = 12;
const R = 13;

function computeLinesAndColumns(host) {
    const source = host.source;
    const sourceLength = source.length;
    const startOffset = source.length > 0 ? isBOM(source.charCodeAt(0)) : 0;
    const lines = adoptBuffer(host.lines, sourceLength);
    const columns = adoptBuffer(host.columns, sourceLength);
    let line = host.startLine;
    let column = host.startColumn;

    for (let i = startOffset; i < sourceLength; i++) {
        const code = source.charCodeAt(i);

        lines[i] = line;
        columns[i] = column++;

        if (code === N || code === R || code === F) {
            if (code === R && i + 1 < sourceLength && source.charCodeAt(i + 1) === N) {
                i++;
                lines[i] = line;
                columns[i] = column;
            }

            line++;
            column = 1;
        }
    }

    lines[sourceLength] = line;
    columns[sourceLength] = column;

    host.lines = lines;
    host.columns = columns;
    host.computed = true;
}

class OffsetToLocation {
    constructor() {
        this.lines = null;
        this.columns = null;
        this.computed = false;
    }
    setSource(source, startOffset = 0, startLine = 1, startColumn = 1) {
        this.source = source;
        this.startOffset = startOffset;
        this.startLine = startLine;
        this.startColumn = startColumn;
        this.computed = false;
    }
    getLocation(offset, filename) {
        if (!this.computed) {
            computeLinesAndColumns(this);
        }

        return {
            source: filename,
            offset: this.startOffset + offset,
            line: this.lines[offset],
            column: this.columns[offset]
        };
    }
    getLocationRange(start, end, filename) {
        if (!this.computed) {
            computeLinesAndColumns(this);
        }

        return {
            source: filename,
            start: {
                offset: this.startOffset + start,
                line: this.lines[start],
                column: this.columns[start]
            },
            end: {
                offset: this.startOffset + end,
                line: this.lines[end],
                column: this.columns[end]
            }
        };
    }
};

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/tokenizer/TokenStream.js





const OFFSET_MASK = 0x00FFFFFF;
const TYPE_SHIFT = 24;
const balancePair = new Map([
    [types_Function, RightParenthesis],
    [LeftParenthesis, RightParenthesis],
    [LeftSquareBracket, RightSquareBracket],
    [LeftCurlyBracket, RightCurlyBracket]
]);

class TokenStream {
    constructor(source, tokenize) {
        this.setSource(source, tokenize);
    }
    reset() {
        this.eof = false;
        this.tokenIndex = -1;
        this.tokenType = 0;
        this.tokenStart = this.firstCharOffset;
        this.tokenEnd = this.firstCharOffset;
    }
    setSource(source = '', tokenize = () => {}) {
        source = String(source || '');

        const sourceLength = source.length;
        const offsetAndType = adoptBuffer(this.offsetAndType, source.length + 1); // +1 because of eof-token
        const balance = adoptBuffer(this.balance, source.length + 1);
        let tokenCount = 0;
        let balanceCloseType = 0;
        let balanceStart = 0;
        let firstCharOffset = -1;

        // capture buffers
        this.offsetAndType = null;
        this.balance = null;

        tokenize(source, (type, start, end) => {
            switch (type) {
                default:
                    balance[tokenCount] = sourceLength;
                    break;

                case balanceCloseType: {
                    let balancePrev = balanceStart & OFFSET_MASK;
                    balanceStart = balance[balancePrev];
                    balanceCloseType = balanceStart >> TYPE_SHIFT;
                    balance[tokenCount] = balancePrev;
                    balance[balancePrev++] = tokenCount;
                    for (; balancePrev < tokenCount; balancePrev++) {
                        if (balance[balancePrev] === sourceLength) {
                            balance[balancePrev] = tokenCount;
                        }
                    }
                    break;
                }

                case LeftParenthesis:
                case types_Function:
                case LeftSquareBracket:
                case LeftCurlyBracket:
                    balance[tokenCount] = balanceStart;
                    balanceCloseType = balancePair.get(type);
                    balanceStart = (balanceCloseType << TYPE_SHIFT) | tokenCount;
                    break;
            }

            offsetAndType[tokenCount++] = (type << TYPE_SHIFT) | end;
            if (firstCharOffset === -1) {
                firstCharOffset = start;
            }
        });

        // finalize buffers
        offsetAndType[tokenCount] = (EOF << TYPE_SHIFT) | sourceLength; // <EOF-token>
        balance[tokenCount] = sourceLength;
        balance[sourceLength] = sourceLength; // prevents false positive balance match with any token
        while (balanceStart !== 0) {
            const balancePrev = balanceStart & OFFSET_MASK;
            balanceStart = balance[balancePrev];
            balance[balancePrev] = sourceLength;
        }

        this.source = source;
        this.firstCharOffset = firstCharOffset === -1 ? 0 : firstCharOffset;
        this.tokenCount = tokenCount;
        this.offsetAndType = offsetAndType;
        this.balance = balance;

        this.reset();
        this.next();
    }

    lookupType(offset) {
        offset += this.tokenIndex;

        if (offset < this.tokenCount) {
            return this.offsetAndType[offset] >> TYPE_SHIFT;
        }

        return EOF;
    }
    lookupOffset(offset) {
        offset += this.tokenIndex;

        if (offset < this.tokenCount) {
            return this.offsetAndType[offset - 1] & OFFSET_MASK;
        }

        return this.source.length;
    }
    lookupValue(offset, referenceStr) {
        offset += this.tokenIndex;

        if (offset < this.tokenCount) {
            return cmpStr(
                this.source,
                this.offsetAndType[offset - 1] & OFFSET_MASK,
                this.offsetAndType[offset] & OFFSET_MASK,
                referenceStr
            );
        }

        return false;
    }
    getTokenStart(tokenIndex) {
        if (tokenIndex === this.tokenIndex) {
            return this.tokenStart;
        }

        if (tokenIndex > 0) {
            return tokenIndex < this.tokenCount
                ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK
                : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
        }

        return this.firstCharOffset;
    }
    substrToCursor(start) {
        return this.source.substring(start, this.tokenStart);
    }

    isBalanceEdge(pos) {
        return this.balance[this.tokenIndex] < pos;
    }
    isDelim(code, offset) {
        if (offset) {
            return (
                this.lookupType(offset) === Delim &&
                this.source.charCodeAt(this.lookupOffset(offset)) === code
            );
        }

        return (
            this.tokenType === Delim &&
            this.source.charCodeAt(this.tokenStart) === code
        );
    }

    skip(tokenCount) {
        let next = this.tokenIndex + tokenCount;

        if (next < this.tokenCount) {
            this.tokenIndex = next;
            this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
            next = this.offsetAndType[next];
            this.tokenType = next >> TYPE_SHIFT;
            this.tokenEnd = next & OFFSET_MASK;
        } else {
            this.tokenIndex = this.tokenCount;
            this.next();
        }
    }
    next() {
        let next = this.tokenIndex + 1;

        if (next < this.tokenCount) {
            this.tokenIndex = next;
            this.tokenStart = this.tokenEnd;
            next = this.offsetAndType[next];
            this.tokenType = next >> TYPE_SHIFT;
            this.tokenEnd = next & OFFSET_MASK;
        } else {
            this.eof = true;
            this.tokenIndex = this.tokenCount;
            this.tokenType = EOF;
            this.tokenStart = this.tokenEnd = this.source.length;
        }
    }
    skipSC() {
        while (this.tokenType === WhiteSpace || this.tokenType === Comment) {
            this.next();
        }
    }
    skipUntilBalanced(startToken, stopConsume) {
        let cursor = startToken;
        let balanceEnd;
        let offset;

        loop:
        for (; cursor < this.tokenCount; cursor++) {
            balanceEnd = this.balance[cursor];

            // stop scanning on balance edge that points to offset before start token
            if (balanceEnd < startToken) {
                break loop;
            }

            offset = cursor > 0 ? this.offsetAndType[cursor - 1] & OFFSET_MASK : this.firstCharOffset;

            // check stop condition
            switch (stopConsume(this.source.charCodeAt(offset))) {
                case 1: // just stop
                    break loop;

                case 2: // stop & included
                    cursor++;
                    break loop;

                default:
                    // fast forward to the end of balanced block
                    if (this.balance[balanceEnd] === cursor) {
                        cursor = balanceEnd;
                    }
            }
        }

        this.skip(cursor - this.tokenIndex);
    }

    forEachToken(fn) {
        for (let i = 0, offset = this.firstCharOffset; i < this.tokenCount; i++) {
            const start = offset;
            const item = this.offsetAndType[i];
            const end = item & OFFSET_MASK;
            const type = item >> TYPE_SHIFT;

            offset = end;

            fn(type, start, end, i);
        }
    }
    dump() {
        const tokens = new Array(this.tokenCount);

        this.forEachToken((type, start, end, index) => {
            tokens[index] = {
                idx: index,
                type: names[type],
                chunk: this.source.substring(start, end),
                balance: this.balance[index]
            };
        });

        return tokens;
    }
};

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/tokenizer/index.js




function tokenize(source, onToken) {
    function getCharCode(offset) {
        return offset < sourceLength ? source.charCodeAt(offset) : 0;
    }

    //  4.3.3. Consume a numeric token
    function consumeNumericToken() {
        // Consume a number and let number be the result.
        offset = consumeNumber(source, offset);

        // If the next 3 input code points would start an identifier, then:
        if (isIdentifierStart(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
            // Create a <dimension-token> with the same value and type flag as number, and a unit set initially to the empty string.
            // Consume a name. Set the <dimension-token>s unit to the returned value.
            // Return the <dimension-token>.
            type = Dimension;
            offset = consumeName(source, offset);
            return;
        }

        // Otherwise, if the next input code point is U+0025 PERCENTAGE SIGN (%), consume it.
        if (getCharCode(offset) === 0x0025) {
            // Create a <percentage-token> with the same value as number, and return it.
            type = Percentage;
            offset++;
            return;
        }

        // Otherwise, create a <number-token> with the same value and type flag as number, and return it.
        type = types_Number;
    }

    //  4.3.4. Consume an ident-like token
    function consumeIdentLikeToken() {
        const nameStartOffset = offset;

        // Consume a name, and let string be the result.
        offset = consumeName(source, offset);

        // If strings value is an ASCII case-insensitive match for "url",
        // and the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
        if (cmpStr(source, nameStartOffset, offset, 'url') && getCharCode(offset) === 0x0028) {
            // While the next two input code points are whitespace, consume the next input code point.
            offset = findWhiteSpaceEnd(source, offset + 1);

            // If the next one or two input code points are U+0022 QUOTATION MARK ("), U+0027 APOSTROPHE ('),
            // or whitespace followed by U+0022 QUOTATION MARK (") or U+0027 APOSTROPHE ('),
            // then create a <function-token> with its value set to string and return it.
            if (getCharCode(offset) === 0x0022 ||
                getCharCode(offset) === 0x0027) {
                type = types_Function;
                offset = nameStartOffset + 4;
                return;
            }

            // Otherwise, consume a url token, and return it.
            consumeUrlToken();
            return;
        }

        // Otherwise, if the next input code point is U+0028 LEFT PARENTHESIS ((), consume it.
        // Create a <function-token> with its value set to string and return it.
        if (getCharCode(offset) === 0x0028) {
            type = types_Function;
            offset++;
            return;
        }

        // Otherwise, create an <ident-token> with its value set to string and return it.
        type = Ident;
    }

    //  4.3.5. Consume a string token
    function consumeStringToken(endingCodePoint) {
        // This algorithm may be called with an ending code point, which denotes the code point
        // that ends the string. If an ending code point is not specified,
        // the current input code point is used.
        if (!endingCodePoint) {
            endingCodePoint = getCharCode(offset++);
        }

        // Initially create a <string-token> with its value set to the empty string.
        type = types_String;

        // Repeatedly consume the next input code point from the stream:
        for (; offset < source.length; offset++) {
            const code = source.charCodeAt(offset);

            switch (charCodeCategory(code)) {
                // ending code point
                case endingCodePoint:
                    // Return the <string-token>.
                    offset++;
                    return;

                    // EOF
                    // case EofCategory:
                    // This is a parse error. Return the <string-token>.
                    // return;

                // newline
                case WhiteSpaceCategory:
                    if (isNewline(code)) {
                        // This is a parse error. Reconsume the current input code point,
                        // create a <bad-string-token>, and return it.
                        offset += getNewlineLength(source, offset, code);
                        type = BadString;
                        return;
                    }
                    break;

                // U+005C REVERSE SOLIDUS (\)
                case 0x005C:
                    // If the next input code point is EOF, do nothing.
                    if (offset === source.length - 1) {
                        break;
                    }

                    const nextCode = getCharCode(offset + 1);

                    // Otherwise, if the next input code point is a newline, consume it.
                    if (isNewline(nextCode)) {
                        offset += getNewlineLength(source, offset + 1, nextCode);
                    } else if (char_code_definitions_isValidEscape(code, nextCode)) {
                        // Otherwise, (the stream starts with a valid escape) consume
                        // an escaped code point and append the returned code point to
                        // the <string-token>s value.
                        offset = utils_consumeEscaped(source, offset) - 1;
                    }
                    break;

                // anything else
                // Append the current input code point to the <string-token>s value.
            }
        }
    }

    //  4.3.6. Consume a url token
    // Note: This algorithm assumes that the initial "url(" has already been consumed.
    // This algorithm also assumes that its being called to consume an "unquoted" value, like url(foo).
    // A quoted value, like url("foo"), is parsed as a <function-token>. Consume an ident-like token
    // automatically handles this distinction; this algorithm shouldnt be called directly otherwise.
    function consumeUrlToken() {
        // Initially create a <url-token> with its value set to the empty string.
        type = Url;

        // Consume as much whitespace as possible.
        offset = findWhiteSpaceEnd(source, offset);

        // Repeatedly consume the next input code point from the stream:
        for (; offset < source.length; offset++) {
            const code = source.charCodeAt(offset);

            switch (charCodeCategory(code)) {
                // U+0029 RIGHT PARENTHESIS ())
                case 0x0029:
                    // Return the <url-token>.
                    offset++;
                    return;

                    // EOF
                    // case EofCategory:
                    // This is a parse error. Return the <url-token>.
                    // return;

                // whitespace
                case WhiteSpaceCategory:
                    // Consume as much whitespace as possible.
                    offset = findWhiteSpaceEnd(source, offset);

                    // If the next input code point is U+0029 RIGHT PARENTHESIS ()) or EOF,
                    // consume it and return the <url-token>
                    // (if EOF was encountered, this is a parse error);
                    if (getCharCode(offset) === 0x0029 || offset >= source.length) {
                        if (offset < source.length) {
                            offset++;
                        }
                        return;
                    }

                    // otherwise, consume the remnants of a bad url, create a <bad-url-token>,
                    // and return it.
                    offset = consumeBadUrlRemnants(source, offset);
                    type = BadUrl;
                    return;

                // U+0022 QUOTATION MARK (")
                // U+0027 APOSTROPHE (')
                // U+0028 LEFT PARENTHESIS (()
                // non-printable code point
                case 0x0022:
                case 0x0027:
                case 0x0028:
                case NonPrintableCategory:
                    // This is a parse error. Consume the remnants of a bad url,
                    // create a <bad-url-token>, and return it.
                    offset = consumeBadUrlRemnants(source, offset);
                    type = BadUrl;
                    return;

                // U+005C REVERSE SOLIDUS (\)
                case 0x005C:
                    // If the stream starts with a valid escape, consume an escaped code point and
                    // append the returned code point to the <url-token>s value.
                    if (char_code_definitions_isValidEscape(code, getCharCode(offset + 1))) {
                        offset = utils_consumeEscaped(source, offset) - 1;
                        break;
                    }

                    // Otherwise, this is a parse error. Consume the remnants of a bad url,
                    // create a <bad-url-token>, and return it.
                    offset = consumeBadUrlRemnants(source, offset);
                    type = BadUrl;
                    return;

                // anything else
                // Append the current input code point to the <url-token>s value.
            }
        }
    }

    // ensure source is a string
    source = String(source || '');

    const sourceLength = source.length;
    let start = isBOM(getCharCode(0));
    let offset = start;
    let type;

    // https://drafts.csswg.org/css-syntax-3/#consume-token
    //  4.3.1. Consume a token
    while (offset < sourceLength) {
        const code = source.charCodeAt(offset);

        switch (charCodeCategory(code)) {
            // whitespace
            case WhiteSpaceCategory:
                // Consume as much whitespace as possible. Return a <whitespace-token>.
                type = WhiteSpace;
                offset = findWhiteSpaceEnd(source, offset + 1);
                break;

            // U+0022 QUOTATION MARK (")
            case 0x0022:
                // Consume a string token and return it.
                consumeStringToken();
                break;

            // U+0023 NUMBER SIGN (#)
            case 0x0023:
                // If the next input code point is a name code point or the next two input code points are a valid escape, then:
                if (char_code_definitions_isName(getCharCode(offset + 1)) || char_code_definitions_isValidEscape(getCharCode(offset + 1), getCharCode(offset + 2))) {
                    // Create a <hash-token>.
                    type = Hash;

                    // If the next 3 input code points would start an identifier, set the <hash-token>s type flag to "id".
                    // if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
                    //     // TODO: set id flag
                    // }

                    // Consume a name, and set the <hash-token>s value to the returned string.
                    offset = consumeName(source, offset + 1);

                    // Return the <hash-token>.
                } else {
                    // Otherwise, return a <delim-token> with its value set to the current input code point.
                    type = Delim;
                    offset++;
                }

                break;

            // U+0027 APOSTROPHE (')
            case 0x0027:
                // Consume a string token and return it.
                consumeStringToken();
                break;

            // U+0028 LEFT PARENTHESIS (()
            case 0x0028:
                // Return a <(-token>.
                type = LeftParenthesis;
                offset++;
                break;

            // U+0029 RIGHT PARENTHESIS ())
            case 0x0029:
                // Return a <)-token>.
                type = RightParenthesis;
                offset++;
                break;

            // U+002B PLUS SIGN (+)
            case 0x002B:
                // If the input stream starts with a number, ...
                if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
                    // ... reconsume the current input code point, consume a numeric token, and return it.
                    consumeNumericToken();
                } else {
                    // Otherwise, return a <delim-token> with its value set to the current input code point.
                    type = Delim;
                    offset++;
                }
                break;

            // U+002C COMMA (,)
            case 0x002C:
                // Return a <comma-token>.
                type = Comma;
                offset++;
                break;

            // U+002D HYPHEN-MINUS (-)
            case 0x002D:
                // If the input stream starts with a number, reconsume the current input code point, consume a numeric token, and return it.
                if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
                    consumeNumericToken();
                } else {
                    // Otherwise, if the next 2 input code points are U+002D HYPHEN-MINUS U+003E GREATER-THAN SIGN (->), consume them and return a <CDC-token>.
                    if (getCharCode(offset + 1) === 0x002D &&
                        getCharCode(offset + 2) === 0x003E) {
                        type = CDC;
                        offset = offset + 3;
                    } else {
                        // Otherwise, if the input stream starts with an identifier, ...
                        if (isIdentifierStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
                            // ... reconsume the current input code point, consume an ident-like token, and return it.
                            consumeIdentLikeToken();
                        } else {
                            // Otherwise, return a <delim-token> with its value set to the current input code point.
                            type = Delim;
                            offset++;
                        }
                    }
                }
                break;

            // U+002E FULL STOP (.)
            case 0x002E:
                // If the input stream starts with a number, ...
                if (isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
                    // ... reconsume the current input code point, consume a numeric token, and return it.
                    consumeNumericToken();
                } else {
                    // Otherwise, return a <delim-token> with its value set to the current input code point.
                    type = Delim;
                    offset++;
                }

                break;

            // U+002F SOLIDUS (/)
            case 0x002F:
                // If the next two input code point are U+002F SOLIDUS (/) followed by a U+002A ASTERISK (*),
                if (getCharCode(offset + 1) === 0x002A) {
                    // ... consume them and all following code points up to and including the first U+002A ASTERISK (*)
                    // followed by a U+002F SOLIDUS (/), or up to an EOF code point.
                    type = Comment;
                    offset = source.indexOf('*/', offset + 2);
                    offset = offset === -1 ? source.length : offset + 2;
                } else {
                    type = Delim;
                    offset++;
                }
                break;

            // U+003A COLON (:)
            case 0x003A:
                // Return a <colon-token>.
                type = Colon;
                offset++;
                break;

            // U+003B SEMICOLON (;)
            case 0x003B:
                // Return a <semicolon-token>.
                type = Semicolon;
                offset++;
                break;

            // U+003C LESS-THAN SIGN (<)
            case 0x003C:
                // If the next 3 input code points are U+0021 EXCLAMATION MARK U+002D HYPHEN-MINUS U+002D HYPHEN-MINUS (!--), ...
                if (getCharCode(offset + 1) === 0x0021 &&
                    getCharCode(offset + 2) === 0x002D &&
                    getCharCode(offset + 3) === 0x002D) {
                    // ... consume them and return a <CDO-token>.
                    type = CDO;
                    offset = offset + 4;
                } else {
                    // Otherwise, return a <delim-token> with its value set to the current input code point.
                    type = Delim;
                    offset++;
                }

                break;

            // U+0040 COMMERCIAL AT (@)
            case 0x0040:
                // If the next 3 input code points would start an identifier, ...
                if (isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
                    // ... consume a name, create an <at-keyword-token> with its value set to the returned value, and return it.
                    type = AtKeyword;
                    offset = consumeName(source, offset + 1);
                } else {
                    // Otherwise, return a <delim-token> with its value set to the current input code point.
                    type = Delim;
                    offset++;
                }

                break;

            // U+005B LEFT SQUARE BRACKET ([)
            case 0x005B:
                // Return a <[-token>.
                type = LeftSquareBracket;
                offset++;
                break;

            // U+005C REVERSE SOLIDUS (\)
            case 0x005C:
                // If the input stream starts with a valid escape, ...
                if (char_code_definitions_isValidEscape(code, getCharCode(offset + 1))) {
                    // ... reconsume the current input code point, consume an ident-like token, and return it.
                    consumeIdentLikeToken();
                } else {
                    // Otherwise, this is a parse error. Return a <delim-token> with its value set to the current input code point.
                    type = Delim;
                    offset++;
                }
                break;

            // U+005D RIGHT SQUARE BRACKET (])
            case 0x005D:
                // Return a <]-token>.
                type = RightSquareBracket;
                offset++;
                break;

            // U+007B LEFT CURLY BRACKET ({)
            case 0x007B:
                // Return a <{-token>.
                type = LeftCurlyBracket;
                offset++;
                break;

            // U+007D RIGHT CURLY BRACKET (})
            case 0x007D:
                // Return a <}-token>.
                type = RightCurlyBracket;
                offset++;
                break;

            // digit
            case DigitCategory:
                // Reconsume the current input code point, consume a numeric token, and return it.
                consumeNumericToken();
                break;

            // name-start code point
            case NameStartCategory:
                // Reconsume the current input code point, consume an ident-like token, and return it.
                consumeIdentLikeToken();
                break;

                // EOF
                // case EofCategory:
                // Return an <EOF-token>.
                // break;

            // anything else
            default:
                // Return a <delim-token> with its value set to the current input code point.
                type = Delim;
                offset++;
        }

        // put token to stream
        onToken(type, start, start = offset);
    }
}









;// CONCATENATED MODULE: ./node_modules/css-tree/lib/utils/List.js
//
//                              list
//                            
//             head 
//                            tail
//                                         
//                                                 
//            item        item        item        item
//                      
//  null prev prev prev prev 
//           next next next next null
//                      
//           data      data      data      data 
//                      
//

let releasedCursors = null;

class List {
    static createItem(data) {
        return {
            prev: null,
            next: null,
            data
        };
    }

    constructor() {
        this.head = null;
        this.tail = null;
        this.cursor = null;
    }
    createItem(data) {
        return List.createItem(data);
    }

    // cursor helpers
    allocateCursor(prev, next) {
        let cursor;

        if (releasedCursors !== null) {
            cursor = releasedCursors;
            releasedCursors = releasedCursors.cursor;
            cursor.prev = prev;
            cursor.next = next;
            cursor.cursor = this.cursor;
        } else {
            cursor = {
                prev,
                next,
                cursor: this.cursor
            };
        }

        this.cursor = cursor;

        return cursor;
    }
    releaseCursor() {
        const { cursor } = this;

        this.cursor = cursor.cursor;
        cursor.prev = null;
        cursor.next = null;
        cursor.cursor = releasedCursors;
        releasedCursors = cursor;
    }
    updateCursors(prevOld, prevNew, nextOld, nextNew) {
        let { cursor } = this;

        while (cursor !== null) {
            if (cursor.prev === prevOld) {
                cursor.prev = prevNew;
            }

            if (cursor.next === nextOld) {
                cursor.next = nextNew;
            }

            cursor = cursor.cursor;
        }
    }
    *[Symbol.iterator]() {
        for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
            yield cursor.data;
        }
    }

    // getters
    get size() {
        let size = 0;

        for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
            size++;
        }

        return size;
    }
    get isEmpty() {
        return this.head === null;
    }
    get first() {
        return this.head && this.head.data;
    }
    get last() {
        return this.tail && this.tail.data;
    }

    // convertors
    fromArray(array) {
        let cursor = null;
        this.head = null;

        for (let data of array) {
            const item = List.createItem(data);

            if (cursor !== null) {
                cursor.next = item;
            } else {
                this.head = item;
            }

            item.prev = cursor;
            cursor = item;
        }

        this.tail = cursor;
        return this;
    }
    toArray() {
        return [...this];
    }
    toJSON() {
        return [...this];
    }

    // array-like methods
    forEach(fn, thisArg = this) {
        // push cursor
        const cursor = this.allocateCursor(null, this.head);

        while (cursor.next !== null) {
            const item = cursor.next;
            cursor.next = item.next;
            fn.call(thisArg, item.data, item, this);
        }

        // pop cursor
        this.releaseCursor();
    }
    forEachRight(fn, thisArg = this) {
        // push cursor
        const cursor = this.allocateCursor(this.tail, null);

        while (cursor.prev !== null) {
            const item = cursor.prev;
            cursor.prev = item.prev;
            fn.call(thisArg, item.data, item, this);
        }

        // pop cursor
        this.releaseCursor();
    }
    reduce(fn, initialValue, thisArg = this) {
        // push cursor
        let cursor = this.allocateCursor(null, this.head);
        let acc = initialValue;
        let item;

        while (cursor.next !== null) {
            item = cursor.next;
            cursor.next = item.next;

            acc = fn.call(thisArg, acc, item.data, item, this);
        }

        // pop cursor
        this.releaseCursor();

        return acc;
    }
    reduceRight(fn, initialValue, thisArg = this) {
        // push cursor
        let cursor = this.allocateCursor(this.tail, null);
        let acc = initialValue;
        let item;

        while (cursor.prev !== null) {
            item = cursor.prev;
            cursor.prev = item.prev;

            acc = fn.call(thisArg, acc, item.data, item, this);
        }

        // pop cursor
        this.releaseCursor();

        return acc;
    }
    some(fn, thisArg = this) {
        for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
            if (fn.call(thisArg, cursor.data, cursor, this)) {
                return true;
            }
        }

        return false;
    }
    map(fn, thisArg = this) {
        const result = new List();

        for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
            result.appendData(fn.call(thisArg, cursor.data, cursor, this));
        }

        return result;
    }
    filter(fn, thisArg = this) {
        const result = new List();

        for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
            if (fn.call(thisArg, cursor.data, cursor, this)) {
                result.appendData(cursor.data);
            }
        }

        return result;
    }

    nextUntil(start, fn, thisArg = this) {
        if (start === null) {
            return;
        }

        // push cursor
        const cursor = this.allocateCursor(null, start);

        while (cursor.next !== null) {
            const item = cursor.next;
            cursor.next = item.next;
            if (fn.call(thisArg, item.data, item, this)) {
                break;
            }
        }

        // pop cursor
        this.releaseCursor();
    }
    prevUntil(start, fn, thisArg = this) {
        if (start === null) {
            return;
        }

        // push cursor
        const cursor = this.allocateCursor(start, null);

        while (cursor.prev !== null) {
            const item = cursor.prev;
            cursor.prev = item.prev;
            if (fn.call(thisArg, item.data, item, this)) {
                break;
            }
        }

        // pop cursor
        this.releaseCursor();
    }

    // mutation
    clear() {
        this.head = null;
        this.tail = null;
    }
    copy() {
        const result = new List();

        for (let data of this) {
            result.appendData(data);
        }

        return result;
    }
    prepend(item) {
        //      head
        //    ^
        // item
        this.updateCursors(null, item, this.head, item);

        // insert to the beginning of the list
        if (this.head !== null) {
            // new item <- first item
            this.head.prev = item;
            // new item -> first item
            item.next = this.head;
        } else {
            // if list has no head, then it also has no tail
            // in this case tail points to the new item
            this.tail = item;
        }

        // head always points to new item
        this.head = item;
        return this;
    }
    prependData(data) {
        return this.prepend(List.createItem(data));
    }
    append(item) {
        return this.insert(item);
    }
    appendData(data) {
        return this.insert(List.createItem(data));
    }
    insert(item, before = null) {
        if (before !== null) {
            // prev   before
            //      ^
            //     item
            this.updateCursors(before.prev, item, before, item);

            if (before.prev === null) {
                // insert to the beginning of list
                if (this.head !== before) {
                    throw new Error('before doesn\'t belong to list');
                }
                // since head points to before therefore list doesn't empty
                // no need to check tail
                this.head = item;
                before.prev = item;
                item.next = before;
                this.updateCursors(null, item);
            } else {
                // insert between two items
                before.prev.next = item;
                item.prev = before.prev;
                before.prev = item;
                item.next = before;
            }
        } else {
            // tail
            //      ^
            //      item
            this.updateCursors(this.tail, item, null, item);

            // insert to the ending of the list
            if (this.tail !== null) {
                // last item -> new item
                this.tail.next = item;
                // last item <- new item
                item.prev = this.tail;
            } else {
                // if list has no tail, then it also has no head
                // in this case head points to new item
                this.head = item;
            }

            // tail always points to new item
            this.tail = item;
        }

        return this;
    }
    insertData(data, before) {
        return this.insert(List.createItem(data), before);
    }
    remove(item) {
        //      item
        //       ^
        // prev     next
        this.updateCursors(item, item.prev, item, item.next);

        if (item.prev !== null) {
            item.prev.next = item.next;
        } else {
            if (this.head !== item) {
                throw new Error('item doesn\'t belong to list');
            }

            this.head = item.next;
        }

        if (item.next !== null) {
            item.next.prev = item.prev;
        } else {
            if (this.tail !== item) {
                throw new Error('item doesn\'t belong to list');
            }

            this.tail = item.prev;
        }

        item.prev = null;
        item.next = null;

        return item;
    }
    push(data) {
        this.insert(List.createItem(data));
    }
    pop() {
        return this.tail !== null ? this.remove(this.tail) : null;
    }
    unshift(data) {
        this.prepend(List.createItem(data));
    }
    shift() {
        return this.head !== null ? this.remove(this.head) : null;
    }
    prependList(list) {
        return this.insertList(list, this.head);
    }
    appendList(list) {
        return this.insertList(list);
    }
    insertList(list, before) {
        // ignore empty lists
        if (list.head === null) {
            return this;
        }

        if (before !== undefined && before !== null) {
            this.updateCursors(before.prev, list.tail, before, list.head);

            // insert in the middle of dist list
            if (before.prev !== null) {
                // before.prev <-> list.head
                before.prev.next = list.head;
                list.head.prev = before.prev;
            } else {
                this.head = list.head;
            }

            before.prev = list.tail;
            list.tail.next = before;
        } else {
            this.updateCursors(this.tail, list.tail, null, list.head);

            // insert to end of the list
            if (this.tail !== null) {
                // if destination list has a tail, then it also has a head,
                // but head doesn't change
                // dest tail -> source head
                this.tail.next = list.head;
                // dest tail <- source head
                list.head.prev = this.tail;
            } else {
                // if list has no a tail, then it also has no a head
                // in this case points head to new item
                this.head = list.head;
            }

            // tail always start point to new item
            this.tail = list.tail;
        }

        list.head = null;
        list.tail = null;
        return this;
    }
    replace(oldItem, newItemOrList) {
        if ('head' in newItemOrList) {
            this.insertList(newItemOrList, oldItem);
        } else {
            this.insert(newItemOrList, oldItem);
        }

        this.remove(oldItem);
    }
}

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/utils/create-custom-error.js
function createCustomError(name, message) {
    // use Object.create(), because some VMs prevent setting line/column otherwise
    // (iOS Safari 10 even throws an exception)
    const error = Object.create(SyntaxError.prototype);
    const errorStack = new Error();

    return Object.assign(error, {
        name,
        message,
        get stack() {
            return (errorStack.stack || '').replace(/^(.+\n){1,3}/, `${name}: ${message}\n`);
        }
    });
};

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/parser/SyntaxError.js


const MAX_LINE_LENGTH = 100;
const OFFSET_CORRECTION = 60;
const TAB_REPLACEMENT = '    ';

function sourceFragment({ source, line, column }, extraLines) {
    function processLines(start, end) {
        return lines
            .slice(start, end)
            .map((line, idx) =>
                String(start + idx + 1).padStart(maxNumLength) + ' |' + line
            ).join('\n');
    }

    const lines = source.split(/\r\n?|\n|\f/);
    const startLine = Math.max(1, line - extraLines) - 1;
    const endLine = Math.min(line + extraLines, lines.length + 1);
    const maxNumLength = Math.max(4, String(endLine).length) + 1;
    let cutLeft = 0;

    // column correction according to replaced tab before column
    column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;

    if (column > MAX_LINE_LENGTH) {
        cutLeft = column - OFFSET_CORRECTION + 3;
        column = OFFSET_CORRECTION - 2;
    }

    for (let i = startLine; i <= endLine; i++) {
        if (i >= 0 && i < lines.length) {
            lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
            lines[i] =
                (cutLeft > 0 && lines[i].length > cutLeft ? '\u2026' : '') +
                lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) +
                (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? '\u2026' : '');
        }
    }

    return [
        processLines(startLine, line),
        new Array(column + maxNumLength + 2).join('-') + '^',
        processLines(line, endLine)
    ].filter(Boolean).join('\n');
}

function SyntaxError_SyntaxError(message, source, offset, line, column) {
    const error = Object.assign(createCustomError('SyntaxError', message), {
        source,
        offset,
        line,
        column,
        sourceFragment(extraLines) {
            return sourceFragment({ source, line, column }, isNaN(extraLines) ? 0 : extraLines);
        },
        get formattedMessage() {
            return (
                `Parse error: ${message}\n` +
                sourceFragment({ source, line, column }, 2)
            );
        }
    });

    return error;
}

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/parser/sequence.js


function readSequence(recognizer) {
    const children = this.createList();
    let space = false;
    const context = {
        recognizer
    };

    while (!this.eof) {
        switch (this.tokenType) {
            case Comment:
                this.next();
                continue;

            case WhiteSpace:
                space = true;
                this.next();
                continue;
        }

        let child = recognizer.getNode.call(this, context);

        if (child === undefined) {
            break;
        }

        if (space) {
            if (recognizer.onWhiteSpace) {
                recognizer.onWhiteSpace.call(this, child, children, context);
            }
            space = false;
        }

        children.push(child);
    }

    if (space && recognizer.onWhiteSpace) {
        recognizer.onWhiteSpace.call(this, null, children, context);
    }

    return children;
};

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/parser/create.js





const NOOP = () => {};
const EXCLAMATIONMARK = 0x0021;  // U+0021 EXCLAMATION MARK (!)
const NUMBERSIGN = 0x0023;       // U+0023 NUMBER SIGN (#)
const SEMICOLON = 0x003B;        // U+003B SEMICOLON (;)
const LEFTCURLYBRACKET = 0x007B; // U+007B LEFT CURLY BRACKET ({)
const NULL = 0;

function createParseContext(name) {
    return function() {
        return this[name]();
    };
}

function fetchParseValues(dict) {
    const result = Object.create(null);

    for (const name in dict) {
        const item = dict[name];
        const fn = item.parse || item;

        if (fn) {
            result[name] = fn;
        }
    }

    return result;
}

function processConfig(config) {
    const parseConfig = {
        context: Object.create(null),
        scope: Object.assign(Object.create(null), config.scope),
        atrule: fetchParseValues(config.atrule),
        pseudo: fetchParseValues(config.pseudo),
        node: fetchParseValues(config.node)
    };

    for (const name in config.parseContext) {
        switch (typeof config.parseContext[name]) {
            case 'function':
                parseConfig.context[name] = config.parseContext[name];
                break;

            case 'string':
                parseConfig.context[name] = createParseContext(config.parseContext[name]);
                break;
        }
    }

    return {
        config: parseConfig,
        ...parseConfig,
        ...parseConfig.node
    };
}

function createParser(config) {
    let source = '';
    let filename = '<unknown>';
    let needPositions = false;
    let onParseError = NOOP;
    let onParseErrorThrow = false;

    const locationMap = new OffsetToLocation();
    const parser = Object.assign(new TokenStream(), processConfig(config || {}), {
        parseAtrulePrelude: true,
        parseRulePrelude: true,
        parseValue: true,
        parseCustomProperty: false,

        readSequence: readSequence,

        consumeUntilBalanceEnd: () => 0,
        consumeUntilLeftCurlyBracket(code) {
            return code === LEFTCURLYBRACKET ? 1 : 0;
        },
        consumeUntilLeftCurlyBracketOrSemicolon(code) {
            return code === LEFTCURLYBRACKET || code === SEMICOLON ? 1 : 0;
        },
        consumeUntilExclamationMarkOrSemicolon(code) {
            return code === EXCLAMATIONMARK || code === SEMICOLON ? 1 : 0;
        },
        consumeUntilSemicolonIncluded(code) {
            return code === SEMICOLON ? 2 : 0;
        },

        createList() {
            return new List();
        },
        createSingleNodeList(node) {
            return new List().appendData(node);
        },
        getFirstListNode(list) {
            return list && list.first;
        },
        getLastListNode(list) {
            return list && list.last;
        },

        parseWithFallback(consumer, fallback) {
            const startToken = this.tokenIndex;

            try {
                return consumer.call(this);
            } catch (e) {
                if (onParseErrorThrow) {
                    throw e;
                }

                const fallbackNode = fallback.call(this, startToken);

                onParseErrorThrow = true;
                onParseError(e, fallbackNode);
                onParseErrorThrow = false;

                return fallbackNode;
            }
        },

        lookupNonWSType(offset) {
            let type;

            do {
                type = this.lookupType(offset++);
                if (type !== WhiteSpace) {
                    return type;
                }
            } while (type !== NULL);

            return NULL;
        },

        charCodeAt(offset) {
            return offset >= 0 && offset < source.length ? source.charCodeAt(offset) : 0;
        },
        substring(offsetStart, offsetEnd) {
            return source.substring(offsetStart, offsetEnd);
        },
        substrToCursor(start) {
            return this.source.substring(start, this.tokenStart);
        },

        cmpChar(offset, charCode) {
            return cmpChar(source, offset, charCode);
        },
        cmpStr(offsetStart, offsetEnd, str) {
            return cmpStr(source, offsetStart, offsetEnd, str);
        },

        consume(tokenType) {
            const start = this.tokenStart;

            this.eat(tokenType);

            return this.substrToCursor(start);
        },
        consumeFunctionName() {
            const name = source.substring(this.tokenStart, this.tokenEnd - 1);

            this.eat(types_Function);

            return name;
        },
        consumeNumber(type) {
            const number = source.substring(this.tokenStart, consumeNumber(source, this.tokenStart));

            this.eat(type);

            return number;
        },

        eat(tokenType) {
            if (this.tokenType !== tokenType) {
                const tokenName = names[tokenType].slice(0, -6).replace(/-/g, ' ').replace(/^./, m => m.toUpperCase());
                let message = `${/[[\](){}]/.test(tokenName) ? `"${tokenName}"` : tokenName} is expected`;
                let offset = this.tokenStart;

                // tweak message and offset
                switch (tokenType) {
                    case Ident:
                        // when identifier is expected but there is a function or url
                        if (this.tokenType === types_Function || this.tokenType === Url) {
                            offset = this.tokenEnd - 1;
                            message = 'Identifier is expected but function found';
                        } else {
                            message = 'Identifier is expected';
                        }
                        break;

                    case Hash:
                        if (this.isDelim(NUMBERSIGN)) {
                            this.next();
                            offset++;
                            message = 'Name is expected';
                        }
                        break;

                    case Percentage:
                        if (this.tokenType === types_Number) {
                            offset = this.tokenEnd;
                            message = 'Percent sign is expected';
                        }
                        break;
                }

                this.error(message, offset);
            }

            this.next();
        },
        eatIdent(name) {
            if (this.tokenType !== Ident || this.lookupValue(0, name) === false) {
                this.error(`Identifier "${name}" is expected`);
            }

            this.next();
        },
        eatDelim(code) {
            if (!this.isDelim(code)) {
                this.error(`Delim "${String.fromCharCode(code)}" is expected`);
            }

            this.next();
        },

        getLocation(start, end) {
            if (needPositions) {
                return locationMap.getLocationRange(
                    start,
                    end,
                    filename
                );
            }

            return null;
        },
        getLocationFromList(list) {
            if (needPositions) {
                const head = this.getFirstListNode(list);
                const tail = this.getLastListNode(list);
                return locationMap.getLocationRange(
                    head !== null ? head.loc.start.offset - locationMap.startOffset : this.tokenStart,
                    tail !== null ? tail.loc.end.offset - locationMap.startOffset : this.tokenStart,
                    filename
                );
            }

            return null;
        },

        error(message, offset) {
            const location = typeof offset !== 'undefined' && offset < source.length
                ? locationMap.getLocation(offset)
                : this.eof
                    ? locationMap.getLocation(findWhiteSpaceStart(source, source.length - 1))
                    : locationMap.getLocation(this.tokenStart);

            throw new SyntaxError_SyntaxError(
                message || 'Unexpected input',
                source,
                location.offset,
                location.line,
                location.column
            );
        }
    });

    const parse = function(source_, options) {
        source = source_;
        options = options || {};

        parser.setSource(source, tokenize);
        locationMap.setSource(
            source,
            options.offset,
            options.line,
            options.column
        );

        filename = options.filename || '<unknown>';
        needPositions = Boolean(options.positions);
        onParseError = typeof options.onParseError === 'function' ? options.onParseError : NOOP;
        onParseErrorThrow = false;

        parser.parseAtrulePrelude = 'parseAtrulePrelude' in options ? Boolean(options.parseAtrulePrelude) : true;
        parser.parseRulePrelude = 'parseRulePrelude' in options ? Boolean(options.parseRulePrelude) : true;
        parser.parseValue = 'parseValue' in options ? Boolean(options.parseValue) : true;
        parser.parseCustomProperty = 'parseCustomProperty' in options ? Boolean(options.parseCustomProperty) : false;

        const { context = 'default', onComment } = options;

        if (context in parser.context === false) {
            throw new Error('Unknown context `' + context + '`');
        }

        if (typeof onComment === 'function') {
            parser.forEachToken((type, start, end) => {
                if (type === Comment) {
                    const loc = parser.getLocation(start, end);
                    const value = cmpStr(source, end - 2, end, '*/')
                        ? source.slice(start + 2, end - 2)
                        : source.slice(start + 2, end);

                    onComment(value, loc);
                }
            });
        }

        const ast = parser.context[context].call(parser, options);

        if (!parser.eof) {
            parser.error();
        }

        return ast;
    };

    return Object.assign(parse, {
        SyntaxError: SyntaxError_SyntaxError,
        config: parser.config
    });
};

// EXTERNAL MODULE: ./node_modules/source-map-js/lib/source-map-generator.js
var source_map_generator = __webpack_require__(4508);
;// CONCATENATED MODULE: ./node_modules/css-tree/lib/generator/sourceMap.js


const trackNodes = new Set(['Atrule', 'Selector', 'Declaration']);

function generateSourceMap(handlers) {
    const map = new source_map_generator/* SourceMapGenerator */.h();
    const generated = {
        line: 1,
        column: 0
    };
    const original = {
        line: 0, // should be zero to add first mapping
        column: 0
    };
    const activatedGenerated = {
        line: 1,
        column: 0
    };
    const activatedMapping = {
        generated: activatedGenerated
    };
    let line = 1;
    let column = 0;
    let sourceMappingActive = false;

    const origHandlersNode = handlers.node;
    handlers.node = function(node) {
        if (node.loc && node.loc.start && trackNodes.has(node.type)) {
            const nodeLine = node.loc.start.line;
            const nodeColumn = node.loc.start.column - 1;

            if (original.line !== nodeLine ||
                original.column !== nodeColumn) {
                original.line = nodeLine;
                original.column = nodeColumn;

                generated.line = line;
                generated.column = column;

                if (sourceMappingActive) {
                    sourceMappingActive = false;
                    if (generated.line !== activatedGenerated.line ||
                        generated.column !== activatedGenerated.column) {
                        map.addMapping(activatedMapping);
                    }
                }

                sourceMappingActive = true;
                map.addMapping({
                    source: node.loc.source,
                    original,
                    generated
                });
            }
        }

        origHandlersNode.call(this, node);

        if (sourceMappingActive && trackNodes.has(node.type)) {
            activatedGenerated.line = line;
            activatedGenerated.column = column;
        }
    };

    const origHandlersEmit = handlers.emit;
    handlers.emit = function(value, type, auto) {
        for (let i = 0; i < value.length; i++) {
            if (value.charCodeAt(i) === 10) { // \n
                line++;
                column = 0;
            } else {
                column++;
            }
        }

        origHandlersEmit(value, type, auto);
    };

    const origHandlersResult = handlers.result;
    handlers.result = function() {
        if (sourceMappingActive) {
            map.addMapping(activatedMapping);
        }

        return {
            css: origHandlersResult(),
            map
        };
    };

    return handlers;
};

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/generator/token-before.js


const PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
const HYPHENMINUS = 0x002D; // U+002D HYPHEN-MINUS (-)

const code = (type, value) => {
    if (type === Delim) {
        type = value;
    }

    if (typeof type === 'string') {
        const charCode = type.charCodeAt(0);
        return charCode > 0x7F ? 0x8000 : charCode << 8;
    }

    return type;
};

// https://www.w3.org/TR/css-syntax-3/#serialization
// The only requirement for serialization is that it must "round-trip" with parsing,
// that is, parsing the stylesheet must produce the same data structures as parsing,
// serializing, and parsing again, except for consecutive <whitespace-token>s,
// which may be collapsed into a single token.

const specPairs = [
    [Ident, Ident],
    [Ident, types_Function],
    [Ident, Url],
    [Ident, BadUrl],
    [Ident, '-'],
    [Ident, types_Number],
    [Ident, Percentage],
    [Ident, Dimension],
    [Ident, CDC],
    [Ident, LeftParenthesis],

    [AtKeyword, Ident],
    [AtKeyword, types_Function],
    [AtKeyword, Url],
    [AtKeyword, BadUrl],
    [AtKeyword, '-'],
    [AtKeyword, types_Number],
    [AtKeyword, Percentage],
    [AtKeyword, Dimension],
    [AtKeyword, CDC],

    [Hash, Ident],
    [Hash, types_Function],
    [Hash, Url],
    [Hash, BadUrl],
    [Hash, '-'],
    [Hash, types_Number],
    [Hash, Percentage],
    [Hash, Dimension],
    [Hash, CDC],

    [Dimension, Ident],
    [Dimension, types_Function],
    [Dimension, Url],
    [Dimension, BadUrl],
    [Dimension, '-'],
    [Dimension, types_Number],
    [Dimension, Percentage],
    [Dimension, Dimension],
    [Dimension, CDC],

    ['#', Ident],
    ['#', types_Function],
    ['#', Url],
    ['#', BadUrl],
    ['#', '-'],
    ['#', types_Number],
    ['#', Percentage],
    ['#', Dimension],
    ['#', CDC], // https://github.com/w3c/csswg-drafts/pull/6874

    ['-', Ident],
    ['-', types_Function],
    ['-', Url],
    ['-', BadUrl],
    ['-', '-'],
    ['-', types_Number],
    ['-', Percentage],
    ['-', Dimension],
    ['-', CDC], // https://github.com/w3c/csswg-drafts/pull/6874

    [types_Number, Ident],
    [types_Number, types_Function],
    [types_Number, Url],
    [types_Number, BadUrl],
    [types_Number, types_Number],
    [types_Number, Percentage],
    [types_Number, Dimension],
    [types_Number, '%'],
    [types_Number, CDC], // https://github.com/w3c/csswg-drafts/pull/6874

    ['@', Ident],
    ['@', types_Function],
    ['@', Url],
    ['@', BadUrl],
    ['@', '-'],
    ['@', CDC], // https://github.com/w3c/csswg-drafts/pull/6874

    ['.', types_Number],
    ['.', Percentage],
    ['.', Dimension],

    ['+', types_Number],
    ['+', Percentage],
    ['+', Dimension],

    ['/', '*']
];
// validate with scripts/generate-safe
const safePairs = specPairs.concat([
    [Ident, Hash],

    [Dimension, Hash],

    [Hash, Hash],

    [AtKeyword, LeftParenthesis],
    [AtKeyword, types_String],
    [AtKeyword, Colon],

    [Percentage, Percentage],
    [Percentage, Dimension],
    [Percentage, types_Function],
    [Percentage, '-'],

    [RightParenthesis, Ident],
    [RightParenthesis, types_Function],
    [RightParenthesis, Percentage],
    [RightParenthesis, Dimension],
    [RightParenthesis, Hash],
    [RightParenthesis, '-']
]);

function createMap(pairs) {
    const isWhiteSpaceRequired = new Set(
        pairs.map(([prev, next]) => (code(prev) << 16 | code(next)))
    );

    return function(prevCode, type, value) {
        const nextCode = code(type, value);
        const nextCharCode = value.charCodeAt(0);
        const emitWs =
            (nextCharCode === HYPHENMINUS &&
                type !== Ident &&
                type !== types_Function &&
                type !== CDC) ||
            (nextCharCode === PLUSSIGN)
                ? isWhiteSpaceRequired.has(prevCode << 16 | nextCharCode << 8)
                : isWhiteSpaceRequired.has(prevCode << 16 | nextCode);

        if (emitWs) {
            this.emit(' ', WhiteSpace, true);
        }

        return nextCode;
    };
}

const spec = createMap(specPairs);
const safe = createMap(safePairs);

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/generator/create.js




const REVERSESOLIDUS = 0x005c; // U+005C REVERSE SOLIDUS (\)

function processChildren(node, delimeter) {
    if (typeof delimeter === 'function') {
        let prev = null;

        node.children.forEach(node => {
            if (prev !== null) {
                delimeter.call(this, prev);
            }

            this.node(node);
            prev = node;
        });

        return;
    }

    node.children.forEach(this.node, this);
}

function processChunk(chunk) {
    tokenize(chunk, (type, start, end) => {
        this.token(type, chunk.slice(start, end));
    });
}

function createGenerator(config) {
    const types = new Map();

    for (let name in config.node) {
        const item = config.node[name];
        const fn = item.generate || item;

        if (typeof fn === 'function') {
            types.set(name, item.generate || item);
        }
    }

    return function(node, options) {
        let buffer = '';
        let prevCode = 0;
        let handlers = {
            node(node) {
                if (types.has(node.type)) {
                    types.get(node.type).call(publicApi, node);
                } else {
                    throw new Error('Unknown node type: ' + node.type);
                }
            },
            tokenBefore: safe,
            token(type, value) {
                prevCode = this.tokenBefore(prevCode, type, value);

                this.emit(value, type, false);

                if (type === Delim && value.charCodeAt(0) === REVERSESOLIDUS) {
                    this.emit('\n', WhiteSpace, true);
                }
            },
            emit(value) {
                buffer += value;
            },
            result() {
                return buffer;
            }
        };

        if (options) {
            if (typeof options.decorator === 'function') {
                handlers = options.decorator(handlers);
            }

            if (options.sourceMap) {
                handlers = generateSourceMap(handlers);
            }

            if (options.mode in token_before_namespaceObject) {
                handlers.tokenBefore = token_before_namespaceObject[options.mode];
            }
        }

        const publicApi = {
            node: (node) => handlers.node(node),
            children: processChildren,
            token: (type, value) => handlers.token(type, value),
            tokenize: processChunk
        };

        handlers.node(node);

        return handlers.result();
    };
};

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/convertor/create.js


function createConvertor(walk) {
    return {
        fromPlainObject(ast) {
            walk(ast, {
                enter(node) {
                    if (node.children && node.children instanceof List === false) {
                        node.children = new List().fromArray(node.children);
                    }
                }
            });

            return ast;
        },
        toPlainObject(ast) {
            walk(ast, {
                leave(node) {
                    if (node.children && node.children instanceof List) {
                        node.children = node.children.toArray();
                    }
                }
            });

            return ast;
        }
    };
};

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/walker/create.js
const { hasOwnProperty: create_hasOwnProperty } = Object.prototype;
const noop = function() {};

function ensureFunction(value) {
    return typeof value === 'function' ? value : noop;
}

function invokeForType(fn, type) {
    return function(node, item, list) {
        if (node.type === type) {
            fn.call(this, node, item, list);
        }
    };
}

function getWalkersFromStructure(name, nodeType) {
    const structure = nodeType.structure;
    const walkers = [];

    for (const key in structure) {
        if (create_hasOwnProperty.call(structure, key) === false) {
            continue;
        }

        let fieldTypes = structure[key];
        const walker = {
            name: key,
            type: false,
            nullable: false
        };

        if (!Array.isArray(fieldTypes)) {
            fieldTypes = [fieldTypes];
        }

        for (const fieldType of fieldTypes) {
            if (fieldType === null) {
                walker.nullable = true;
            } else if (typeof fieldType === 'string') {
                walker.type = 'node';
            } else if (Array.isArray(fieldType)) {
                walker.type = 'list';
            }
        }

        if (walker.type) {
            walkers.push(walker);
        }
    }

    if (walkers.length) {
        return {
            context: nodeType.walkContext,
            fields: walkers
        };
    }

    return null;
}

function getTypesFromConfig(config) {
    const types = {};

    for (const name in config.node) {
        if (create_hasOwnProperty.call(config.node, name)) {
            const nodeType = config.node[name];

            if (!nodeType.structure) {
                throw new Error('Missed `structure` field in `' + name + '` node type definition');
            }

            types[name] = getWalkersFromStructure(name, nodeType);
        }
    }

    return types;
}

function createTypeIterator(config, reverse) {
    const fields = config.fields.slice();
    const contextName = config.context;
    const useContext = typeof contextName === 'string';

    if (reverse) {
        fields.reverse();
    }

    return function(node, context, walk, walkReducer) {
        let prevContextValue;

        if (useContext) {
            prevContextValue = context[contextName];
            context[contextName] = node;
        }

        for (const field of fields) {
            const ref = node[field.name];

            if (!field.nullable || ref) {
                if (field.type === 'list') {
                    const breakWalk = reverse
                        ? ref.reduceRight(walkReducer, false)
                        : ref.reduce(walkReducer, false);

                    if (breakWalk) {
                        return true;
                    }
                } else if (walk(ref)) {
                    return true;
                }
            }
        }

        if (useContext) {
            context[contextName] = prevContextValue;
        }
    };
}

function createFastTraveralMap({
    StyleSheet,
    Atrule,
    Rule,
    Block,
    DeclarationList
}) {
    return {
        Atrule: {
            StyleSheet,
            Atrule,
            Rule,
            Block
        },
        Rule: {
            StyleSheet,
            Atrule,
            Rule,
            Block
        },
        Declaration: {
            StyleSheet,
            Atrule,
            Rule,
            Block,
            DeclarationList
        }
    };
}

function createWalker(config) {
    const types = getTypesFromConfig(config);
    const iteratorsNatural = {};
    const iteratorsReverse = {};
    const breakWalk = Symbol('break-walk');
    const skipNode = Symbol('skip-node');

    for (const name in types) {
        if (create_hasOwnProperty.call(types, name) && types[name] !== null) {
            iteratorsNatural[name] = createTypeIterator(types[name], false);
            iteratorsReverse[name] = createTypeIterator(types[name], true);
        }
    }

    const fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
    const fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);

    const walk = function(root, options) {
        function walkNode(node, item, list) {
            const enterRet = enter.call(context, node, item, list);

            if (enterRet === breakWalk) {
                return true;
            }

            if (enterRet === skipNode) {
                return false;
            }

            if (iterators.hasOwnProperty(node.type)) {
                if (iterators[node.type](node, context, walkNode, walkReducer)) {
                    return true;
                }
            }

            if (leave.call(context, node, item, list) === breakWalk) {
                return true;
            }

            return false;
        }

        let enter = noop;
        let leave = noop;
        let iterators = iteratorsNatural;
        let walkReducer = (ret, data, item, list) => ret || walkNode(data, item, list);
        const context = {
            break: breakWalk,
            skip: skipNode,

            root,
            stylesheet: null,
            atrule: null,
            atrulePrelude: null,
            rule: null,
            selector: null,
            block: null,
            declaration: null,
            function: null
        };

        if (typeof options === 'function') {
            enter = options;
        } else if (options) {
            enter = ensureFunction(options.enter);
            leave = ensureFunction(options.leave);

            if (options.reverse) {
                iterators = iteratorsReverse;
            }

            if (options.visit) {
                if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
                    iterators = options.reverse
                        ? fastTraversalIteratorsReverse[options.visit]
                        : fastTraversalIteratorsNatural[options.visit];
                } else if (!types.hasOwnProperty(options.visit)) {
                    throw new Error('Bad value `' + options.visit + '` for `visit` option (should be: ' + Object.keys(types).sort().join(', ') + ')');
                }

                enter = invokeForType(enter, options.visit);
                leave = invokeForType(leave, options.visit);
            }
        }

        if (enter === noop && leave === noop) {
            throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
        }

        walkNode(root);
    };

    walk.break = breakWalk;
    walk.skip = skipNode;

    walk.find = function(ast, fn) {
        let found = null;

        walk(ast, function(node, item, list) {
            if (fn.call(this, node, item, list)) {
                found = node;
                return breakWalk;
            }
        });

        return found;
    };

    walk.findLast = function(ast, fn) {
        let found = null;

        walk(ast, {
            reverse: true,
            enter(node, item, list) {
                if (fn.call(this, node, item, list)) {
                    found = node;
                    return breakWalk;
                }
            }
        });

        return found;
    };

    walk.findAll = function(ast, fn) {
        const found = [];

        walk(ast, function(node, item, list) {
            if (fn.call(this, node, item, list)) {
                found.push(node);
            }
        });

        return found;
    };

    return walk;
};

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/definition-syntax/generate.js
function generate_noop(value) {
    return value;
}

function generateMultiplier(multiplier) {
    const { min, max, comma } = multiplier;

    if (min === 0 && max === 0) {
        return comma ? '#?' : '*';
    }

    if (min === 0 && max === 1) {
        return '?';
    }

    if (min === 1 && max === 0) {
        return comma ? '#' : '+';
    }

    if (min === 1 && max === 1) {
        return '';
    }

    return (
        (comma ? '#' : '') +
        (min === max
            ? '{' + min + '}'
            : '{' + min + ',' + (max !== 0 ? max : '') + '}'
        )
    );
}

function generateTypeOpts(node) {
    switch (node.type) {
        case 'Range':
            return (
                ' [' +
                (node.min === null ? '-' : node.min) +
                ',' +
                (node.max === null ? '' : node.max) +
                ']'
            );

        default:
            throw new Error('Unknown node type `' + node.type + '`');
    }
}

function generateSequence(node, decorate, forceBraces, compact) {
    const combinator = node.combinator === ' ' || compact ? node.combinator : ' ' + node.combinator + ' ';
    const result = node.terms
        .map(term => internalGenerate(term, decorate, forceBraces, compact))
        .join(combinator);

    if (node.explicit || forceBraces) {
        return (compact || result[0] === ',' ? '[' : '[ ') + result + (compact ? ']' : ' ]');
    }

    return result;
}

function internalGenerate(node, decorate, forceBraces, compact) {
    let result;

    switch (node.type) {
        case 'Group':
            result =
                generateSequence(node, decorate, forceBraces, compact) +
                (node.disallowEmpty ? '!' : '');
            break;

        case 'Multiplier':
            // return since node is a composition
            return (
                internalGenerate(node.term, decorate, forceBraces, compact) +
                decorate(generateMultiplier(node), node)
            );

        case 'Type':
            result = '<' + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : '') + '>';
            break;

        case 'Property':
            result = '<\'' + node.name + '\'>';
            break;

        case 'Keyword':
            result = node.name;
            break;

        case 'AtKeyword':
            result = '@' + node.name;
            break;

        case 'Function':
            result = node.name + '(';
            break;

        case 'String':
        case 'Token':
            result = node.value;
            break;

        case 'Comma':
            result = ',';
            break;

        default:
            throw new Error('Unknown node type `' + node.type + '`');
    }

    return decorate(result, node);
}

function generate(node, options) {
    let decorate = generate_noop;
    let forceBraces = false;
    let compact = false;

    if (typeof options === 'function') {
        decorate = options;
    } else if (options) {
        forceBraces = Boolean(options.forceBraces);
        compact = Boolean(options.compact);
        if (typeof options.decorate === 'function') {
            decorate = options.decorate;
        }
    }

    return internalGenerate(node, decorate, forceBraces, compact);
};

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/lexer/error.js



const defaultLoc = { offset: 0, line: 1, column: 1 };

function locateMismatch(matchResult, node) {
    const tokens = matchResult.tokens;
    const longestMatch = matchResult.longestMatch;
    const mismatchNode = longestMatch < tokens.length ? tokens[longestMatch].node || null : null;
    const badNode = mismatchNode !== node ? mismatchNode : null;
    let mismatchOffset = 0;
    let mismatchLength = 0;
    let entries = 0;
    let css = '';
    let start;
    let end;

    for (let i = 0; i < tokens.length; i++) {
        const token = tokens[i].value;

        if (i === longestMatch) {
            mismatchLength = token.length;
            mismatchOffset = css.length;
        }

        if (badNode !== null && tokens[i].node === badNode) {
            if (i <= longestMatch) {
                entries++;
            } else {
                entries = 0;
            }
        }

        css += token;
    }

    if (longestMatch === tokens.length || entries > 1) { // last
        start = fromLoc(badNode || node, 'end') || buildLoc(defaultLoc, css);
        end = buildLoc(start);
    } else {
        start = fromLoc(badNode, 'start') ||
            buildLoc(fromLoc(node, 'start') || defaultLoc, css.slice(0, mismatchOffset));
        end = fromLoc(badNode, 'end') ||
            buildLoc(start, css.substr(mismatchOffset, mismatchLength));
    }

    return {
        css,
        mismatchOffset,
        mismatchLength,
        start,
        end
    };
}

function fromLoc(node, point) {
    const value = node && node.loc && node.loc[point];

    if (value) {
        return 'line' in value ? buildLoc(value) : value;
    }

    return null;
}

function buildLoc({ offset, line, column }, extra) {
    const loc = {
        offset,
        line,
        column
    };

    if (extra) {
        const lines = extra.split(/\n|\r\n?|\f/);

        loc.offset += extra.length;
        loc.line += lines.length - 1;
        loc.column = lines.length === 1 ? loc.column + extra.length : lines.pop().length + 1;
    }

    return loc;
}

const SyntaxReferenceError = function(type, referenceName) {
    const error = createCustomError(
        'SyntaxReferenceError',
        type + (referenceName ? ' `' + referenceName + '`' : '')
    );

    error.reference = referenceName;

    return error;
};

const SyntaxMatchError = function(message, syntax, node, matchResult) {
    const error = createCustomError('SyntaxMatchError', message);
    const {
        css,
        mismatchOffset,
        mismatchLength,
        start,
        end
    } = locateMismatch(matchResult, node);

    error.rawMessage = message;
    error.syntax = syntax ? generate(syntax) : '<generic>';
    error.css = css;
    error.mismatchOffset = mismatchOffset;
    error.mismatchLength = mismatchLength;
    error.message = message + '\n' +
        '  syntax: ' + error.syntax + '\n' +
        '   value: ' + (css || '<empty string>') + '\n' +
        '  --------' + new Array(error.mismatchOffset + 1).join('-') + '^';

    Object.assign(error, start);
    error.loc = {
        source: (node && node.loc && node.loc.source) || '<unknown>',
        start,
        end
    };

    return error;
};

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/utils/names.js
const keywords = new Map();
const properties = new Map();
const names_HYPHENMINUS = 45; // '-'.charCodeAt()

const keyword = getKeywordDescriptor;
const names_property = getPropertyDescriptor;
const vendorPrefix = (/* unused pure expression or super */ null && (getVendorPrefix));
function isCustomProperty(str, offset) {
    offset = offset || 0;

    return str.length - offset >= 2 &&
           str.charCodeAt(offset) === names_HYPHENMINUS &&
           str.charCodeAt(offset + 1) === names_HYPHENMINUS;
}

function getVendorPrefix(str, offset) {
    offset = offset || 0;

    // verdor prefix should be at least 3 chars length
    if (str.length - offset >= 3) {
        // vendor prefix starts with hyper minus following non-hyper minus
        if (str.charCodeAt(offset) === names_HYPHENMINUS &&
            str.charCodeAt(offset + 1) !== names_HYPHENMINUS) {
            // vendor prefix should contain a hyper minus at the ending
            const secondDashIndex = str.indexOf('-', offset + 2);

            if (secondDashIndex !== -1) {
                return str.substring(offset, secondDashIndex + 1);
            }
        }
    }

    return '';
}

function getKeywordDescriptor(keyword) {
    if (keywords.has(keyword)) {
        return keywords.get(keyword);
    }

    const name = keyword.toLowerCase();
    let descriptor = keywords.get(name);

    if (descriptor === undefined) {
        const custom = isCustomProperty(name, 0);
        const vendor = !custom ? getVendorPrefix(name, 0) : '';
        descriptor = Object.freeze({
            basename: name.substr(vendor.length),
            name,
            prefix: vendor,
            vendor,
            custom
        });
    }

    keywords.set(keyword, descriptor);

    return descriptor;
}

function getPropertyDescriptor(property) {
    if (properties.has(property)) {
        return properties.get(property);
    }

    let name = property;
    let hack = property[0];

    if (hack === '/') {
        hack = property[1] === '/' ? '//' : '/';
    } else if (hack !== '_' &&
               hack !== '*' &&
               hack !== '$' &&
               hack !== '#' &&
               hack !== '+' &&
               hack !== '&') {
        hack = '';
    }

    const custom = isCustomProperty(name, hack.length);

    // re-use result when possible (the same as for lower case)
    if (!custom) {
        name = name.toLowerCase();
        if (properties.has(name)) {
            const descriptor = properties.get(name);
            properties.set(property, descriptor);
            return descriptor;
        }
    }

    const vendor = !custom ? getVendorPrefix(name, hack.length) : '';
    const prefix = name.substr(0, hack.length + vendor.length);
    const descriptor = Object.freeze({
        basename: name.substr(prefix.length),
        name: name.substr(hack.length),
        hack,
        vendor,
        prefix,
        custom
    });

    properties.set(property, descriptor);

    return descriptor;
}

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/lexer/generic-const.js
// https://drafts.csswg.org/css-cascade-5/
const cssWideKeywords = [
    'initial',
    'inherit',
    'unset',
    'revert',
    'revert-layer'
];

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/lexer/generic-an-plus-b.js


const generic_an_plus_b_PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
const generic_an_plus_b_HYPHENMINUS = 0x002D; // U+002D HYPHEN-MINUS (-)
const generic_an_plus_b_N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
const DISALLOW_SIGN = true;
const ALLOW_SIGN = false;

function isDelim(token, code) {
    return token !== null && token.type === Delim && token.value.charCodeAt(0) === code;
}

function skipSC(token, offset, getNextToken) {
    while (token !== null && (token.type === WhiteSpace || token.type === Comment)) {
        token = getNextToken(++offset);
    }

    return offset;
}

function checkInteger(token, valueOffset, disallowSign, offset) {
    if (!token) {
        return 0;
    }

    const code = token.value.charCodeAt(valueOffset);

    if (code === generic_an_plus_b_PLUSSIGN || code === generic_an_plus_b_HYPHENMINUS) {
        if (disallowSign) {
            // Number sign is not allowed
            return 0;
        }
        valueOffset++;
    }

    for (; valueOffset < token.value.length; valueOffset++) {
        if (!isDigit(token.value.charCodeAt(valueOffset))) {
            // Integer is expected
            return 0;
        }
    }

    return offset + 1;
}

// ... <signed-integer>
// ... ['+' | '-'] <signless-integer>
function consumeB(token, offset_, getNextToken) {
    let sign = false;
    let offset = skipSC(token, offset_, getNextToken);

    token = getNextToken(offset);

    if (token === null) {
        return offset_;
    }

    if (token.type !== types_Number) {
        if (isDelim(token, generic_an_plus_b_PLUSSIGN) || isDelim(token, generic_an_plus_b_HYPHENMINUS)) {
            sign = true;
            offset = skipSC(getNextToken(++offset), offset, getNextToken);
            token = getNextToken(offset);

            if (token === null || token.type !== types_Number) {
                return 0;
            }
        } else {
            return offset_;
        }
    }

    if (!sign) {
        const code = token.value.charCodeAt(0);
        if (code !== generic_an_plus_b_PLUSSIGN && code !== generic_an_plus_b_HYPHENMINUS) {
            // Number sign is expected
            return 0;
        }
    }

    return checkInteger(token, sign ? 0 : 1, sign, offset);
}

// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
function anPlusB(token, getNextToken) {
    /* eslint-disable brace-style*/
    let offset = 0;

    if (!token) {
        return 0;
    }

    // <integer>
    if (token.type === types_Number) {
        return checkInteger(token, 0, ALLOW_SIGN, offset); // b
    }

    // -n
    // -n <signed-integer>
    // -n ['+' | '-'] <signless-integer>
    // -n- <signless-integer>
    // <dashndashdigit-ident>
    else if (token.type === Ident && token.value.charCodeAt(0) === generic_an_plus_b_HYPHENMINUS) {
        // expect 1st char is N
        if (!cmpChar(token.value, 1, generic_an_plus_b_N)) {
            return 0;
        }

        switch (token.value.length) {
            // -n
            // -n <signed-integer>
            // -n ['+' | '-'] <signless-integer>
            case 2:
                return consumeB(getNextToken(++offset), offset, getNextToken);

            // -n- <signless-integer>
            case 3:
                if (token.value.charCodeAt(2) !== generic_an_plus_b_HYPHENMINUS) {
                    return 0;
                }

                offset = skipSC(getNextToken(++offset), offset, getNextToken);
                token = getNextToken(offset);

                return checkInteger(token, 0, DISALLOW_SIGN, offset);

            // <dashndashdigit-ident>
            default:
                if (token.value.charCodeAt(2) !== generic_an_plus_b_HYPHENMINUS) {
                    return 0;
                }

                return checkInteger(token, 3, DISALLOW_SIGN, offset);
        }
    }

    // '+'? n
    // '+'? n <signed-integer>
    // '+'? n ['+' | '-'] <signless-integer>
    // '+'? n- <signless-integer>
    // '+'? <ndashdigit-ident>
    else if (token.type === Ident || (isDelim(token, generic_an_plus_b_PLUSSIGN) && getNextToken(offset + 1).type === Ident)) {
        // just ignore a plus
        if (token.type !== Ident) {
            token = getNextToken(++offset);
        }

        if (token === null || !cmpChar(token.value, 0, generic_an_plus_b_N)) {
            return 0;
        }

        switch (token.value.length) {
            // '+'? n
            // '+'? n <signed-integer>
            // '+'? n ['+' | '-'] <signless-integer>
            case 1:
                return consumeB(getNextToken(++offset), offset, getNextToken);

            // '+'? n- <signless-integer>
            case 2:
                if (token.value.charCodeAt(1) !== generic_an_plus_b_HYPHENMINUS) {
                    return 0;
                }

                offset = skipSC(getNextToken(++offset), offset, getNextToken);
                token = getNextToken(offset);

                return checkInteger(token, 0, DISALLOW_SIGN, offset);

            // '+'? <ndashdigit-ident>
            default:
                if (token.value.charCodeAt(1) !== generic_an_plus_b_HYPHENMINUS) {
                    return 0;
                }

                return checkInteger(token, 2, DISALLOW_SIGN, offset);
        }
    }

    // <ndashdigit-dimension>
    // <ndash-dimension> <signless-integer>
    // <n-dimension>
    // <n-dimension> <signed-integer>
    // <n-dimension> ['+' | '-'] <signless-integer>
    else if (token.type === Dimension) {
        let code = token.value.charCodeAt(0);
        let sign = code === generic_an_plus_b_PLUSSIGN || code === generic_an_plus_b_HYPHENMINUS ? 1 : 0;
        let i = sign;

        for (; i < token.value.length; i++) {
            if (!isDigit(token.value.charCodeAt(i))) {
                break;
            }
        }

        if (i === sign) {
            // Integer is expected
            return 0;
        }

        if (!cmpChar(token.value, i, generic_an_plus_b_N)) {
            return 0;
        }

        // <n-dimension>
        // <n-dimension> <signed-integer>
        // <n-dimension> ['+' | '-'] <signless-integer>
        if (i + 1 === token.value.length) {
            return consumeB(getNextToken(++offset), offset, getNextToken);
        } else {
            if (token.value.charCodeAt(i + 1) !== generic_an_plus_b_HYPHENMINUS) {
                return 0;
            }

            // <ndash-dimension> <signless-integer>
            if (i + 2 === token.value.length) {
                offset = skipSC(getNextToken(++offset), offset, getNextToken);
                token = getNextToken(offset);

                return checkInteger(token, 0, DISALLOW_SIGN, offset);
            }
            // <ndashdigit-dimension>
            else {
                return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
            }
        }
    }

    return 0;
};

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/lexer/generic-urange.js


const generic_urange_PLUSSIGN = 0x002B;     // U+002B PLUS SIGN (+)
const generic_urange_HYPHENMINUS = 0x002D;  // U+002D HYPHEN-MINUS (-)
const QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)
const U = 0x0075;            // U+0075 LATIN SMALL LETTER U (u)

function generic_urange_isDelim(token, code) {
    return token !== null && token.type === Delim && token.value.charCodeAt(0) === code;
}

function startsWith(token, code) {
    return token.value.charCodeAt(0) === code;
}

function hexSequence(token, offset, allowDash) {
    let hexlen = 0;

    for (let pos = offset; pos < token.value.length; pos++) {
        const code = token.value.charCodeAt(pos);

        if (code === generic_urange_HYPHENMINUS && allowDash && hexlen !== 0) {
            hexSequence(token, offset + hexlen + 1, false);
            return 6; // dissallow following question marks
        }

        if (!isHexDigit(code)) {
            return 0; // not a hex digit
        }

        if (++hexlen > 6) {
            return 0; // too many hex digits
        };
    }

    return hexlen;
}

function withQuestionMarkSequence(consumed, length, getNextToken) {
    if (!consumed) {
        return 0; // nothing consumed
    }

    while (generic_urange_isDelim(getNextToken(length), QUESTIONMARK)) {
        if (++consumed > 6) {
            return 0; // too many question marks
        }

        length++;
    }

    return length;
}

// https://drafts.csswg.org/css-syntax/#urange
// Informally, the <urange> production has three forms:
// U+0001
//      Defines a range consisting of a single code point, in this case the code point "1".
// U+0001-00ff
//      Defines a range of codepoints between the first and the second value, in this case
//      the range between "1" and "ff" (255 in decimal) inclusive.
// U+00??
//      Defines a range of codepoints where the "?" characters range over all hex digits,
//      in this case defining the same as the value U+0000-00ff.
// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
//
// <urange> =
//   u '+' <ident-token> '?'* |
//   u <dimension-token> '?'* |
//   u <number-token> '?'* |
//   u <number-token> <dimension-token> |
//   u <number-token> <number-token> |
//   u '+' '?'+
function urange(token, getNextToken) {
    let length = 0;

    // should start with `u` or `U`
    if (token === null || token.type !== Ident || !cmpChar(token.value, 0, U)) {
        return 0;
    }

    token = getNextToken(++length);
    if (token === null) {
        return 0;
    }

    // u '+' <ident-token> '?'*
    // u '+' '?'+
    if (generic_urange_isDelim(token, generic_urange_PLUSSIGN)) {
        token = getNextToken(++length);
        if (token === null) {
            return 0;
        }

        if (token.type === Ident) {
            // u '+' <ident-token> '?'*
            return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
        }

        if (generic_urange_isDelim(token, QUESTIONMARK)) {
            // u '+' '?'+
            return withQuestionMarkSequence(1, ++length, getNextToken);
        }

        // Hex digit or question mark is expected
        return 0;
    }

    // u <number-token> '?'*
    // u <number-token> <dimension-token>
    // u <number-token> <number-token>
    if (token.type === types_Number) {
        const consumedHexLength = hexSequence(token, 1, true);
        if (consumedHexLength === 0) {
            return 0;
        }

        token = getNextToken(++length);
        if (token === null) {
            // u <number-token> <eof>
            return length;
        }

        if (token.type === Dimension || token.type === types_Number) {
            // u <number-token> <dimension-token>
            // u <number-token> <number-token>
            if (!startsWith(token, generic_urange_HYPHENMINUS) || !hexSequence(token, 1, false)) {
                return 0;
            }

            return length + 1;
        }

        // u <number-token> '?'*
        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
    }

    // u <dimension-token> '?'*
    if (token.type === Dimension) {
        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
    }

    return 0;
};

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/lexer/generic.js





const calcFunctionNames = ['calc(', '-moz-calc(', '-webkit-calc('];
const generic_balancePair = new Map([
    [types_Function, RightParenthesis],
    [LeftParenthesis, RightParenthesis],
    [LeftSquareBracket, RightSquareBracket],
    [LeftCurlyBracket, RightCurlyBracket]
]);

// units
const LENGTH = [
    // absolute length units https://www.w3.org/TR/css-values-3/#lengths
    'cm', 'mm', 'q', 'in', 'pt', 'pc', 'px',
    // font-relative length units https://drafts.csswg.org/css-values-4/#font-relative-lengths
    'em', 'rem',
    'ex', 'rex',
    'cap', 'rcap',
    'ch', 'rch',
    'ic', 'ric',
    'lh', 'rlh',
    // viewport-percentage lengths https://drafts.csswg.org/css-values-4/#viewport-relative-lengths
    'vw', 'svw', 'lvw', 'dvw',
    'vh', 'svh', 'lvh', 'dvh',
    'vi', 'svi', 'lvi', 'dvi',
    'vb', 'svb', 'lvb', 'dvb',
    'vmin', 'svmin', 'lvmin', 'dvmin',
    'vmax', 'svmax', 'lvmax', 'dvmax',
    // container relative lengths https://drafts.csswg.org/css-contain-3/#container-lengths
    'cqw', 'cqh', 'cqi', 'cqb', 'cqmin', 'cqmax'
];
const ANGLE = ['deg', 'grad', 'rad', 'turn']; // https://www.w3.org/TR/css-values-3/#angles
const TIME = ['s', 'ms'];                     // https://www.w3.org/TR/css-values-3/#time
const FREQUENCY = ['hz', 'khz'];              // https://www.w3.org/TR/css-values-3/#frequency
const RESOLUTION = ['dpi', 'dpcm', 'dppx', 'x']; // https://www.w3.org/TR/css-values-3/#resolution
const FLEX = ['fr'];                          // https://drafts.csswg.org/css-grid/#fr-unit
const DECIBEL = ['db'];                       // https://www.w3.org/TR/css3-speech/#mixing-props-voice-volume
const SEMITONES = ['st'];                     // https://www.w3.org/TR/css3-speech/#voice-props-voice-pitch

// safe char code getter
function charCodeAt(str, index) {
    return index < str.length ? str.charCodeAt(index) : 0;
}

function eqStr(actual, expected) {
    return cmpStr(actual, 0, actual.length, expected);
}

function eqStrAny(actual, expected) {
    for (let i = 0; i < expected.length; i++) {
        if (eqStr(actual, expected[i])) {
            return true;
        }
    }

    return false;
}

// IE postfix hack, i.e. 123\0 or 123px\9
function isPostfixIeHack(str, offset) {
    if (offset !== str.length - 2) {
        return false;
    }

    return (
        charCodeAt(str, offset) === 0x005C &&  // U+005C REVERSE SOLIDUS (\)
        isDigit(charCodeAt(str, offset + 1))
    );
}

function outOfRange(opts, value, numEnd) {
    if (opts && opts.type === 'Range') {
        const num = Number(
            numEnd !== undefined && numEnd !== value.length
                ? value.substr(0, numEnd)
                : value
        );

        if (isNaN(num)) {
            return true;
        }

        // FIXME: when opts.min is a string it's a dimension, skip a range validation
        // for now since it requires a type covertation which is not implmented yet
        if (opts.min !== null && num < opts.min && typeof opts.min !== 'string') {
            return true;
        }

        // FIXME: when opts.max is a string it's a dimension, skip a range validation
        // for now since it requires a type covertation which is not implmented yet
        if (opts.max !== null && num > opts.max && typeof opts.max !== 'string') {
            return true;
        }
    }

    return false;
}

function consumeFunction(token, getNextToken) {
    let balanceCloseType = 0;
    let balanceStash = [];
    let length = 0;

    // balanced token consuming
    scan:
    do {
        switch (token.type) {
            case RightCurlyBracket:
            case RightParenthesis:
            case RightSquareBracket:
                if (token.type !== balanceCloseType) {
                    break scan;
                }

                balanceCloseType = balanceStash.pop();

                if (balanceStash.length === 0) {
                    length++;
                    break scan;
                }

                break;

            case types_Function:
            case LeftParenthesis:
            case LeftSquareBracket:
            case LeftCurlyBracket:
                balanceStash.push(balanceCloseType);
                balanceCloseType = generic_balancePair.get(token.type);
                break;
        }

        length++;
    } while (token = getNextToken(length));

    return length;
}

// TODO: implement
// can be used wherever <length>, <frequency>, <angle>, <time>, <percentage>, <number>, or <integer> values are allowed
// https://drafts.csswg.org/css-values/#calc-notation
function calc(next) {
    return function(token, getNextToken, opts) {
        if (token === null) {
            return 0;
        }

        if (token.type === types_Function && eqStrAny(token.value, calcFunctionNames)) {
            return consumeFunction(token, getNextToken);
        }

        return next(token, getNextToken, opts);
    };
}

function tokenType(expectedTokenType) {
    return function(token) {
        if (token === null || token.type !== expectedTokenType) {
            return 0;
        }

        return 1;
    };
}

// =========================
// Complex types
//

// https://drafts.csswg.org/css-values-4/#custom-idents
// 4.2. Author-defined Identifiers: the <custom-ident> type
// Some properties accept arbitrary author-defined identifiers as a component value.
// This generic data type is denoted by <custom-ident>, and represents any valid CSS identifier
// that would not be misinterpreted as a pre-defined keyword in that propertys value definition.
//
// See also: https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident
function customIdent(token) {
    if (token === null || token.type !== Ident) {
        return 0;
    }

    const name = token.value.toLowerCase();

    // The CSS-wide keywords are not valid <custom-ident>s
    if (eqStrAny(name, cssWideKeywords)) {
        return 0;
    }

    // The default keyword is reserved and is also not a valid <custom-ident>
    if (eqStr(name, 'default')) {
        return 0;
    }

    // TODO: ignore property specific keywords (as described https://developer.mozilla.org/en-US/docs/Web/CSS/custom-ident)
    // Specifications using <custom-ident> must specify clearly what other keywords
    // are excluded from <custom-ident>, if anyfor example by saying that any pre-defined keywords
    // in that propertys value definition are excluded. Excluded keywords are excluded
    // in all ASCII case permutations.

    return 1;
}

// https://drafts.csswg.org/css-variables/#typedef-custom-property-name
// A custom property is any property whose name starts with two dashes (U+002D HYPHEN-MINUS), like --foo.
// The <custom-property-name> production corresponds to this: its defined as any valid identifier
// that starts with two dashes, except -- itself, which is reserved for future use by CSS.
// NOTE: Current implementation treat `--` as a valid name since most (all?) major browsers treat it as valid.
function customPropertyName(token) {
    // ... defined as any valid identifier
    if (token === null || token.type !== Ident) {
        return 0;
    }

    // ... that starts with two dashes (U+002D HYPHEN-MINUS)
    if (charCodeAt(token.value, 0) !== 0x002D || charCodeAt(token.value, 1) !== 0x002D) {
        return 0;
    }

    return 1;
}

// https://drafts.csswg.org/css-color-4/#hex-notation
// The syntax of a <hex-color> is a <hash-token> token whose value consists of 3, 4, 6, or 8 hexadecimal digits.
// In other words, a hex color is written as a hash character, "#", followed by some number of digits 0-9 or
// letters a-f (the case of the letters doesnt matter - #00ff00 is identical to #00FF00).
function hexColor(token) {
    if (token === null || token.type !== Hash) {
        return 0;
    }

    const length = token.value.length;

    // valid values (length): #rgb (4), #rgba (5), #rrggbb (7), #rrggbbaa (9)
    if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
        return 0;
    }

    for (let i = 1; i < length; i++) {
        if (!isHexDigit(charCodeAt(token.value, i))) {
            return 0;
        }
    }

    return 1;
}

function idSelector(token) {
    if (token === null || token.type !== Hash) {
        return 0;
    }

    if (!isIdentifierStart(charCodeAt(token.value, 1), charCodeAt(token.value, 2), charCodeAt(token.value, 3))) {
        return 0;
    }

    return 1;
}

// https://drafts.csswg.org/css-syntax/#any-value
// It represents the entirety of what a valid declaration can have as its value.
function declarationValue(token, getNextToken) {
    if (!token) {
        return 0;
    }

    let balanceCloseType = 0;
    let balanceStash = [];
    let length = 0;

    // The <declaration-value> production matches any sequence of one or more tokens,
    // so long as the sequence does not contain ...
    scan:
    do {
        switch (token.type) {
            // ... <bad-string-token>, <bad-url-token>,
            case BadString:
            case BadUrl:
                break scan;

            // ... unmatched <)-token>, <]-token>, or <}-token>,
            case RightCurlyBracket:
            case RightParenthesis:
            case RightSquareBracket:
                if (token.type !== balanceCloseType) {
                    break scan;
                }

                balanceCloseType = balanceStash.pop();
                break;

            // ... or top-level <semicolon-token> tokens
            case Semicolon:
                if (balanceCloseType === 0) {
                    break scan;
                }

                break;

            // ... or <delim-token> tokens with a value of "!"
            case Delim:
                if (balanceCloseType === 0 && token.value === '!') {
                    break scan;
                }

                break;

            case types_Function:
            case LeftParenthesis:
            case LeftSquareBracket:
            case LeftCurlyBracket:
                balanceStash.push(balanceCloseType);
                balanceCloseType = generic_balancePair.get(token.type);
                break;
        }

        length++;
    } while (token = getNextToken(length));

    return length;
}

// https://drafts.csswg.org/css-syntax/#any-value
// The <any-value> production is identical to <declaration-value>, but also
// allows top-level <semicolon-token> tokens and <delim-token> tokens
// with a value of "!". It represents the entirety of what valid CSS can be in any context.
function anyValue(token, getNextToken) {
    if (!token) {
        return 0;
    }

    let balanceCloseType = 0;
    let balanceStash = [];
    let length = 0;

    // The <any-value> production matches any sequence of one or more tokens,
    // so long as the sequence ...
    scan:
    do {
        switch (token.type) {
            // ... does not contain <bad-string-token>, <bad-url-token>,
            case BadString:
            case BadUrl:
                break scan;

            // ... unmatched <)-token>, <]-token>, or <}-token>,
            case RightCurlyBracket:
            case RightParenthesis:
            case RightSquareBracket:
                if (token.type !== balanceCloseType) {
                    break scan;
                }

                balanceCloseType = balanceStash.pop();
                break;

            case types_Function:
            case LeftParenthesis:
            case LeftSquareBracket:
            case LeftCurlyBracket:
                balanceStash.push(balanceCloseType);
                balanceCloseType = generic_balancePair.get(token.type);
                break;
        }

        length++;
    } while (token = getNextToken(length));

    return length;
}

// =========================
// Dimensions
//

function dimension(type) {
    if (type) {
        type = new Set(type);
    }

    return function(token, getNextToken, opts) {
        if (token === null || token.type !== Dimension) {
            return 0;
        }

        const numberEnd = consumeNumber(token.value, 0);

        // check unit
        if (type !== null) {
            // check for IE postfix hack, i.e. 123px\0 or 123px\9
            const reverseSolidusOffset = token.value.indexOf('\\', numberEnd);
            const unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset)
                ? token.value.substr(numberEnd)
                : token.value.substring(numberEnd, reverseSolidusOffset);

            if (type.has(unit.toLowerCase()) === false) {
                return 0;
            }
        }

        // check range if specified
        if (outOfRange(opts, token.value, numberEnd)) {
            return 0;
        }

        return 1;
    };
}

// =========================
// Percentage
//

// 5.5. Percentages: the <percentage> type
// https://drafts.csswg.org/css-values-4/#percentages
function percentage(token, getNextToken, opts) {
    // ... corresponds to the <percentage-token> production
    if (token === null || token.type !== Percentage) {
        return 0;
    }

    // check range if specified
    if (outOfRange(opts, token.value, token.value.length - 1)) {
        return 0;
    }

    return 1;
}

// =========================
// Numeric
//

// https://drafts.csswg.org/css-values-4/#numbers
// The value <zero> represents a literal number with the value 0. Expressions that merely
// evaluate to a <number> with the value 0 (for example, calc(0)) do not match <zero>;
// only literal <number-token>s do.
function zero(next) {
    if (typeof next !== 'function') {
        next = function() {
            return 0;
        };
    }

    return function(token, getNextToken, opts) {
        if (token !== null && token.type === types_Number) {
            if (Number(token.value) === 0) {
                return 1;
            }
        }

        return next(token, getNextToken, opts);
    };
}

//  5.3. Real Numbers: the <number> type
// https://drafts.csswg.org/css-values-4/#numbers
// Number values are denoted by <number>, and represent real numbers, possibly with a fractional component.
// ... It corresponds to the <number-token> production
function number(token, getNextToken, opts) {
    if (token === null) {
        return 0;
    }

    const numberEnd = consumeNumber(token.value, 0);
    const isNumber = numberEnd === token.value.length;
    if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
        return 0;
    }

    // check range if specified
    if (outOfRange(opts, token.value, numberEnd)) {
        return 0;
    }

    return 1;
}

// 5.2. Integers: the <integer> type
// https://drafts.csswg.org/css-values-4/#integers
function integer(token, getNextToken, opts) {
    // ... corresponds to a subset of the <number-token> production
    if (token === null || token.type !== types_Number) {
        return 0;
    }

    // The first digit of an integer may be immediately preceded by `-` or `+` to indicate the integers sign.
    let i = charCodeAt(token.value, 0) === 0x002B ||       // U+002B PLUS SIGN (+)
            charCodeAt(token.value, 0) === 0x002D ? 1 : 0; // U+002D HYPHEN-MINUS (-)

    // When written literally, an integer is one or more decimal digits 0 through 9 ...
    for (; i < token.value.length; i++) {
        if (!isDigit(charCodeAt(token.value, i))) {
            return 0;
        }
    }

    // check range if specified
    if (outOfRange(opts, token.value, i)) {
        return 0;
    }

    return 1;
}

/* harmony default export */ const generic = ({
    // token types
    'ident-token': tokenType(Ident),
    'function-token': tokenType(types_Function),
    'at-keyword-token': tokenType(AtKeyword),
    'hash-token': tokenType(Hash),
    'string-token': tokenType(types_String),
    'bad-string-token': tokenType(BadString),
    'url-token': tokenType(Url),
    'bad-url-token': tokenType(BadUrl),
    'delim-token': tokenType(Delim),
    'number-token': tokenType(types_Number),
    'percentage-token': tokenType(Percentage),
    'dimension-token': tokenType(Dimension),
    'whitespace-token': tokenType(WhiteSpace),
    'CDO-token': tokenType(CDO),
    'CDC-token': tokenType(CDC),
    'colon-token': tokenType(Colon),
    'semicolon-token': tokenType(Semicolon),
    'comma-token': tokenType(Comma),
    '[-token': tokenType(LeftSquareBracket),
    ']-token': tokenType(RightSquareBracket),
    '(-token': tokenType(LeftParenthesis),
    ')-token': tokenType(RightParenthesis),
    '{-token': tokenType(LeftCurlyBracket),
    '}-token': tokenType(RightCurlyBracket),

    // token type aliases
    'string': tokenType(types_String),
    'ident': tokenType(Ident),

    // complex types
    'custom-ident': customIdent,
    'custom-property-name': customPropertyName,
    'hex-color': hexColor,
    'id-selector': idSelector, // element( <id-selector> )
    'an-plus-b': anPlusB,
    'urange': urange,
    'declaration-value': declarationValue,
    'any-value': anyValue,

    // dimensions
    'dimension': calc(dimension(null)),
    'angle': calc(dimension(ANGLE)),
    'decibel': calc(dimension(DECIBEL)),
    'frequency': calc(dimension(FREQUENCY)),
    'flex': calc(dimension(FLEX)),
    'length': calc(zero(dimension(LENGTH))),
    'resolution': calc(dimension(RESOLUTION)),
    'semitones': calc(dimension(SEMITONES)),
    'time': calc(dimension(TIME)),

    // percentage
    'percentage': calc(percentage),

    // numeric
    'zero': zero(),
    'number': calc(number),
    'integer': calc(integer)
});

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/definition-syntax/SyntaxError.js


function definition_syntax_SyntaxError_SyntaxError(message, input, offset) {
    return Object.assign(createCustomError('SyntaxError', message), {
        input,
        offset,
        rawMessage: message,
        message: message + '\n' +
            '  ' + input + '\n' +
            '--' + new Array((offset || input.length) + 1).join('-') + '^'
    });
};

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/definition-syntax/tokenizer.js


const TAB = 9;
const tokenizer_N = 10;
const tokenizer_F = 12;
const tokenizer_R = 13;
const SPACE = 32;

class Tokenizer {
    constructor(str) {
        this.str = str;
        this.pos = 0;
    }
    charCodeAt(pos) {
        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
    }
    charCode() {
        return this.charCodeAt(this.pos);
    }
    nextCharCode() {
        return this.charCodeAt(this.pos + 1);
    }
    nextNonWsCode(pos) {
        return this.charCodeAt(this.findWsEnd(pos));
    }
    findWsEnd(pos) {
        for (; pos < this.str.length; pos++) {
            const code = this.str.charCodeAt(pos);
            if (code !== tokenizer_R && code !== tokenizer_N && code !== tokenizer_F && code !== SPACE && code !== TAB) {
                break;
            }
        }

        return pos;
    }
    substringToPos(end) {
        return this.str.substring(this.pos, this.pos = end);
    }
    eat(code) {
        if (this.charCode() !== code) {
            this.error('Expect `' + String.fromCharCode(code) + '`');
        }

        this.pos++;
    }
    peek() {
        return this.pos < this.str.length ? this.str.charAt(this.pos++) : '';
    }
    error(message) {
        throw new definition_syntax_SyntaxError_SyntaxError(message, this.str, this.pos);
    }
};

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/definition-syntax/parse.js


const parse_TAB = 9;
const parse_N = 10;
const parse_F = 12;
const parse_R = 13;
const parse_SPACE = 32;
const parse_EXCLAMATIONMARK = 33;    // !
const parse_NUMBERSIGN = 35;         // #
const AMPERSAND = 38;          // &
const APOSTROPHE = 39;         // '
const LEFTPARENTHESIS = 40;    // (
const RIGHTPARENTHESIS = 41;   // )
const ASTERISK = 42;           // *
const parse_PLUSSIGN = 43;           // +
const COMMA = 44;              // ,
const HYPERMINUS = 45;         // -
const LESSTHANSIGN = 60;       // <
const GREATERTHANSIGN = 62;    // >
const parse_QUESTIONMARK = 63;       // ?
const COMMERCIALAT = 64;       // @
const LEFTSQUAREBRACKET = 91;  // [
const RIGHTSQUAREBRACKET = 93; // ]
const parse_LEFTCURLYBRACKET = 123;  // {
const VERTICALLINE = 124;      // |
const RIGHTCURLYBRACKET = 125; // }
const INFINITY = 8734;         // 
const NAME_CHAR = new Uint8Array(128).map((_, idx) =>
    /[a-zA-Z0-9\-]/.test(String.fromCharCode(idx)) ? 1 : 0
);
const COMBINATOR_PRECEDENCE = {
    ' ': 1,
    '&&': 2,
    '||': 3,
    '|': 4
};

function scanSpaces(tokenizer) {
    return tokenizer.substringToPos(
        tokenizer.findWsEnd(tokenizer.pos)
    );
}

function scanWord(tokenizer) {
    let end = tokenizer.pos;

    for (; end < tokenizer.str.length; end++) {
        const code = tokenizer.str.charCodeAt(end);
        if (code >= 128 || NAME_CHAR[code] === 0) {
            break;
        }
    }

    if (tokenizer.pos === end) {
        tokenizer.error('Expect a keyword');
    }

    return tokenizer.substringToPos(end);
}

function scanNumber(tokenizer) {
    let end = tokenizer.pos;

    for (; end < tokenizer.str.length; end++) {
        const code = tokenizer.str.charCodeAt(end);
        if (code < 48 || code > 57) {
            break;
        }
    }

    if (tokenizer.pos === end) {
        tokenizer.error('Expect a number');
    }

    return tokenizer.substringToPos(end);
}

function scanString(tokenizer) {
    const end = tokenizer.str.indexOf('\'', tokenizer.pos + 1);

    if (end === -1) {
        tokenizer.pos = tokenizer.str.length;
        tokenizer.error('Expect an apostrophe');
    }

    return tokenizer.substringToPos(end + 1);
}

function readMultiplierRange(tokenizer) {
    let min = null;
    let max = null;

    tokenizer.eat(parse_LEFTCURLYBRACKET);

    min = scanNumber(tokenizer);

    if (tokenizer.charCode() === COMMA) {
        tokenizer.pos++;
        if (tokenizer.charCode() !== RIGHTCURLYBRACKET) {
            max = scanNumber(tokenizer);
        }
    } else {
        max = min;
    }

    tokenizer.eat(RIGHTCURLYBRACKET);

    return {
        min: Number(min),
        max: max ? Number(max) : 0
    };
}

function readMultiplier(tokenizer) {
    let range = null;
    let comma = false;

    switch (tokenizer.charCode()) {
        case ASTERISK:
            tokenizer.pos++;

            range = {
                min: 0,
                max: 0
            };

            break;

        case parse_PLUSSIGN:
            tokenizer.pos++;

            range = {
                min: 1,
                max: 0
            };

            break;

        case parse_QUESTIONMARK:
            tokenizer.pos++;

            range = {
                min: 0,
                max: 1
            };

            break;

        case parse_NUMBERSIGN:
            tokenizer.pos++;

            comma = true;

            if (tokenizer.charCode() === parse_LEFTCURLYBRACKET) {
                range = readMultiplierRange(tokenizer);
            } else if (tokenizer.charCode() === parse_QUESTIONMARK) {
                // https://www.w3.org/TR/css-values-4/#component-multipliers
                // > the # and ? multipliers may be stacked as #?
                // In this case just treat "#?" as a single multiplier
                // { min: 0, max: 0, comma: true }
                tokenizer.pos++;
                range = {
                    min: 0,
                    max: 0
                };
            } else {
                range = {
                    min: 1,
                    max: 0
                };
            }

            break;

        case parse_LEFTCURLYBRACKET:
            range = readMultiplierRange(tokenizer);
            break;

        default:
            return null;
    }

    return {
        type: 'Multiplier',
        comma,
        min: range.min,
        max: range.max,
        term: null
    };
}

function maybeMultiplied(tokenizer, node) {
    const multiplier = readMultiplier(tokenizer);

    if (multiplier !== null) {
        multiplier.term = node;

        // https://www.w3.org/TR/css-values-4/#component-multipliers
        // > The + and # multipliers may be stacked as +#;
        // Represent "+#" as nested multipliers:
        // { ...<multiplier #>,
        //   term: {
        //     ...<multipler +>,
        //     term: node
        //   }
        // }
        if (tokenizer.charCode() === parse_NUMBERSIGN &&
            tokenizer.charCodeAt(tokenizer.pos - 1) === parse_PLUSSIGN) {
            return maybeMultiplied(tokenizer, multiplier);
        }

        return multiplier;
    }

    return node;
}

function maybeToken(tokenizer) {
    const ch = tokenizer.peek();

    if (ch === '') {
        return null;
    }

    return {
        type: 'Token',
        value: ch
    };
}

function readProperty(tokenizer) {
    let name;

    tokenizer.eat(LESSTHANSIGN);
    tokenizer.eat(APOSTROPHE);

    name = scanWord(tokenizer);

    tokenizer.eat(APOSTROPHE);
    tokenizer.eat(GREATERTHANSIGN);

    return maybeMultiplied(tokenizer, {
        type: 'Property',
        name
    });
}

// https://drafts.csswg.org/css-values-3/#numeric-ranges
// 4.1. Range Restrictions and Range Definition Notation
//
// Range restrictions can be annotated in the numeric type notation using CSS bracketed
// range notation[min,max]within the angle brackets, after the identifying keyword,
// indicating a closed range between (and including) min and max.
// For example, <integer [0, 10]> indicates an integer between 0 and 10, inclusive.
function readTypeRange(tokenizer) {
    // use null for Infinity to make AST format JSON serializable/deserializable
    let min = null; // -Infinity
    let max = null; // Infinity
    let sign = 1;

    tokenizer.eat(LEFTSQUAREBRACKET);

    if (tokenizer.charCode() === HYPERMINUS) {
        tokenizer.peek();
        sign = -1;
    }

    if (sign == -1 && tokenizer.charCode() === INFINITY) {
        tokenizer.peek();
    } else {
        min = sign * Number(scanNumber(tokenizer));

        if (NAME_CHAR[tokenizer.charCode()] !== 0) {
            min += scanWord(tokenizer);
        }
    }

    scanSpaces(tokenizer);
    tokenizer.eat(COMMA);
    scanSpaces(tokenizer);

    if (tokenizer.charCode() === INFINITY) {
        tokenizer.peek();
    } else {
        sign = 1;

        if (tokenizer.charCode() === HYPERMINUS) {
            tokenizer.peek();
            sign = -1;
        }

        max = sign * Number(scanNumber(tokenizer));

        if (NAME_CHAR[tokenizer.charCode()] !== 0) {
            max += scanWord(tokenizer);
        }
    }

    tokenizer.eat(RIGHTSQUAREBRACKET);

    return {
        type: 'Range',
        min,
        max
    };
}

function readType(tokenizer) {
    let name;
    let opts = null;

    tokenizer.eat(LESSTHANSIGN);
    name = scanWord(tokenizer);

    if (tokenizer.charCode() === LEFTPARENTHESIS &&
        tokenizer.nextCharCode() === RIGHTPARENTHESIS) {
        tokenizer.pos += 2;
        name += '()';
    }

    if (tokenizer.charCodeAt(tokenizer.findWsEnd(tokenizer.pos)) === LEFTSQUAREBRACKET) {
        scanSpaces(tokenizer);
        opts = readTypeRange(tokenizer);
    }

    tokenizer.eat(GREATERTHANSIGN);

    return maybeMultiplied(tokenizer, {
        type: 'Type',
        name,
        opts
    });
}

function readKeywordOrFunction(tokenizer) {
    const name = scanWord(tokenizer);

    if (tokenizer.charCode() === LEFTPARENTHESIS) {
        tokenizer.pos++;

        return {
            type: 'Function',
            name
        };
    }

    return maybeMultiplied(tokenizer, {
        type: 'Keyword',
        name
    });
}

function regroupTerms(terms, combinators) {
    function createGroup(terms, combinator) {
        return {
            type: 'Group',
            terms,
            combinator,
            disallowEmpty: false,
            explicit: false
        };
    }

    let combinator;

    combinators = Object.keys(combinators)
        .sort((a, b) => COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b]);

    while (combinators.length > 0) {
        combinator = combinators.shift();

        let i = 0;
        let subgroupStart = 0;

        for (; i < terms.length; i++) {
            const term = terms[i];

            if (term.type === 'Combinator') {
                if (term.value === combinator) {
                    if (subgroupStart === -1) {
                        subgroupStart = i - 1;
                    }
                    terms.splice(i, 1);
                    i--;
                } else {
                    if (subgroupStart !== -1 && i - subgroupStart > 1) {
                        terms.splice(
                            subgroupStart,
                            i - subgroupStart,
                            createGroup(terms.slice(subgroupStart, i), combinator)
                        );
                        i = subgroupStart + 1;
                    }
                    subgroupStart = -1;
                }
            }
        }

        if (subgroupStart !== -1 && combinators.length) {
            terms.splice(
                subgroupStart,
                i - subgroupStart,
                createGroup(terms.slice(subgroupStart, i), combinator)
            );
        }
    }

    return combinator;
}

function readImplicitGroup(tokenizer) {
    const terms = [];
    const combinators = {};
    let token;
    let prevToken = null;
    let prevTokenPos = tokenizer.pos;

    while (token = peek(tokenizer)) {
        if (token.type !== 'Spaces') {
            if (token.type === 'Combinator') {
                // check for combinator in group beginning and double combinator sequence
                if (prevToken === null || prevToken.type === 'Combinator') {
                    tokenizer.pos = prevTokenPos;
                    tokenizer.error('Unexpected combinator');
                }

                combinators[token.value] = true;
            } else if (prevToken !== null && prevToken.type !== 'Combinator') {
                combinators[' '] = true;  // a b
                terms.push({
                    type: 'Combinator',
                    value: ' '
                });
            }

            terms.push(token);
            prevToken = token;
            prevTokenPos = tokenizer.pos;
        }
    }

    // check for combinator in group ending
    if (prevToken !== null && prevToken.type === 'Combinator') {
        tokenizer.pos -= prevTokenPos;
        tokenizer.error('Unexpected combinator');
    }

    return {
        type: 'Group',
        terms,
        combinator: regroupTerms(terms, combinators) || ' ',
        disallowEmpty: false,
        explicit: false
    };
}

function readGroup(tokenizer) {
    let result;

    tokenizer.eat(LEFTSQUAREBRACKET);
    result = readImplicitGroup(tokenizer);
    tokenizer.eat(RIGHTSQUAREBRACKET);

    result.explicit = true;

    if (tokenizer.charCode() === parse_EXCLAMATIONMARK) {
        tokenizer.pos++;
        result.disallowEmpty = true;
    }

    return result;
}

function peek(tokenizer) {
    let code = tokenizer.charCode();

    if (code < 128 && NAME_CHAR[code] === 1) {
        return readKeywordOrFunction(tokenizer);
    }

    switch (code) {
        case RIGHTSQUAREBRACKET:
            // don't eat, stop scan a group
            break;

        case LEFTSQUAREBRACKET:
            return maybeMultiplied(tokenizer, readGroup(tokenizer));

        case LESSTHANSIGN:
            return tokenizer.nextCharCode() === APOSTROPHE
                ? readProperty(tokenizer)
                : readType(tokenizer);

        case VERTICALLINE:
            return {
                type: 'Combinator',
                value: tokenizer.substringToPos(
                    tokenizer.pos + (tokenizer.nextCharCode() === VERTICALLINE ? 2 : 1)
                )
            };

        case AMPERSAND:
            tokenizer.pos++;
            tokenizer.eat(AMPERSAND);

            return {
                type: 'Combinator',
                value: '&&'
            };

        case COMMA:
            tokenizer.pos++;
            return {
                type: 'Comma'
            };

        case APOSTROPHE:
            return maybeMultiplied(tokenizer, {
                type: 'String',
                value: scanString(tokenizer)
            });

        case parse_SPACE:
        case parse_TAB:
        case parse_N:
        case parse_R:
        case parse_F:
            return {
                type: 'Spaces',
                value: scanSpaces(tokenizer)
            };

        case COMMERCIALAT:
            code = tokenizer.nextCharCode();

            if (code < 128 && NAME_CHAR[code] === 1) {
                tokenizer.pos++;
                return {
                    type: 'AtKeyword',
                    name: scanWord(tokenizer)
                };
            }

            return maybeToken(tokenizer);

        case ASTERISK:
        case parse_PLUSSIGN:
        case parse_QUESTIONMARK:
        case parse_NUMBERSIGN:
        case parse_EXCLAMATIONMARK:
            // prohibited tokens (used as a multiplier start)
            break;

        case parse_LEFTCURLYBRACKET:
            // LEFTCURLYBRACKET is allowed since mdn/data uses it w/o quoting
            // check next char isn't a number, because it's likely a disjoined multiplier
            code = tokenizer.nextCharCode();

            if (code < 48 || code > 57) {
                return maybeToken(tokenizer);
            }

            break;

        default:
            return maybeToken(tokenizer);
    }
}

function parse(source) {
    const tokenizer = new Tokenizer(source);
    const result = readImplicitGroup(tokenizer);

    if (tokenizer.pos !== source.length) {
        tokenizer.error('Unexpected input');
    }

    // reduce redundant groups with single group term
    if (result.terms.length === 1 && result.terms[0].type === 'Group') {
        return result.terms[0];
    }

    return result;
};

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/definition-syntax/walk.js
const walk_noop = function() {};

function walk_ensureFunction(value) {
    return typeof value === 'function' ? value : walk_noop;
}

function walk(node, options, context) {
    function walk(node) {
        enter.call(context, node);

        switch (node.type) {
            case 'Group':
                node.terms.forEach(walk);
                break;

            case 'Multiplier':
                walk(node.term);
                break;

            case 'Type':
            case 'Property':
            case 'Keyword':
            case 'AtKeyword':
            case 'Function':
            case 'String':
            case 'Token':
            case 'Comma':
                break;

            default:
                throw new Error('Unknown type: ' + node.type);
        }

        leave.call(context, node);
    }

    let enter = walk_noop;
    let leave = walk_noop;

    if (typeof options === 'function') {
        enter = options;
    } else if (options) {
        enter = walk_ensureFunction(options.enter);
        leave = walk_ensureFunction(options.leave);
    }

    if (enter === walk_noop && leave === walk_noop) {
        throw new Error('Neither `enter` nor `leave` walker handler is set or both aren\'t a function');
    }

    walk(node, context);
};

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/definition-syntax/index.js





;// CONCATENATED MODULE: ./node_modules/css-tree/lib/lexer/prepare-tokens.js


const astToTokens = {
    decorator(handlers) {
        const tokens = [];
        let curNode = null;

        return {
            ...handlers,
            node(node) {
                const tmp = curNode;
                curNode = node;
                handlers.node.call(this, node);
                curNode = tmp;
            },
            emit(value, type, auto) {
                tokens.push({
                    type,
                    value,
                    node: auto ? null : curNode
                });
            },
            result() {
                return tokens;
            }
        };
    }
};

function stringToTokens(str) {
    const tokens = [];

    tokenize(str, (type, start, end) =>
        tokens.push({
            type,
            value: str.slice(start, end),
            node: null
        })
    );

    return tokens;
}

/* harmony default export */ function prepare_tokens(value, syntax) {
    if (typeof value === 'string') {
        return stringToTokens(value);
    }

    return syntax.generate(value, astToTokens);
};

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/lexer/match-graph.js


const MATCH = { type: 'Match' };
const MISMATCH = { type: 'Mismatch' };
const DISALLOW_EMPTY = { type: 'DisallowEmpty' };

const match_graph_LEFTPARENTHESIS = 40;  // (
const match_graph_RIGHTPARENTHESIS = 41; // )

function createCondition(match, thenBranch, elseBranch) {
    // reduce node count
    if (thenBranch === MATCH && elseBranch === MISMATCH) {
        return match;
    }

    if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
        return match;
    }

    if (match.type === 'If' && match.else === MISMATCH && thenBranch === MATCH) {
        thenBranch = match.then;
        match = match.match;
    }

    return {
        type: 'If',
        match,
        then: thenBranch,
        else: elseBranch
    };
}

function isFunctionType(name) {
    return (
        name.length > 2 &&
        name.charCodeAt(name.length - 2) === match_graph_LEFTPARENTHESIS &&
        name.charCodeAt(name.length - 1) === match_graph_RIGHTPARENTHESIS
    );
}

function isEnumCapatible(term) {
    return (
        term.type === 'Keyword' ||
        term.type === 'AtKeyword' ||
        term.type === 'Function' ||
        term.type === 'Type' && isFunctionType(term.name)
    );
}

function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
    switch (combinator) {
        case ' ': {
            // Juxtaposing components means that all of them must occur, in the given order.
            //
            // a b c
            // =
            // match a
            //   then match b
            //     then match c
            //       then MATCH
            //       else MISMATCH
            //     else MISMATCH
            //   else MISMATCH
            let result = MATCH;

            for (let i = terms.length - 1; i >= 0; i--) {
                const term = terms[i];

                result = createCondition(
                    term,
                    result,
                    MISMATCH
                );
            };

            return result;
        }

        case '|': {
            // A bar (|) separates two or more alternatives: exactly one of them must occur.
            //
            // a | b | c
            // =
            // match a
            //   then MATCH
            //   else match b
            //     then MATCH
            //     else match c
            //       then MATCH
            //       else MISMATCH

            let result = MISMATCH;
            let map = null;

            for (let i = terms.length - 1; i >= 0; i--) {
                let term = terms[i];

                // reduce sequence of keywords into a Enum
                if (isEnumCapatible(term)) {
                    if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
                        map = Object.create(null);
                        result = createCondition(
                            {
                                type: 'Enum',
                                map
                            },
                            MATCH,
                            result
                        );
                    }

                    if (map !== null) {
                        const key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
                        if (key in map === false) {
                            map[key] = term;
                            continue;
                        }
                    }
                }

                map = null;

                // create a new conditonal node
                result = createCondition(
                    term,
                    MATCH,
                    result
                );
            };

            return result;
        }

        case '&&': {
            // A double ampersand (&&) separates two or more components,
            // all of which must occur, in any order.

            // Use MatchOnce for groups with a large number of terms,
            // since &&-groups produces at least N!-node trees
            if (terms.length > 5) {
                return {
                    type: 'MatchOnce',
                    terms,
                    all: true
                };
            }

            // Use a combination tree for groups with small number of terms
            //
            // a && b && c
            // =
            // match a
            //   then [b && c]
            //   else match b
            //     then [a && c]
            //     else match c
            //       then [a && b]
            //       else MISMATCH
            //
            // a && b
            // =
            // match a
            //   then match b
            //     then MATCH
            //     else MISMATCH
            //   else match b
            //     then match a
            //       then MATCH
            //       else MISMATCH
            //     else MISMATCH
            let result = MISMATCH;

            for (let i = terms.length - 1; i >= 0; i--) {
                const term = terms[i];
                let thenClause;

                if (terms.length > 1) {
                    thenClause = buildGroupMatchGraph(
                        combinator,
                        terms.filter(function(newGroupTerm) {
                            return newGroupTerm !== term;
                        }),
                        false
                    );
                } else {
                    thenClause = MATCH;
                }

                result = createCondition(
                    term,
                    thenClause,
                    result
                );
            };

            return result;
        }

        case '||': {
            // A double bar (||) separates two or more options:
            // one or more of them must occur, in any order.

            // Use MatchOnce for groups with a large number of terms,
            // since ||-groups produces at least N!-node trees
            if (terms.length > 5) {
                return {
                    type: 'MatchOnce',
                    terms,
                    all: false
                };
            }

            // Use a combination tree for groups with small number of terms
            //
            // a || b || c
            // =
            // match a
            //   then [b || c]
            //   else match b
            //     then [a || c]
            //     else match c
            //       then [a || b]
            //       else MISMATCH
            //
            // a || b
            // =
            // match a
            //   then match b
            //     then MATCH
            //     else MATCH
            //   else match b
            //     then match a
            //       then MATCH
            //       else MATCH
            //     else MISMATCH
            let result = atLeastOneTermMatched ? MATCH : MISMATCH;

            for (let i = terms.length - 1; i >= 0; i--) {
                const term = terms[i];
                let thenClause;

                if (terms.length > 1) {
                    thenClause = buildGroupMatchGraph(
                        combinator,
                        terms.filter(function(newGroupTerm) {
                            return newGroupTerm !== term;
                        }),
                        true
                    );
                } else {
                    thenClause = MATCH;
                }

                result = createCondition(
                    term,
                    thenClause,
                    result
                );
            };

            return result;
        }
    }
}

function buildMultiplierMatchGraph(node) {
    let result = MATCH;
    let matchTerm = buildMatchGraphInternal(node.term);

    if (node.max === 0) {
        // disable repeating of empty match to prevent infinite loop
        matchTerm = createCondition(
            matchTerm,
            DISALLOW_EMPTY,
            MISMATCH
        );

        // an occurrence count is not limited, make a cycle;
        // to collect more terms on each following matching mismatch
        result = createCondition(
            matchTerm,
            null, // will be a loop
            MISMATCH
        );

        result.then = createCondition(
            MATCH,
            MATCH,
            result // make a loop
        );

        if (node.comma) {
            result.then.else = createCondition(
                { type: 'Comma', syntax: node },
                result,
                MISMATCH
            );
        }
    } else {
        // create a match node chain for [min .. max] interval with optional matches
        for (let i = node.min || 1; i <= node.max; i++) {
            if (node.comma && result !== MATCH) {
                result = createCondition(
                    { type: 'Comma', syntax: node },
                    result,
                    MISMATCH
                );
            }

            result = createCondition(
                matchTerm,
                createCondition(
                    MATCH,
                    MATCH,
                    result
                ),
                MISMATCH
            );
        }
    }

    if (node.min === 0) {
        // allow zero match
        result = createCondition(
            MATCH,
            MATCH,
            result
        );
    } else {
        // create a match node chain to collect [0 ... min - 1] required matches
        for (let i = 0; i < node.min - 1; i++) {
            if (node.comma && result !== MATCH) {
                result = createCondition(
                    { type: 'Comma', syntax: node },
                    result,
                    MISMATCH
                );
            }

            result = createCondition(
                matchTerm,
                result,
                MISMATCH
            );
        }
    }

    return result;
}

function buildMatchGraphInternal(node) {
    if (typeof node === 'function') {
        return {
            type: 'Generic',
            fn: node
        };
    }

    switch (node.type) {
        case 'Group': {
            let result = buildGroupMatchGraph(
                node.combinator,
                node.terms.map(buildMatchGraphInternal),
                false
            );

            if (node.disallowEmpty) {
                result = createCondition(
                    result,
                    DISALLOW_EMPTY,
                    MISMATCH
                );
            }

            return result;
        }

        case 'Multiplier':
            return buildMultiplierMatchGraph(node);

        case 'Type':
        case 'Property':
            return {
                type: node.type,
                name: node.name,
                syntax: node
            };

        case 'Keyword':
            return {
                type: node.type,
                name: node.name.toLowerCase(),
                syntax: node
            };

        case 'AtKeyword':
            return {
                type: node.type,
                name: '@' + node.name.toLowerCase(),
                syntax: node
            };

        case 'Function':
            return {
                type: node.type,
                name: node.name.toLowerCase() + '(',
                syntax: node
            };

        case 'String':
            // convert a one char length String to a Token
            if (node.value.length === 3) {
                return {
                    type: 'Token',
                    value: node.value.charAt(1),
                    syntax: node
                };
            }

            // otherwise use it as is
            return {
                type: node.type,
                value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, '\''),
                syntax: node
            };

        case 'Token':
            return {
                type: node.type,
                value: node.value,
                syntax: node
            };

        case 'Comma':
            return {
                type: node.type,
                syntax: node
            };

        default:
            throw new Error('Unknown node type:', node.type);
    }
}

function buildMatchGraph(syntaxTree, ref) {
    if (typeof syntaxTree === 'string') {
        syntaxTree = parse(syntaxTree);
    }

    return {
        type: 'MatchGraph',
        match: buildMatchGraphInternal(syntaxTree),
        syntax: ref || null,
        source: syntaxTree
    };
}

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/lexer/match.js



const { hasOwnProperty: match_hasOwnProperty } = Object.prototype;
const STUB = 0;
const TOKEN = 1;
const OPEN_SYNTAX = 2;
const CLOSE_SYNTAX = 3;

const EXIT_REASON_MATCH = 'Match';
const EXIT_REASON_MISMATCH = 'Mismatch';
const EXIT_REASON_ITERATION_LIMIT = 'Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)';

const ITERATION_LIMIT = 15000;
let totalIterationCount = 0;

function reverseList(list) {
    let prev = null;
    let next = null;
    let item = list;

    while (item !== null) {
        next = item.prev;
        item.prev = prev;
        prev = item;
        item = next;
    }

    return prev;
}

function areStringsEqualCaseInsensitive(testStr, referenceStr) {
    if (testStr.length !== referenceStr.length) {
        return false;
    }

    for (let i = 0; i < testStr.length; i++) {
        const referenceCode = referenceStr.charCodeAt(i);
        let testCode = testStr.charCodeAt(i);

        // testCode.toLowerCase() for U+0041 LATIN CAPITAL LETTER A (A) .. U+005A LATIN CAPITAL LETTER Z (Z).
        if (testCode >= 0x0041 && testCode <= 0x005A) {
            testCode = testCode | 32;
        }

        if (testCode !== referenceCode) {
            return false;
        }
    }

    return true;
}

function isContextEdgeDelim(token) {
    if (token.type !== Delim) {
        return false;
    }

    // Fix matching for unicode-range: U+30??, U+FF00-FF9F
    // Probably we need to check out previous match instead
    return token.value !== '?';
}

function isCommaContextStart(token) {
    if (token === null) {
        return true;
    }

    return (
        token.type === Comma ||
        token.type === types_Function ||
        token.type === LeftParenthesis ||
        token.type === LeftSquareBracket ||
        token.type === LeftCurlyBracket ||
        isContextEdgeDelim(token)
    );
}

function isCommaContextEnd(token) {
    if (token === null) {
        return true;
    }

    return (
        token.type === RightParenthesis ||
        token.type === RightSquareBracket ||
        token.type === RightCurlyBracket ||
        (token.type === Delim && token.value === '/')
    );
}

function internalMatch(tokens, state, syntaxes) {
    function moveToNextToken() {
        do {
            tokenIndex++;
            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
        } while (token !== null && (token.type === WhiteSpace || token.type === Comment));
    }

    function getNextToken(offset) {
        const nextIndex = tokenIndex + offset;

        return nextIndex < tokens.length ? tokens[nextIndex] : null;
    }

    function stateSnapshotFromSyntax(nextState, prev) {
        return {
            nextState,
            matchStack,
            syntaxStack,
            thenStack,
            tokenIndex,
            prev
        };
    }

    function pushThenStack(nextState) {
        thenStack = {
            nextState,
            matchStack,
            syntaxStack,
            prev: thenStack
        };
    }

    function pushElseStack(nextState) {
        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
    }

    function addTokenToMatch() {
        matchStack = {
            type: TOKEN,
            syntax: state.syntax,
            token,
            prev: matchStack
        };

        moveToNextToken();
        syntaxStash = null;

        if (tokenIndex > longestMatch) {
            longestMatch = tokenIndex;
        }
    }

    function openSyntax() {
        syntaxStack = {
            syntax: state.syntax,
            opts: state.syntax.opts || (syntaxStack !== null && syntaxStack.opts) || null,
            prev: syntaxStack
        };

        matchStack = {
            type: OPEN_SYNTAX,
            syntax: state.syntax,
            token: matchStack.token,
            prev: matchStack
        };
    }

    function closeSyntax() {
        if (matchStack.type === OPEN_SYNTAX) {
            matchStack = matchStack.prev;
        } else {
            matchStack = {
                type: CLOSE_SYNTAX,
                syntax: syntaxStack.syntax,
                token: matchStack.token,
                prev: matchStack
            };
        }

        syntaxStack = syntaxStack.prev;
    }

    let syntaxStack = null;
    let thenStack = null;
    let elseStack = null;

    // null  stashing allowed, nothing stashed
    // false  stashing disabled, nothing stashed
    // anithing else  fail stashable syntaxes, some syntax stashed
    let syntaxStash = null;

    let iterationCount = 0; // count iterations and prevent infinite loop
    let exitReason = null;

    let token = null;
    let tokenIndex = -1;
    let longestMatch = 0;
    let matchStack = {
        type: STUB,
        syntax: null,
        token: null,
        prev: null
    };

    moveToNextToken();

    while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
        // function mapList(list, fn) {
        //     const result = [];
        //     while (list) {
        //         result.unshift(fn(list));
        //         list = list.prev;
        //     }
        //     return result;
        // }
        // console.log('--\n',
        //     '#' + iterationCount,
        //     require('util').inspect({
        //         match: mapList(matchStack, x => x.type === TOKEN ? x.token && x.token.value : x.syntax ? ({ [OPEN_SYNTAX]: '<', [CLOSE_SYNTAX]: '</' }[x.type] || x.type) + '!' + x.syntax.name : null),
        //         token: token && token.value,
        //         tokenIndex,
        //         syntax: syntax.type + (syntax.id ? ' #' + syntax.id : '')
        //     }, { depth: null })
        // );
        switch (state.type) {
            case 'Match':
                if (thenStack === null) {
                    // turn to MISMATCH when some tokens left unmatched
                    if (token !== null) {
                        // doesn't mismatch if just one token left and it's an IE hack
                        if (tokenIndex !== tokens.length - 1 || (token.value !== '\\0' && token.value !== '\\9')) {
                            state = MISMATCH;
                            break;
                        }
                    }

                    // break the main loop, return a result - MATCH
                    exitReason = EXIT_REASON_MATCH;
                    break;
                }

                // go to next syntax (`then` branch)
                state = thenStack.nextState;

                // check match is not empty
                if (state === DISALLOW_EMPTY) {
                    if (thenStack.matchStack === matchStack) {
                        state = MISMATCH;
                        break;
                    } else {
                        state = MATCH;
                    }
                }

                // close syntax if needed
                while (thenStack.syntaxStack !== syntaxStack) {
                    closeSyntax();
                }

                // pop stack
                thenStack = thenStack.prev;
                break;

            case 'Mismatch':
                // when some syntax is stashed
                if (syntaxStash !== null && syntaxStash !== false) {
                    // there is no else branches or a branch reduce match stack
                    if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
                        // restore state from the stash
                        elseStack = syntaxStash;
                        syntaxStash = false; // disable stashing
                    }
                } else if (elseStack === null) {
                    // no else branches -> break the main loop
                    // return a result - MISMATCH
                    exitReason = EXIT_REASON_MISMATCH;
                    break;
                }

                // go to next syntax (`else` branch)
                state = elseStack.nextState;

                // restore all the rest stack states
                thenStack = elseStack.thenStack;
                syntaxStack = elseStack.syntaxStack;
                matchStack = elseStack.matchStack;
                tokenIndex = elseStack.tokenIndex;
                token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;

                // pop stack
                elseStack = elseStack.prev;
                break;

            case 'MatchGraph':
                state = state.match;
                break;

            case 'If':
                // IMPORTANT: else stack push must go first,
                // since it stores the state of thenStack before changes
                if (state.else !== MISMATCH) {
                    pushElseStack(state.else);
                }

                if (state.then !== MATCH) {
                    pushThenStack(state.then);
                }

                state = state.match;
                break;

            case 'MatchOnce':
                state = {
                    type: 'MatchOnceBuffer',
                    syntax: state,
                    index: 0,
                    mask: 0
                };
                break;

            case 'MatchOnceBuffer': {
                const terms = state.syntax.terms;

                if (state.index === terms.length) {
                    // no matches at all or it's required all terms to be matched
                    if (state.mask === 0 || state.syntax.all) {
                        state = MISMATCH;
                        break;
                    }

                    // a partial match is ok
                    state = MATCH;
                    break;
                }

                // all terms are matched
                if (state.mask === (1 << terms.length) - 1) {
                    state = MATCH;
                    break;
                }

                for (; state.index < terms.length; state.index++) {
                    const matchFlag = 1 << state.index;

                    if ((state.mask & matchFlag) === 0) {
                        // IMPORTANT: else stack push must go first,
                        // since it stores the state of thenStack before changes
                        pushElseStack(state);
                        pushThenStack({
                            type: 'AddMatchOnce',
                            syntax: state.syntax,
                            mask: state.mask | matchFlag
                        });

                        // match
                        state = terms[state.index++];
                        break;
                    }
                }
                break;
            }

            case 'AddMatchOnce':
                state = {
                    type: 'MatchOnceBuffer',
                    syntax: state.syntax,
                    index: 0,
                    mask: state.mask
                };
                break;

            case 'Enum':
                if (token !== null) {
                    let name = token.value.toLowerCase();

                    // drop \0 and \9 hack from keyword name
                    if (name.indexOf('\\') !== -1) {
                        name = name.replace(/\\[09].*$/, '');
                    }

                    if (match_hasOwnProperty.call(state.map, name)) {
                        state = state.map[name];
                        break;
                    }
                }

                state = MISMATCH;
                break;

            case 'Generic': {
                const opts = syntaxStack !== null ? syntaxStack.opts : null;
                const lastTokenIndex = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));

                if (!isNaN(lastTokenIndex) && lastTokenIndex > tokenIndex) {
                    while (tokenIndex < lastTokenIndex) {
                        addTokenToMatch();
                    }

                    state = MATCH;
                } else {
                    state = MISMATCH;
                }

                break;
            }

            case 'Type':
            case 'Property': {
                const syntaxDict = state.type === 'Type' ? 'types' : 'properties';
                const dictSyntax = match_hasOwnProperty.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;

                if (!dictSyntax || !dictSyntax.match) {
                    throw new Error(
                        'Bad syntax reference: ' +
                        (state.type === 'Type'
                            ? '<' + state.name + '>'
                            : '<\'' + state.name + '\'>')
                    );
                }

                // stash a syntax for types with low priority
                if (syntaxStash !== false && token !== null && state.type === 'Type') {
                    const lowPriorityMatching =
                        // https://drafts.csswg.org/css-values-4/#custom-idents
                        // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
                        // can only claim the keyword if no other unfulfilled production can claim it.
                        (state.name === 'custom-ident' && token.type === Ident) ||

                        // https://drafts.csswg.org/css-values-4/#lengths
                        // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
                        // it must parse as a <number>
                        (state.name === 'length' && token.value === '0');

                    if (lowPriorityMatching) {
                        if (syntaxStash === null) {
                            syntaxStash = stateSnapshotFromSyntax(state, elseStack);
                        }

                        state = MISMATCH;
                        break;
                    }
                }

                openSyntax();
                state = dictSyntax.match;
                break;
            }

            case 'Keyword': {
                const name = state.name;

                if (token !== null) {
                    let keywordName = token.value;

                    // drop \0 and \9 hack from keyword name
                    if (keywordName.indexOf('\\') !== -1) {
                        keywordName = keywordName.replace(/\\[09].*$/, '');
                    }

                    if (areStringsEqualCaseInsensitive(keywordName, name)) {
                        addTokenToMatch();
                        state = MATCH;
                        break;
                    }
                }

                state = MISMATCH;
                break;
            }

            case 'AtKeyword':
            case 'Function':
                if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
                    addTokenToMatch();
                    state = MATCH;
                    break;
                }

                state = MISMATCH;
                break;

            case 'Token':
                if (token !== null && token.value === state.value) {
                    addTokenToMatch();
                    state = MATCH;
                    break;
                }

                state = MISMATCH;
                break;

            case 'Comma':
                if (token !== null && token.type === Comma) {
                    if (isCommaContextStart(matchStack.token)) {
                        state = MISMATCH;
                    } else {
                        addTokenToMatch();
                        state = isCommaContextEnd(token) ? MISMATCH : MATCH;
                    }
                } else {
                    state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? MATCH : MISMATCH;
                }

                break;

            case 'String':
                let string = '';
                let lastTokenIndex = tokenIndex;

                for (; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
                    string += tokens[lastTokenIndex].value;
                }

                if (areStringsEqualCaseInsensitive(string, state.value)) {
                    while (tokenIndex < lastTokenIndex) {
                        addTokenToMatch();
                    }

                    state = MATCH;
                } else {
                    state = MISMATCH;
                }

                break;

            default:
                throw new Error('Unknown node type: ' + state.type);
        }
    }

    totalIterationCount += iterationCount;

    switch (exitReason) {
        case null:
            console.warn('[csstree-match] BREAK after ' + ITERATION_LIMIT + ' iterations');
            exitReason = EXIT_REASON_ITERATION_LIMIT;
            matchStack = null;
            break;

        case EXIT_REASON_MATCH:
            while (syntaxStack !== null) {
                closeSyntax();
            }
            break;

        default:
            matchStack = null;
    }

    return {
        tokens,
        reason: exitReason,
        iterations: iterationCount,
        match: matchStack,
        longestMatch
    };
}

function matchAsList(tokens, matchGraph, syntaxes) {
    const matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

    if (matchResult.match !== null) {
        let item = reverseList(matchResult.match).prev;

        matchResult.match = [];

        while (item !== null) {
            switch (item.type) {
                case OPEN_SYNTAX:
                case CLOSE_SYNTAX:
                    matchResult.match.push({
                        type: item.type,
                        syntax: item.syntax
                    });
                    break;

                default:
                    matchResult.match.push({
                        token: item.token.value,
                        node: item.token.node
                    });
                    break;
            }

            item = item.prev;
        }
    }

    return matchResult;
}

function matchAsTree(tokens, matchGraph, syntaxes) {
    const matchResult = internalMatch(tokens, matchGraph, syntaxes || {});

    if (matchResult.match === null) {
        return matchResult;
    }

    let item = matchResult.match;
    let host = matchResult.match = {
        syntax: matchGraph.syntax || null,
        match: []
    };
    const hostStack = [host];

    // revert a list and start with 2nd item since 1st is a stub item
    item = reverseList(item).prev;

    // build a tree
    while (item !== null) {
        switch (item.type) {
            case OPEN_SYNTAX:
                host.match.push(host = {
                    syntax: item.syntax,
                    match: []
                });
                hostStack.push(host);
                break;

            case CLOSE_SYNTAX:
                hostStack.pop();
                host = hostStack[hostStack.length - 1];
                break;

            default:
                host.match.push({
                    syntax: item.syntax || null,
                    token: item.token.value,
                    node: item.token.node
                });
        }

        item = item.prev;
    }

    return matchResult;
}

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/lexer/trace.js
function getTrace(node) {
    function shouldPutToTrace(syntax) {
        if (syntax === null) {
            return false;
        }

        return (
            syntax.type === 'Type' ||
            syntax.type === 'Property' ||
            syntax.type === 'Keyword'
        );
    }

    function hasMatch(matchNode) {
        if (Array.isArray(matchNode.match)) {
            // use for-loop for better perfomance
            for (let i = 0; i < matchNode.match.length; i++) {
                if (hasMatch(matchNode.match[i])) {
                    if (shouldPutToTrace(matchNode.syntax)) {
                        result.unshift(matchNode.syntax);
                    }

                    return true;
                }
            }
        } else if (matchNode.node === node) {
            result = shouldPutToTrace(matchNode.syntax)
                ? [matchNode.syntax]
                : [];

            return true;
        }

        return false;
    }

    let result = null;

    if (this.matched !== null) {
        hasMatch(this.matched);
    }

    return result;
}

function isType(node, type) {
    return testNode(this, node, match => match.type === 'Type' && match.name === type);
}

function isProperty(node, property) {
    return testNode(this, node, match => match.type === 'Property' && match.name === property);
}

function isKeyword(node) {
    return testNode(this, node, match => match.type === 'Keyword');
}

function testNode(match, node, fn) {
    const trace = getTrace.call(match, node);

    if (trace === null) {
        return false;
    }

    return trace.some(fn);
}

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/lexer/search.js


function getFirstMatchNode(matchNode) {
    if ('node' in matchNode) {
        return matchNode.node;
    }

    return getFirstMatchNode(matchNode.match[0]);
}

function getLastMatchNode(matchNode) {
    if ('node' in matchNode) {
        return matchNode.node;
    }

    return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
}

function matchFragments(lexer, ast, match, type, name) {
    function findFragments(matchNode) {
        if (matchNode.syntax !== null &&
            matchNode.syntax.type === type &&
            matchNode.syntax.name === name) {
            const start = getFirstMatchNode(matchNode);
            const end = getLastMatchNode(matchNode);

            lexer.syntax.walk(ast, function(node, item, list) {
                if (node === start) {
                    const nodes = new List();

                    do {
                        nodes.appendData(item.data);

                        if (item.data === end) {
                            break;
                        }

                        item = item.next;
                    } while (item !== null);

                    fragments.push({
                        parent: list,
                        nodes
                    });
                }
            });
        }

        if (Array.isArray(matchNode.match)) {
            matchNode.match.forEach(findFragments);
        }
    }

    const fragments = [];

    if (match.matched !== null) {
        findFragments(match.matched);
    }

    return fragments;
}

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/lexer/structure.js


const { hasOwnProperty: structure_hasOwnProperty } = Object.prototype;

function isValidNumber(value) {
    // Number.isInteger(value) && value >= 0
    return (
        typeof value === 'number' &&
        isFinite(value) &&
        Math.floor(value) === value &&
        value >= 0
    );
}

function isValidLocation(loc) {
    return (
        Boolean(loc) &&
        isValidNumber(loc.offset) &&
        isValidNumber(loc.line) &&
        isValidNumber(loc.column)
    );
}

function createNodeStructureChecker(type, fields) {
    return function checkNode(node, warn) {
        if (!node || node.constructor !== Object) {
            return warn(node, 'Type of node should be an Object');
        }

        for (let key in node) {
            let valid = true;

            if (structure_hasOwnProperty.call(node, key) === false) {
                continue;
            }

            if (key === 'type') {
                if (node.type !== type) {
                    warn(node, 'Wrong node type `' + node.type + '`, expected `' + type + '`');
                }
            } else if (key === 'loc') {
                if (node.loc === null) {
                    continue;
                } else if (node.loc && node.loc.constructor === Object) {
                    if (typeof node.loc.source !== 'string') {
                        key += '.source';
                    } else if (!isValidLocation(node.loc.start)) {
                        key += '.start';
                    } else if (!isValidLocation(node.loc.end)) {
                        key += '.end';
                    } else {
                        continue;
                    }
                }

                valid = false;
            } else if (fields.hasOwnProperty(key)) {
                valid = false;

                for (let i = 0; !valid && i < fields[key].length; i++) {
                    const fieldType = fields[key][i];

                    switch (fieldType) {
                        case String:
                            valid = typeof node[key] === 'string';
                            break;

                        case Boolean:
                            valid = typeof node[key] === 'boolean';
                            break;

                        case null:
                            valid = node[key] === null;
                            break;

                        default:
                            if (typeof fieldType === 'string') {
                                valid = node[key] && node[key].type === fieldType;
                            } else if (Array.isArray(fieldType)) {
                                valid = node[key] instanceof List;
                            }
                    }
                }
            } else {
                warn(node, 'Unknown field `' + key + '` for ' + type + ' node type');
            }

            if (!valid) {
                warn(node, 'Bad value for `' + type + '.' + key + '`');
            }
        }

        for (const key in fields) {
            if (structure_hasOwnProperty.call(fields, key) &&
                structure_hasOwnProperty.call(node, key) === false) {
                warn(node, 'Field `' + type + '.' + key + '` is missed');
            }
        }
    };
}

function processStructure(name, nodeType) {
    const structure = nodeType.structure;
    const fields = {
        type: String,
        loc: true
    };
    const docs = {
        type: '"' + name + '"'
    };

    for (const key in structure) {
        if (structure_hasOwnProperty.call(structure, key) === false) {
            continue;
        }

        const docsTypes = [];
        const fieldTypes = fields[key] = Array.isArray(structure[key])
            ? structure[key].slice()
            : [structure[key]];

        for (let i = 0; i < fieldTypes.length; i++) {
            const fieldType = fieldTypes[i];
            if (fieldType === String || fieldType === Boolean) {
                docsTypes.push(fieldType.name);
            } else if (fieldType === null) {
                docsTypes.push('null');
            } else if (typeof fieldType === 'string') {
                docsTypes.push('<' + fieldType + '>');
            } else if (Array.isArray(fieldType)) {
                docsTypes.push('List'); // TODO: use type enum
            } else {
                throw new Error('Wrong value `' + fieldType + '` in `' + name + '.' + key + '` structure definition');
            }
        }

        docs[key] = docsTypes.join(' | ');
    }

    return {
        docs,
        check: createNodeStructureChecker(name, fields)
    };
}

function getStructureFromConfig(config) {
    const structure = {};

    if (config.node) {
        for (const name in config.node) {
            if (structure_hasOwnProperty.call(config.node, name)) {
                const nodeType = config.node[name];

                if (nodeType.structure) {
                    structure[name] = processStructure(name, nodeType);
                } else {
                    throw new Error('Missed `structure` field in `' + name + '` node type definition');
                }
            }
        }
    }

    return structure;
};

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/lexer/Lexer.js












const cssWideKeywordsSyntax = buildMatchGraph(cssWideKeywords.join(' | '));

function dumpMapSyntax(map, compact, syntaxAsAst) {
    const result = {};

    for (const name in map) {
        if (map[name].syntax) {
            result[name] = syntaxAsAst
                ? map[name].syntax
                : generate(map[name].syntax, { compact });
        }
    }

    return result;
}

function dumpAtruleMapSyntax(map, compact, syntaxAsAst) {
    const result = {};

    for (const [name, atrule] of Object.entries(map)) {
        result[name] = {
            prelude: atrule.prelude && (
                syntaxAsAst
                    ? atrule.prelude.syntax
                    : generate(atrule.prelude.syntax, { compact })
            ),
            descriptors: atrule.descriptors && dumpMapSyntax(atrule.descriptors, compact, syntaxAsAst)
        };
    }

    return result;
}

function valueHasVar(tokens) {
    for (let i = 0; i < tokens.length; i++) {
        if (tokens[i].value.toLowerCase() === 'var(') {
            return true;
        }
    }

    return false;
}

function buildMatchResult(matched, error, iterations) {
    return {
        matched,
        iterations,
        error,
        ...trace_namespaceObject
    };
}

function matchSyntax(lexer, syntax, value, useCssWideKeywords) {
    const tokens = prepare_tokens(value, lexer.syntax);
    let result;

    if (valueHasVar(tokens)) {
        return buildMatchResult(null, new Error('Matching for a tree with var() is not supported'));
    }

    if (useCssWideKeywords) {
        result = matchAsTree(tokens, lexer.cssWideKeywordsSyntax, lexer);
    }

    if (!useCssWideKeywords || !result.match) {
        result = matchAsTree(tokens, syntax.match, lexer);
        if (!result.match) {
            return buildMatchResult(
                null,
                new SyntaxMatchError(result.reason, syntax.syntax, value, result),
                result.iterations
            );
        }
    }

    return buildMatchResult(result.match, null, result.iterations);
}

class Lexer {
    constructor(config, syntax, structure) {
        this.cssWideKeywordsSyntax = cssWideKeywordsSyntax;
        this.syntax = syntax;
        this.generic = false;
        this.atrules = Object.create(null);
        this.properties = Object.create(null);
        this.types = Object.create(null);
        this.structure = structure || getStructureFromConfig(config);

        if (config) {
            if (config.types) {
                for (const name in config.types) {
                    this.addType_(name, config.types[name]);
                }
            }

            if (config.generic) {
                this.generic = true;
                for (const name in generic) {
                    this.addType_(name, generic[name]);
                }
            }

            if (config.atrules) {
                for (const name in config.atrules) {
                    this.addAtrule_(name, config.atrules[name]);
                }
            }

            if (config.properties) {
                for (const name in config.properties) {
                    this.addProperty_(name, config.properties[name]);
                }
            }
        }
    }

    checkStructure(ast) {
        function collectWarning(node, message) {
            warns.push({ node, message });
        }

        const structure = this.structure;
        const warns = [];

        this.syntax.walk(ast, function(node) {
            if (structure.hasOwnProperty(node.type)) {
                structure[node.type].check(node, collectWarning);
            } else {
                collectWarning(node, 'Unknown node type `' + node.type + '`');
            }
        });

        return warns.length ? warns : false;
    }

    createDescriptor(syntax, type, name, parent = null) {
        const ref = {
            type,
            name
        };
        const descriptor = {
            type,
            name,
            parent,
            serializable: typeof syntax === 'string' || (syntax && typeof syntax.type === 'string'),
            syntax: null,
            match: null
        };

        if (typeof syntax === 'function') {
            descriptor.match = buildMatchGraph(syntax, ref);
        } else {
            if (typeof syntax === 'string') {
                // lazy parsing on first access
                Object.defineProperty(descriptor, 'syntax', {
                    get() {
                        Object.defineProperty(descriptor, 'syntax', {
                            value: parse(syntax)
                        });

                        return descriptor.syntax;
                    }
                });
            } else {
                descriptor.syntax = syntax;
            }

            // lazy graph build on first access
            Object.defineProperty(descriptor, 'match', {
                get() {
                    Object.defineProperty(descriptor, 'match', {
                        value: buildMatchGraph(descriptor.syntax, ref)
                    });

                    return descriptor.match;
                }
            });
        }

        return descriptor;
    }
    addAtrule_(name, syntax) {
        if (!syntax) {
            return;
        }

        this.atrules[name] = {
            type: 'Atrule',
            name: name,
            prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, 'AtrulePrelude', name) : null,
            descriptors: syntax.descriptors
                ? Object.keys(syntax.descriptors).reduce(
                    (map, descName) => {
                        map[descName] = this.createDescriptor(syntax.descriptors[descName], 'AtruleDescriptor', descName, name);
                        return map;
                    },
                    Object.create(null)
                )
                : null
        };
    }
    addProperty_(name, syntax) {
        if (!syntax) {
            return;
        }

        this.properties[name] = this.createDescriptor(syntax, 'Property', name);
    }
    addType_(name, syntax) {
        if (!syntax) {
            return;
        }

        this.types[name] = this.createDescriptor(syntax, 'Type', name);
    }

    checkAtruleName(atruleName) {
        if (!this.getAtrule(atruleName)) {
            return new SyntaxReferenceError('Unknown at-rule', '@' + atruleName);
        }
    }
    checkAtrulePrelude(atruleName, prelude) {
        const error = this.checkAtruleName(atruleName);

        if (error) {
            return error;
        }

        const atrule = this.getAtrule(atruleName);

        if (!atrule.prelude && prelude) {
            return new SyntaxError('At-rule `@' + atruleName + '` should not contain a prelude');
        }

        if (atrule.prelude && !prelude) {
            if (!matchSyntax(this, atrule.prelude, '', false).matched) {
                return new SyntaxError('At-rule `@' + atruleName + '` should contain a prelude');
            }
        }
    }
    checkAtruleDescriptorName(atruleName, descriptorName) {
        const error = this.checkAtruleName(atruleName);

        if (error) {
            return error;
        }

        const atrule = this.getAtrule(atruleName);
        const descriptor = keyword(descriptorName);

        if (!atrule.descriptors) {
            return new SyntaxError('At-rule `@' + atruleName + '` has no known descriptors');
        }

        if (!atrule.descriptors[descriptor.name] &&
            !atrule.descriptors[descriptor.basename]) {
            return new SyntaxReferenceError('Unknown at-rule descriptor', descriptorName);
        }
    }
    checkPropertyName(propertyName) {
        if (!this.getProperty(propertyName)) {
            return new SyntaxReferenceError('Unknown property', propertyName);
        }
    }

    matchAtrulePrelude(atruleName, prelude) {
        const error = this.checkAtrulePrelude(atruleName, prelude);

        if (error) {
            return buildMatchResult(null, error);
        }

        const atrule = this.getAtrule(atruleName);

        if (!atrule.prelude) {
            return buildMatchResult(null, null);
        }

        return matchSyntax(this, atrule.prelude, prelude || '', false);
    }
    matchAtruleDescriptor(atruleName, descriptorName, value) {
        const error = this.checkAtruleDescriptorName(atruleName, descriptorName);

        if (error) {
            return buildMatchResult(null, error);
        }

        const atrule = this.getAtrule(atruleName);
        const descriptor = keyword(descriptorName);

        return matchSyntax(this, atrule.descriptors[descriptor.name] || atrule.descriptors[descriptor.basename], value, false);
    }
    matchDeclaration(node) {
        if (node.type !== 'Declaration') {
            return buildMatchResult(null, new Error('Not a Declaration node'));
        }

        return this.matchProperty(node.property, node.value);
    }
    matchProperty(propertyName, value) {
        // don't match syntax for a custom property at the moment
        if (names_property(propertyName).custom) {
            return buildMatchResult(null, new Error('Lexer matching doesn\'t applicable for custom properties'));
        }

        const error = this.checkPropertyName(propertyName);

        if (error) {
            return buildMatchResult(null, error);
        }

        return matchSyntax(this, this.getProperty(propertyName), value, true);
    }
    matchType(typeName, value) {
        const typeSyntax = this.getType(typeName);

        if (!typeSyntax) {
            return buildMatchResult(null, new SyntaxReferenceError('Unknown type', typeName));
        }

        return matchSyntax(this, typeSyntax, value, false);
    }
    match(syntax, value) {
        if (typeof syntax !== 'string' && (!syntax || !syntax.type)) {
            return buildMatchResult(null, new SyntaxReferenceError('Bad syntax'));
        }

        if (typeof syntax === 'string' || !syntax.match) {
            syntax = this.createDescriptor(syntax, 'Type', 'anonymous');
        }

        return matchSyntax(this, syntax, value, false);
    }

    findValueFragments(propertyName, value, type, name) {
        return matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
    }
    findDeclarationValueFragments(declaration, type, name) {
        return matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
    }
    findAllFragments(ast, type, name) {
        const result = [];

        this.syntax.walk(ast, {
            visit: 'Declaration',
            enter: (declaration) => {
                result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
            }
        });

        return result;
    }

    getAtrule(atruleName, fallbackBasename = true) {
        const atrule = keyword(atruleName);
        const atruleEntry = atrule.vendor && fallbackBasename
            ? this.atrules[atrule.name] || this.atrules[atrule.basename]
            : this.atrules[atrule.name];

        return atruleEntry || null;
    }
    getAtrulePrelude(atruleName, fallbackBasename = true) {
        const atrule = this.getAtrule(atruleName, fallbackBasename);

        return atrule && atrule.prelude || null;
    }
    getAtruleDescriptor(atruleName, name) {
        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators
            ? this.atrules[atruleName].declarators[name] || null
            : null;
    }
    getProperty(propertyName, fallbackBasename = true) {
        const property = names_property(propertyName);
        const propertyEntry = property.vendor && fallbackBasename
            ? this.properties[property.name] || this.properties[property.basename]
            : this.properties[property.name];

        return propertyEntry || null;
    }
    getType(name) {
        return hasOwnProperty.call(this.types, name) ? this.types[name] : null;
    }

    validate() {
        function validate(syntax, name, broken, descriptor) {
            if (broken.has(name)) {
                return broken.get(name);
            }

            broken.set(name, false);
            if (descriptor.syntax !== null) {
                walk(descriptor.syntax, function(node) {
                    if (node.type !== 'Type' && node.type !== 'Property') {
                        return;
                    }

                    const map = node.type === 'Type' ? syntax.types : syntax.properties;
                    const brokenMap = node.type === 'Type' ? brokenTypes : brokenProperties;

                    if (!hasOwnProperty.call(map, node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
                        broken.set(name, true);
                    }
                }, this);
            }
        }

        let brokenTypes = new Map();
        let brokenProperties = new Map();

        for (const key in this.types) {
            validate(this, key, brokenTypes, this.types[key]);
        }

        for (const key in this.properties) {
            validate(this, key, brokenProperties, this.properties[key]);
        }

        brokenTypes = [...brokenTypes.keys()].filter(name => brokenTypes.get(name));
        brokenProperties = [...brokenProperties.keys()].filter(name => brokenProperties.get(name));

        if (brokenTypes.length || brokenProperties.length) {
            return {
                types: brokenTypes,
                properties: brokenProperties
            };
        }

        return null;
    }
    dump(syntaxAsAst, pretty) {
        return {
            generic: this.generic,
            types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
            properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst),
            atrules: dumpAtruleMapSyntax(this.atrules, !pretty, syntaxAsAst)
        };
    }
    toString() {
        return JSON.stringify(this.dump());
    }
};

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/config/mix.js
const { hasOwnProperty: mix_hasOwnProperty } = Object.prototype;
const shape = {
    generic: true,
    types: appendOrAssign,
    atrules: {
        prelude: appendOrAssignOrNull,
        descriptors: appendOrAssignOrNull
    },
    properties: appendOrAssign,
    parseContext: mix_assign,
    scope: deepAssign,
    atrule: ['parse'],
    pseudo: ['parse'],
    node: ['name', 'structure', 'parse', 'generate', 'walkContext']
};

function mix_isObject(value) {
    return value && value.constructor === Object;
}

function mix_copy(value) {
    return mix_isObject(value)
        ? { ...value }
        : value;
}

function mix_assign(dest, src) {
    return Object.assign(dest, src);
}

function deepAssign(dest, src) {
    for (const key in src) {
        if (mix_hasOwnProperty.call(src, key)) {
            if (mix_isObject(dest[key])) {
                deepAssign(dest[key], src[key]);
            } else {
                dest[key] = mix_copy(src[key]);
            }
        }
    }

    return dest;
}

function append(a, b) {
    if (typeof b === 'string' && /^\s*\|/.test(b)) {
        return typeof a === 'string'
            ? a + b
            : b.replace(/^\s*\|\s*/, '');
    }

    return b || null;
}

function appendOrAssign(a, b) {
    if (typeof b === 'string') {
        return append(a, b);
    }

    const result = { ...a };
    for (let key in b) {
        if (mix_hasOwnProperty.call(b, key)) {
            result[key] = append(mix_hasOwnProperty.call(a, key) ? a[key] : undefined, b[key]);
        }
    }

    return result;
}

function appendOrAssignOrNull(a, b) {
    const result = appendOrAssign(a, b);

    return !mix_isObject(result) || Object.keys(result).length
        ? result
        : null;
}

function mix(dest, src, shape) {
    for (const key in shape) {
        if (mix_hasOwnProperty.call(shape, key) === false) {
            continue;
        }

        if (shape[key] === true) {
            if (mix_hasOwnProperty.call(src, key)) {
                dest[key] = mix_copy(src[key]);
            }
        } else if (shape[key]) {
            if (typeof shape[key] === 'function') {
                const fn = shape[key];
                dest[key] = fn({}, dest[key]);
                dest[key] = fn(dest[key] || {}, src[key]);
            } else if (mix_isObject(shape[key])) {
                const result = {};

                for (let name in dest[key]) {
                    result[name] = mix({}, dest[key][name], shape[key]);
                }

                for (let name in src[key]) {
                    result[name] = mix(result[name] || {}, src[key][name], shape[key]);
                }

                dest[key] = result;
            } else if (Array.isArray(shape[key])) {
                const res = {};
                const innerShape = shape[key].reduce(function(s, k) {
                    s[k] = true;
                    return s;
                }, {});

                for (const [name, value] of Object.entries(dest[key] || {})) {
                    res[name] = {};
                    if (value) {
                        mix(res[name], value, innerShape);
                    }
                }

                for (const name in src[key]) {
                    if (mix_hasOwnProperty.call(src[key], name)) {
                        if (!res[name]) {
                            res[name] = {};
                        }

                        if (src[key] && src[key][name]) {
                            mix(res[name], src[key][name], innerShape);
                        }
                    }
                }

                dest[key] = res;
            }
        }
    }
    return dest;
}

/* harmony default export */ const config_mix = ((dest, src) => mix(dest, src, shape));

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/create.js








function createSyntax(config) {
    const parse = createParser(config);
    const walk = createWalker(config);
    const generate = createGenerator(config);
    const { fromPlainObject, toPlainObject } = createConvertor(walk);

    const syntax = {
        lexer: null,
        createLexer: config => new Lexer(config, syntax, syntax.lexer.structure),

        tokenize: tokenize,
        parse,
        generate,

        walk,
        find: walk.find,
        findLast: walk.findLast,
        findAll: walk.findAll,

        fromPlainObject,
        toPlainObject,

        fork(extension) {
            const base = config_mix({}, config); // copy of config

            return createSyntax(
                typeof extension === 'function'
                    ? extension(base, Object.assign)
                    : config_mix(base, extension)
            );
        }
    };

    syntax.lexer = new Lexer({
        generic: true,
        types: config.types,
        atrules: config.atrules,
        properties: config.properties,
        node: config.node
    }, syntax);

    return syntax;
};

/* harmony default export */ const create = (config => createSyntax(config_mix({}, config)));

;// CONCATENATED MODULE: ./node_modules/css-tree/dist/data.js
/* harmony default export */ const data = ({
    "generic": true,
    "types": {
        "absolute-size": "xx-small|x-small|small|medium|large|x-large|xx-large|xxx-large",
        "alpha-value": "<number>|<percentage>",
        "angle-percentage": "<angle>|<percentage>",
        "angular-color-hint": "<angle-percentage>",
        "angular-color-stop": "<color>&&<color-stop-angle>?",
        "angular-color-stop-list": "[<angular-color-stop> [, <angular-color-hint>]?]# , <angular-color-stop>",
        "animateable-feature": "scroll-position|contents|<custom-ident>",
        "attachment": "scroll|fixed|local",
        "attr()": "attr( <attr-name> <type-or-unit>? [, <attr-fallback>]? )",
        "attr-matcher": "['~'|'|'|'^'|'$'|'*']? '='",
        "attr-modifier": "i|s",
        "attribute-selector": "'[' <wq-name> ']'|'[' <wq-name> <attr-matcher> [<string-token>|<ident-token>] <attr-modifier>? ']'",
        "auto-repeat": "repeat( [auto-fill|auto-fit] , [<line-names>? <fixed-size>]+ <line-names>? )",
        "auto-track-list": "[<line-names>? [<fixed-size>|<fixed-repeat>]]* <line-names>? <auto-repeat> [<line-names>? [<fixed-size>|<fixed-repeat>]]* <line-names>?",
        "baseline-position": "[first|last]? baseline",
        "basic-shape": "<inset()>|<circle()>|<ellipse()>|<polygon()>|<path()>",
        "bg-image": "none|<image>",
        "bg-layer": "<bg-image>||<bg-position> [/ <bg-size>]?||<repeat-style>||<attachment>||<box>||<box>",
        "bg-position": "[[left|center|right|top|bottom|<length-percentage>]|[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]|[center|[left|right] <length-percentage>?]&&[center|[top|bottom] <length-percentage>?]]",
        "bg-size": "[<length-percentage>|auto]{1,2}|cover|contain",
        "blur()": "blur( <length> )",
        "blend-mode": "normal|multiply|screen|overlay|darken|lighten|color-dodge|color-burn|hard-light|soft-light|difference|exclusion|hue|saturation|color|luminosity",
        "box": "border-box|padding-box|content-box",
        "brightness()": "brightness( <number-percentage> )",
        "calc()": "calc( <calc-sum> )",
        "calc-sum": "<calc-product> [['+'|'-'] <calc-product>]*",
        "calc-product": "<calc-value> ['*' <calc-value>|'/' <number>]*",
        "calc-value": "<number>|<dimension>|<percentage>|( <calc-sum> )",
        "cf-final-image": "<image>|<color>",
        "cf-mixing-image": "<percentage>?&&<image>",
        "circle()": "circle( [<shape-radius>]? [at <position>]? )",
        "clamp()": "clamp( <calc-sum>#{3} )",
        "class-selector": "'.' <ident-token>",
        "clip-source": "<url>",
        "color": "<rgb()>|<rgba()>|<hsl()>|<hsla()>|<hwb()>|<lab()>|<lch()>|<hex-color>|<named-color>|currentcolor|<deprecated-system-color>",
        "color-stop": "<color-stop-length>|<color-stop-angle>",
        "color-stop-angle": "<angle-percentage>{1,2}",
        "color-stop-length": "<length-percentage>{1,2}",
        "color-stop-list": "[<linear-color-stop> [, <linear-color-hint>]?]# , <linear-color-stop>",
        "combinator": "'>'|'+'|'~'|['||']",
        "common-lig-values": "[common-ligatures|no-common-ligatures]",
        "compat-auto": "searchfield|textarea|push-button|slider-horizontal|checkbox|radio|square-button|menulist|listbox|meter|progress-bar|button",
        "composite-style": "clear|copy|source-over|source-in|source-out|source-atop|destination-over|destination-in|destination-out|destination-atop|xor",
        "compositing-operator": "add|subtract|intersect|exclude",
        "compound-selector": "[<type-selector>? <subclass-selector>* [<pseudo-element-selector> <pseudo-class-selector>*]*]!",
        "compound-selector-list": "<compound-selector>#",
        "complex-selector": "<compound-selector> [<combinator>? <compound-selector>]*",
        "complex-selector-list": "<complex-selector>#",
        "conic-gradient()": "conic-gradient( [from <angle>]? [at <position>]? , <angular-color-stop-list> )",
        "contextual-alt-values": "[contextual|no-contextual]",
        "content-distribution": "space-between|space-around|space-evenly|stretch",
        "content-list": "[<string>|contents|<image>|<counter>|<quote>|<target>|<leader()>|<attr()>]+",
        "content-position": "center|start|end|flex-start|flex-end",
        "content-replacement": "<image>",
        "contrast()": "contrast( [<number-percentage>] )",
        "counter": "<counter()>|<counters()>",
        "counter()": "counter( <counter-name> , <counter-style>? )",
        "counter-name": "<custom-ident>",
        "counter-style": "<counter-style-name>|symbols( )",
        "counter-style-name": "<custom-ident>",
        "counters()": "counters( <counter-name> , <string> , <counter-style>? )",
        "cross-fade()": "cross-fade( <cf-mixing-image> , <cf-final-image>? )",
        "cubic-bezier-timing-function": "ease|ease-in|ease-out|ease-in-out|cubic-bezier( <number [0,1]> , <number> , <number [0,1]> , <number> )",
        "deprecated-system-color": "ActiveBorder|ActiveCaption|AppWorkspace|Background|ButtonFace|ButtonHighlight|ButtonShadow|ButtonText|CaptionText|GrayText|Highlight|HighlightText|InactiveBorder|InactiveCaption|InactiveCaptionText|InfoBackground|InfoText|Menu|MenuText|Scrollbar|ThreeDDarkShadow|ThreeDFace|ThreeDHighlight|ThreeDLightShadow|ThreeDShadow|Window|WindowFrame|WindowText",
        "discretionary-lig-values": "[discretionary-ligatures|no-discretionary-ligatures]",
        "display-box": "contents|none",
        "display-inside": "flow|flow-root|table|flex|grid|ruby",
        "display-internal": "table-row-group|table-header-group|table-footer-group|table-row|table-cell|table-column-group|table-column|table-caption|ruby-base|ruby-text|ruby-base-container|ruby-text-container",
        "display-legacy": "inline-block|inline-list-item|inline-table|inline-flex|inline-grid",
        "display-listitem": "<display-outside>?&&[flow|flow-root]?&&list-item",
        "display-outside": "block|inline|run-in",
        "drop-shadow()": "drop-shadow( <length>{2,3} <color>? )",
        "east-asian-variant-values": "[jis78|jis83|jis90|jis04|simplified|traditional]",
        "east-asian-width-values": "[full-width|proportional-width]",
        "element()": "element( <custom-ident> , [first|start|last|first-except]? )|element( <id-selector> )",
        "ellipse()": "ellipse( [<shape-radius>{2}]? [at <position>]? )",
        "ending-shape": "circle|ellipse",
        "env()": "env( <custom-ident> , <declaration-value>? )",
        "explicit-track-list": "[<line-names>? <track-size>]+ <line-names>?",
        "family-name": "<string>|<custom-ident>+",
        "feature-tag-value": "<string> [<integer>|on|off]?",
        "feature-type": "@stylistic|@historical-forms|@styleset|@character-variant|@swash|@ornaments|@annotation",
        "feature-value-block": "<feature-type> '{' <feature-value-declaration-list> '}'",
        "feature-value-block-list": "<feature-value-block>+",
        "feature-value-declaration": "<custom-ident> : <integer>+ ;",
        "feature-value-declaration-list": "<feature-value-declaration>",
        "feature-value-name": "<custom-ident>",
        "fill-rule": "nonzero|evenodd",
        "filter-function": "<blur()>|<brightness()>|<contrast()>|<drop-shadow()>|<grayscale()>|<hue-rotate()>|<invert()>|<opacity()>|<saturate()>|<sepia()>",
        "filter-function-list": "[<filter-function>|<url>]+",
        "final-bg-layer": "<'background-color'>||<bg-image>||<bg-position> [/ <bg-size>]?||<repeat-style>||<attachment>||<box>||<box>",
        "fit-content()": "fit-content( [<length>|<percentage>] )",
        "fixed-breadth": "<length-percentage>",
        "fixed-repeat": "repeat( [<integer [1,]>] , [<line-names>? <fixed-size>]+ <line-names>? )",
        "fixed-size": "<fixed-breadth>|minmax( <fixed-breadth> , <track-breadth> )|minmax( <inflexible-breadth> , <fixed-breadth> )",
        "font-stretch-absolute": "normal|ultra-condensed|extra-condensed|condensed|semi-condensed|semi-expanded|expanded|extra-expanded|ultra-expanded|<percentage>",
        "font-variant-css21": "[normal|small-caps]",
        "font-weight-absolute": "normal|bold|<number [1,1000]>",
        "frequency-percentage": "<frequency>|<percentage>",
        "general-enclosed": "[<function-token> <any-value> )]|( <ident> <any-value> )",
        "generic-family": "serif|sans-serif|cursive|fantasy|monospace|-apple-system",
        "generic-name": "serif|sans-serif|cursive|fantasy|monospace",
        "geometry-box": "<shape-box>|fill-box|stroke-box|view-box",
        "gradient": "<linear-gradient()>|<repeating-linear-gradient()>|<radial-gradient()>|<repeating-radial-gradient()>|<conic-gradient()>|<repeating-conic-gradient()>|<-legacy-gradient>",
        "grayscale()": "grayscale( <number-percentage> )",
        "grid-line": "auto|<custom-ident>|[<integer>&&<custom-ident>?]|[span&&[<integer>||<custom-ident>]]",
        "historical-lig-values": "[historical-ligatures|no-historical-ligatures]",
        "hsl()": "hsl( <hue> <percentage> <percentage> [/ <alpha-value>]? )|hsl( <hue> , <percentage> , <percentage> , <alpha-value>? )",
        "hsla()": "hsla( <hue> <percentage> <percentage> [/ <alpha-value>]? )|hsla( <hue> , <percentage> , <percentage> , <alpha-value>? )",
        "hue": "<number>|<angle>",
        "hue-rotate()": "hue-rotate( <angle> )",
        "hwb()": "hwb( [<hue>|none] [<percentage>|none] [<percentage>|none] [/ [<alpha-value>|none]]? )",
        "image": "<url>|<image()>|<image-set()>|<element()>|<paint()>|<cross-fade()>|<gradient>",
        "image()": "image( <image-tags>? [<image-src>? , <color>?]! )",
        "image-set()": "image-set( <image-set-option># )",
        "image-set-option": "[<image>|<string>] [<resolution>||type( <string> )]",
        "image-src": "<url>|<string>",
        "image-tags": "ltr|rtl",
        "inflexible-breadth": "<length>|<percentage>|min-content|max-content|auto",
        "inset()": "inset( <length-percentage>{1,4} [round <'border-radius'>]? )",
        "invert()": "invert( <number-percentage> )",
        "keyframes-name": "<custom-ident>|<string>",
        "keyframe-block": "<keyframe-selector># { <declaration-list> }",
        "keyframe-block-list": "<keyframe-block>+",
        "keyframe-selector": "from|to|<percentage>",
        "layer()": "layer( <layer-name> )",
        "layer-name": "<ident> ['.' <ident>]*",
        "leader()": "leader( <leader-type> )",
        "leader-type": "dotted|solid|space|<string>",
        "length-percentage": "<length>|<percentage>",
        "line-names": "'[' <custom-ident>* ']'",
        "line-name-list": "[<line-names>|<name-repeat>]+",
        "line-style": "none|hidden|dotted|dashed|solid|double|groove|ridge|inset|outset",
        "line-width": "<length>|thin|medium|thick",
        "linear-color-hint": "<length-percentage>",
        "linear-color-stop": "<color> <color-stop-length>?",
        "linear-gradient()": "linear-gradient( [<angle>|to <side-or-corner>]? , <color-stop-list> )",
        "mask-layer": "<mask-reference>||<position> [/ <bg-size>]?||<repeat-style>||<geometry-box>||[<geometry-box>|no-clip]||<compositing-operator>||<masking-mode>",
        "mask-position": "[<length-percentage>|left|center|right] [<length-percentage>|top|center|bottom]?",
        "mask-reference": "none|<image>|<mask-source>",
        "mask-source": "<url>",
        "masking-mode": "alpha|luminance|match-source",
        "matrix()": "matrix( <number>#{6} )",
        "matrix3d()": "matrix3d( <number>#{16} )",
        "max()": "max( <calc-sum># )",
        "media-and": "<media-in-parens> [and <media-in-parens>]+",
        "media-condition": "<media-not>|<media-and>|<media-or>|<media-in-parens>",
        "media-condition-without-or": "<media-not>|<media-and>|<media-in-parens>",
        "media-feature": "( [<mf-plain>|<mf-boolean>|<mf-range>] )",
        "media-in-parens": "( <media-condition> )|<media-feature>|<general-enclosed>",
        "media-not": "not <media-in-parens>",
        "media-or": "<media-in-parens> [or <media-in-parens>]+",
        "media-query": "<media-condition>|[not|only]? <media-type> [and <media-condition-without-or>]?",
        "media-query-list": "<media-query>#",
        "media-type": "<ident>",
        "mf-boolean": "<mf-name>",
        "mf-name": "<ident>",
        "mf-plain": "<mf-name> : <mf-value>",
        "mf-range": "<mf-name> ['<'|'>']? '='? <mf-value>|<mf-value> ['<'|'>']? '='? <mf-name>|<mf-value> '<' '='? <mf-name> '<' '='? <mf-value>|<mf-value> '>' '='? <mf-name> '>' '='? <mf-value>",
        "mf-value": "<number>|<dimension>|<ident>|<ratio>",
        "min()": "min( <calc-sum># )",
        "minmax()": "minmax( [<length>|<percentage>|min-content|max-content|auto] , [<length>|<percentage>|<flex>|min-content|max-content|auto] )",
        "name-repeat": "repeat( [<integer [1,]>|auto-fill] , <line-names>+ )",
        "named-color": "transparent|aliceblue|antiquewhite|aqua|aquamarine|azure|beige|bisque|black|blanchedalmond|blue|blueviolet|brown|burlywood|cadetblue|chartreuse|chocolate|coral|cornflowerblue|cornsilk|crimson|cyan|darkblue|darkcyan|darkgoldenrod|darkgray|darkgreen|darkgrey|darkkhaki|darkmagenta|darkolivegreen|darkorange|darkorchid|darkred|darksalmon|darkseagreen|darkslateblue|darkslategray|darkslategrey|darkturquoise|darkviolet|deeppink|deepskyblue|dimgray|dimgrey|dodgerblue|firebrick|floralwhite|forestgreen|fuchsia|gainsboro|ghostwhite|gold|goldenrod|gray|green|greenyellow|grey|honeydew|hotpink|indianred|indigo|ivory|khaki|lavender|lavenderblush|lawngreen|lemonchiffon|lightblue|lightcoral|lightcyan|lightgoldenrodyellow|lightgray|lightgreen|lightgrey|lightpink|lightsalmon|lightseagreen|lightskyblue|lightslategray|lightslategrey|lightsteelblue|lightyellow|lime|limegreen|linen|magenta|maroon|mediumaquamarine|mediumblue|mediumorchid|mediumpurple|mediumseagreen|mediumslateblue|mediumspringgreen|mediumturquoise|mediumvioletred|midnightblue|mintcream|mistyrose|moccasin|navajowhite|navy|oldlace|olive|olivedrab|orange|orangered|orchid|palegoldenrod|palegreen|paleturquoise|palevioletred|papayawhip|peachpuff|peru|pink|plum|powderblue|purple|rebeccapurple|red|rosybrown|royalblue|saddlebrown|salmon|sandybrown|seagreen|seashell|sienna|silver|skyblue|slateblue|slategray|slategrey|snow|springgreen|steelblue|tan|teal|thistle|tomato|turquoise|violet|wheat|white|whitesmoke|yellow|yellowgreen|<-non-standard-color>",
        "namespace-prefix": "<ident>",
        "ns-prefix": "[<ident-token>|'*']? '|'",
        "number-percentage": "<number>|<percentage>",
        "numeric-figure-values": "[lining-nums|oldstyle-nums]",
        "numeric-fraction-values": "[diagonal-fractions|stacked-fractions]",
        "numeric-spacing-values": "[proportional-nums|tabular-nums]",
        "nth": "<an-plus-b>|even|odd",
        "opacity()": "opacity( [<number-percentage>] )",
        "overflow-position": "unsafe|safe",
        "outline-radius": "<length>|<percentage>",
        "page-body": "<declaration>? [; <page-body>]?|<page-margin-box> <page-body>",
        "page-margin-box": "<page-margin-box-type> '{' <declaration-list> '}'",
        "page-margin-box-type": "@top-left-corner|@top-left|@top-center|@top-right|@top-right-corner|@bottom-left-corner|@bottom-left|@bottom-center|@bottom-right|@bottom-right-corner|@left-top|@left-middle|@left-bottom|@right-top|@right-middle|@right-bottom",
        "page-selector-list": "[<page-selector>#]?",
        "page-selector": "<pseudo-page>+|<ident> <pseudo-page>*",
        "page-size": "A5|A4|A3|B5|B4|JIS-B5|JIS-B4|letter|legal|ledger",
        "path()": "path( [<fill-rule> ,]? <string> )",
        "paint()": "paint( <ident> , <declaration-value>? )",
        "perspective()": "perspective( <length> )",
        "polygon()": "polygon( <fill-rule>? , [<length-percentage> <length-percentage>]# )",
        "position": "[[left|center|right]||[top|center|bottom]|[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]?|[[left|right] <length-percentage>]&&[[top|bottom] <length-percentage>]]",
        "pseudo-class-selector": "':' <ident-token>|':' <function-token> <any-value> ')'",
        "pseudo-element-selector": "':' <pseudo-class-selector>",
        "pseudo-page": ": [left|right|first|blank]",
        "quote": "open-quote|close-quote|no-open-quote|no-close-quote",
        "radial-gradient()": "radial-gradient( [<ending-shape>||<size>]? [at <position>]? , <color-stop-list> )",
        "relative-selector": "<combinator>? <complex-selector>",
        "relative-selector-list": "<relative-selector>#",
        "relative-size": "larger|smaller",
        "repeat-style": "repeat-x|repeat-y|[repeat|space|round|no-repeat]{1,2}",
        "repeating-conic-gradient()": "repeating-conic-gradient( [from <angle>]? [at <position>]? , <angular-color-stop-list> )",
        "repeating-linear-gradient()": "repeating-linear-gradient( [<angle>|to <side-or-corner>]? , <color-stop-list> )",
        "repeating-radial-gradient()": "repeating-radial-gradient( [<ending-shape>||<size>]? [at <position>]? , <color-stop-list> )",
        "rgb()": "rgb( <percentage>{3} [/ <alpha-value>]? )|rgb( <number>{3} [/ <alpha-value>]? )|rgb( <percentage>#{3} , <alpha-value>? )|rgb( <number>#{3} , <alpha-value>? )",
        "rgba()": "rgba( <percentage>{3} [/ <alpha-value>]? )|rgba( <number>{3} [/ <alpha-value>]? )|rgba( <percentage>#{3} , <alpha-value>? )|rgba( <number>#{3} , <alpha-value>? )",
        "rotate()": "rotate( [<angle>|<zero>] )",
        "rotate3d()": "rotate3d( <number> , <number> , <number> , [<angle>|<zero>] )",
        "rotateX()": "rotateX( [<angle>|<zero>] )",
        "rotateY()": "rotateY( [<angle>|<zero>] )",
        "rotateZ()": "rotateZ( [<angle>|<zero>] )",
        "saturate()": "saturate( <number-percentage> )",
        "scale()": "scale( <number> , <number>? )",
        "scale3d()": "scale3d( <number> , <number> , <number> )",
        "scaleX()": "scaleX( <number> )",
        "scaleY()": "scaleY( <number> )",
        "scaleZ()": "scaleZ( <number> )",
        "self-position": "center|start|end|self-start|self-end|flex-start|flex-end",
        "shape-radius": "<length-percentage>|closest-side|farthest-side",
        "skew()": "skew( [<angle>|<zero>] , [<angle>|<zero>]? )",
        "skewX()": "skewX( [<angle>|<zero>] )",
        "skewY()": "skewY( [<angle>|<zero>] )",
        "sepia()": "sepia( <number-percentage> )",
        "shadow": "inset?&&<length>{2,4}&&<color>?",
        "shadow-t": "[<length>{2,3}&&<color>?]",
        "shape": "rect( <top> , <right> , <bottom> , <left> )|rect( <top> <right> <bottom> <left> )",
        "shape-box": "<box>|margin-box",
        "side-or-corner": "[left|right]||[top|bottom]",
        "single-animation": "<time>||<easing-function>||<time>||<single-animation-iteration-count>||<single-animation-direction>||<single-animation-fill-mode>||<single-animation-play-state>||[none|<keyframes-name>]",
        "single-animation-direction": "normal|reverse|alternate|alternate-reverse",
        "single-animation-fill-mode": "none|forwards|backwards|both",
        "single-animation-iteration-count": "infinite|<number>",
        "single-animation-play-state": "running|paused",
        "single-animation-timeline": "auto|none|<timeline-name>",
        "single-transition": "[none|<single-transition-property>]||<time>||<easing-function>||<time>",
        "single-transition-property": "all|<custom-ident>",
        "size": "closest-side|farthest-side|closest-corner|farthest-corner|<length>|<length-percentage>{2}",
        "step-position": "jump-start|jump-end|jump-none|jump-both|start|end",
        "step-timing-function": "step-start|step-end|steps( <integer> [, <step-position>]? )",
        "subclass-selector": "<id-selector>|<class-selector>|<attribute-selector>|<pseudo-class-selector>",
        "supports-condition": "not <supports-in-parens>|<supports-in-parens> [and <supports-in-parens>]*|<supports-in-parens> [or <supports-in-parens>]*",
        "supports-in-parens": "( <supports-condition> )|<supports-feature>|<general-enclosed>",
        "supports-feature": "<supports-decl>|<supports-selector-fn>",
        "supports-decl": "( <declaration> )",
        "supports-selector-fn": "selector( <complex-selector> )",
        "symbol": "<string>|<image>|<custom-ident>",
        "target": "<target-counter()>|<target-counters()>|<target-text()>",
        "target-counter()": "target-counter( [<string>|<url>] , <custom-ident> , <counter-style>? )",
        "target-counters()": "target-counters( [<string>|<url>] , <custom-ident> , <string> , <counter-style>? )",
        "target-text()": "target-text( [<string>|<url>] , [content|before|after|first-letter]? )",
        "time-percentage": "<time>|<percentage>",
        "timeline-name": "<custom-ident>|<string>",
        "easing-function": "linear|<cubic-bezier-timing-function>|<step-timing-function>",
        "track-breadth": "<length-percentage>|<flex>|min-content|max-content|auto",
        "track-list": "[<line-names>? [<track-size>|<track-repeat>]]+ <line-names>?",
        "track-repeat": "repeat( [<integer [1,]>] , [<line-names>? <track-size>]+ <line-names>? )",
        "track-size": "<track-breadth>|minmax( <inflexible-breadth> , <track-breadth> )|fit-content( [<length>|<percentage>] )",
        "transform-function": "<matrix()>|<translate()>|<translateX()>|<translateY()>|<scale()>|<scaleX()>|<scaleY()>|<rotate()>|<skew()>|<skewX()>|<skewY()>|<matrix3d()>|<translate3d()>|<translateZ()>|<scale3d()>|<scaleZ()>|<rotate3d()>|<rotateX()>|<rotateY()>|<rotateZ()>|<perspective()>",
        "transform-list": "<transform-function>+",
        "translate()": "translate( <length-percentage> , <length-percentage>? )",
        "translate3d()": "translate3d( <length-percentage> , <length-percentage> , <length> )",
        "translateX()": "translateX( <length-percentage> )",
        "translateY()": "translateY( <length-percentage> )",
        "translateZ()": "translateZ( <length> )",
        "type-or-unit": "string|color|url|integer|number|length|angle|time|frequency|cap|ch|em|ex|ic|lh|rlh|rem|vb|vi|vw|vh|vmin|vmax|mm|Q|cm|in|pt|pc|px|deg|grad|rad|turn|ms|s|Hz|kHz|%",
        "type-selector": "<wq-name>|<ns-prefix>? '*'",
        "var()": "var( <custom-property-name> , <declaration-value>? )",
        "viewport-length": "auto|<length-percentage>",
        "visual-box": "content-box|padding-box|border-box",
        "wq-name": "<ns-prefix>? <ident-token>",
        "-legacy-gradient": "<-webkit-gradient()>|<-legacy-linear-gradient>|<-legacy-repeating-linear-gradient>|<-legacy-radial-gradient>|<-legacy-repeating-radial-gradient>",
        "-legacy-linear-gradient": "-moz-linear-gradient( <-legacy-linear-gradient-arguments> )|-webkit-linear-gradient( <-legacy-linear-gradient-arguments> )|-o-linear-gradient( <-legacy-linear-gradient-arguments> )",
        "-legacy-repeating-linear-gradient": "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )|-webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )|-o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )",
        "-legacy-linear-gradient-arguments": "[<angle>|<side-or-corner>]? , <color-stop-list>",
        "-legacy-radial-gradient": "-moz-radial-gradient( <-legacy-radial-gradient-arguments> )|-webkit-radial-gradient( <-legacy-radial-gradient-arguments> )|-o-radial-gradient( <-legacy-radial-gradient-arguments> )",
        "-legacy-repeating-radial-gradient": "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )|-webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )|-o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )",
        "-legacy-radial-gradient-arguments": "[<position> ,]? [[[<-legacy-radial-gradient-shape>||<-legacy-radial-gradient-size>]|[<length>|<percentage>]{2}] ,]? <color-stop-list>",
        "-legacy-radial-gradient-size": "closest-side|closest-corner|farthest-side|farthest-corner|contain|cover",
        "-legacy-radial-gradient-shape": "circle|ellipse",
        "-non-standard-font": "-apple-system-body|-apple-system-headline|-apple-system-subheadline|-apple-system-caption1|-apple-system-caption2|-apple-system-footnote|-apple-system-short-body|-apple-system-short-headline|-apple-system-short-subheadline|-apple-system-short-caption1|-apple-system-short-footnote|-apple-system-tall-body",
        "-non-standard-color": "-moz-ButtonDefault|-moz-ButtonHoverFace|-moz-ButtonHoverText|-moz-CellHighlight|-moz-CellHighlightText|-moz-Combobox|-moz-ComboboxText|-moz-Dialog|-moz-DialogText|-moz-dragtargetzone|-moz-EvenTreeRow|-moz-Field|-moz-FieldText|-moz-html-CellHighlight|-moz-html-CellHighlightText|-moz-mac-accentdarkestshadow|-moz-mac-accentdarkshadow|-moz-mac-accentface|-moz-mac-accentlightesthighlight|-moz-mac-accentlightshadow|-moz-mac-accentregularhighlight|-moz-mac-accentregularshadow|-moz-mac-chrome-active|-moz-mac-chrome-inactive|-moz-mac-focusring|-moz-mac-menuselect|-moz-mac-menushadow|-moz-mac-menutextselect|-moz-MenuHover|-moz-MenuHoverText|-moz-MenuBarText|-moz-MenuBarHoverText|-moz-nativehyperlinktext|-moz-OddTreeRow|-moz-win-communicationstext|-moz-win-mediatext|-moz-activehyperlinktext|-moz-default-background-color|-moz-default-color|-moz-hyperlinktext|-moz-visitedhyperlinktext|-webkit-activelink|-webkit-focus-ring-color|-webkit-link|-webkit-text",
        "-non-standard-image-rendering": "optimize-contrast|-moz-crisp-edges|-o-crisp-edges|-webkit-optimize-contrast",
        "-non-standard-overflow": "-moz-scrollbars-none|-moz-scrollbars-horizontal|-moz-scrollbars-vertical|-moz-hidden-unscrollable",
        "-non-standard-width": "fill-available|min-intrinsic|intrinsic|-moz-available|-moz-fit-content|-moz-min-content|-moz-max-content|-webkit-min-content|-webkit-max-content",
        "-webkit-gradient()": "-webkit-gradient( <-webkit-gradient-type> , <-webkit-gradient-point> [, <-webkit-gradient-point>|, <-webkit-gradient-radius> , <-webkit-gradient-point>] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )",
        "-webkit-gradient-color-stop": "from( <color> )|color-stop( [<number-zero-one>|<percentage>] , <color> )|to( <color> )",
        "-webkit-gradient-point": "[left|center|right|<length-percentage>] [top|center|bottom|<length-percentage>]",
        "-webkit-gradient-radius": "<length>|<percentage>",
        "-webkit-gradient-type": "linear|radial",
        "-webkit-mask-box-repeat": "repeat|stretch|round",
        "-webkit-mask-clip-style": "border|border-box|padding|padding-box|content|content-box|text",
        "-ms-filter-function-list": "<-ms-filter-function>+",
        "-ms-filter-function": "<-ms-filter-function-progid>|<-ms-filter-function-legacy>",
        "-ms-filter-function-progid": "'progid:' [<ident-token> '.']* [<ident-token>|<function-token> <any-value>? )]",
        "-ms-filter-function-legacy": "<ident-token>|<function-token> <any-value>? )",
        "-ms-filter": "<string>",
        "age": "child|young|old",
        "attr-name": "<wq-name>",
        "attr-fallback": "<any-value>",
        "bg-clip": "<box>|border|text",
        "border-radius": "<length-percentage>{1,2}",
        "bottom": "<length>|auto",
        "generic-voice": "[<age>? <gender> <integer>?]",
        "gender": "male|female|neutral",
        "lab()": "lab( [<percentage>|<number>|none] [<percentage>|<number>|none] [<percentage>|<number>|none] [/ [<alpha-value>|none]]? )",
        "lch()": "lch( [<percentage>|<number>|none] [<percentage>|<number>|none] [<hue>|none] [/ [<alpha-value>|none]]? )",
        "left": "<length>|auto",
        "mask-image": "<mask-reference>#",
        "paint": "none|<color>|<url> [none|<color>]?|context-fill|context-stroke",
        "ratio": "<number [0,]> [/ <number [0,]>]?",
        "reversed-counter-name": "reversed( <counter-name> )",
        "right": "<length>|auto",
        "svg-length": "<percentage>|<length>|<number>",
        "svg-writing-mode": "lr-tb|rl-tb|tb-rl|lr|rl|tb",
        "top": "<length>|auto",
        "track-group": "'(' [<string>* <track-minmax> <string>*]+ ')' ['[' <positive-integer> ']']?|<track-minmax>",
        "track-list-v0": "[<string>* <track-group> <string>*]+|none",
        "track-minmax": "minmax( <track-breadth> , <track-breadth> )|auto|<track-breadth>|fit-content",
        "x": "<number>",
        "y": "<number>",
        "declaration": "<ident-token> : <declaration-value>? ['!' important]?",
        "declaration-list": "[<declaration>? ';']* <declaration>?",
        "url": "url( <string> <url-modifier>* )|<url-token>",
        "url-modifier": "<ident>|<function-token> <any-value> )",
        "number-zero-one": "<number [0,1]>",
        "number-one-or-greater": "<number [1,]>",
        "positive-integer": "<integer [0,]>",
        "-non-standard-display": "-ms-inline-flexbox|-ms-grid|-ms-inline-grid|-webkit-flex|-webkit-inline-flex|-webkit-box|-webkit-inline-box|-moz-inline-stack|-moz-box|-moz-inline-box"
    },
    "properties": {
        "--*": "<declaration-value>",
        "-ms-accelerator": "false|true",
        "-ms-block-progression": "tb|rl|bt|lr",
        "-ms-content-zoom-chaining": "none|chained",
        "-ms-content-zooming": "none|zoom",
        "-ms-content-zoom-limit": "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
        "-ms-content-zoom-limit-max": "<percentage>",
        "-ms-content-zoom-limit-min": "<percentage>",
        "-ms-content-zoom-snap": "<'-ms-content-zoom-snap-type'>||<'-ms-content-zoom-snap-points'>",
        "-ms-content-zoom-snap-points": "snapInterval( <percentage> , <percentage> )|snapList( <percentage># )",
        "-ms-content-zoom-snap-type": "none|proximity|mandatory",
        "-ms-filter": "<string>",
        "-ms-flow-from": "[none|<custom-ident>]#",
        "-ms-flow-into": "[none|<custom-ident>]#",
        "-ms-grid-columns": "none|<track-list>|<auto-track-list>",
        "-ms-grid-rows": "none|<track-list>|<auto-track-list>",
        "-ms-high-contrast-adjust": "auto|none",
        "-ms-hyphenate-limit-chars": "auto|<integer>{1,3}",
        "-ms-hyphenate-limit-lines": "no-limit|<integer>",
        "-ms-hyphenate-limit-zone": "<percentage>|<length>",
        "-ms-ime-align": "auto|after",
        "-ms-overflow-style": "auto|none|scrollbar|-ms-autohiding-scrollbar",
        "-ms-scrollbar-3dlight-color": "<color>",
        "-ms-scrollbar-arrow-color": "<color>",
        "-ms-scrollbar-base-color": "<color>",
        "-ms-scrollbar-darkshadow-color": "<color>",
        "-ms-scrollbar-face-color": "<color>",
        "-ms-scrollbar-highlight-color": "<color>",
        "-ms-scrollbar-shadow-color": "<color>",
        "-ms-scrollbar-track-color": "<color>",
        "-ms-scroll-chaining": "chained|none",
        "-ms-scroll-limit": "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
        "-ms-scroll-limit-x-max": "auto|<length>",
        "-ms-scroll-limit-x-min": "<length>",
        "-ms-scroll-limit-y-max": "auto|<length>",
        "-ms-scroll-limit-y-min": "<length>",
        "-ms-scroll-rails": "none|railed",
        "-ms-scroll-snap-points-x": "snapInterval( <length-percentage> , <length-percentage> )|snapList( <length-percentage># )",
        "-ms-scroll-snap-points-y": "snapInterval( <length-percentage> , <length-percentage> )|snapList( <length-percentage># )",
        "-ms-scroll-snap-type": "none|proximity|mandatory",
        "-ms-scroll-snap-x": "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
        "-ms-scroll-snap-y": "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
        "-ms-scroll-translation": "none|vertical-to-horizontal",
        "-ms-text-autospace": "none|ideograph-alpha|ideograph-numeric|ideograph-parenthesis|ideograph-space",
        "-ms-touch-select": "grippers|none",
        "-ms-user-select": "none|element|text",
        "-ms-wrap-flow": "auto|both|start|end|maximum|clear",
        "-ms-wrap-margin": "<length>",
        "-ms-wrap-through": "wrap|none",
        "-moz-appearance": "none|button|button-arrow-down|button-arrow-next|button-arrow-previous|button-arrow-up|button-bevel|button-focus|caret|checkbox|checkbox-container|checkbox-label|checkmenuitem|dualbutton|groupbox|listbox|listitem|menuarrow|menubar|menucheckbox|menuimage|menuitem|menuitemtext|menulist|menulist-button|menulist-text|menulist-textfield|menupopup|menuradio|menuseparator|meterbar|meterchunk|progressbar|progressbar-vertical|progresschunk|progresschunk-vertical|radio|radio-container|radio-label|radiomenuitem|range|range-thumb|resizer|resizerpanel|scale-horizontal|scalethumbend|scalethumb-horizontal|scalethumbstart|scalethumbtick|scalethumb-vertical|scale-vertical|scrollbarbutton-down|scrollbarbutton-left|scrollbarbutton-right|scrollbarbutton-up|scrollbarthumb-horizontal|scrollbarthumb-vertical|scrollbartrack-horizontal|scrollbartrack-vertical|searchfield|separator|sheet|spinner|spinner-downbutton|spinner-textfield|spinner-upbutton|splitter|statusbar|statusbarpanel|tab|tabpanel|tabpanels|tab-scroll-arrow-back|tab-scroll-arrow-forward|textfield|textfield-multiline|toolbar|toolbarbutton|toolbarbutton-dropdown|toolbargripper|toolbox|tooltip|treeheader|treeheadercell|treeheadersortarrow|treeitem|treeline|treetwisty|treetwistyopen|treeview|-moz-mac-unified-toolbar|-moz-win-borderless-glass|-moz-win-browsertabbar-toolbox|-moz-win-communicationstext|-moz-win-communications-toolbox|-moz-win-exclude-glass|-moz-win-glass|-moz-win-mediatext|-moz-win-media-toolbox|-moz-window-button-box|-moz-window-button-box-maximized|-moz-window-button-close|-moz-window-button-maximize|-moz-window-button-minimize|-moz-window-button-restore|-moz-window-frame-bottom|-moz-window-frame-left|-moz-window-frame-right|-moz-window-titlebar|-moz-window-titlebar-maximized",
        "-moz-binding": "<url>|none",
        "-moz-border-bottom-colors": "<color>+|none",
        "-moz-border-left-colors": "<color>+|none",
        "-moz-border-right-colors": "<color>+|none",
        "-moz-border-top-colors": "<color>+|none",
        "-moz-context-properties": "none|[fill|fill-opacity|stroke|stroke-opacity]#",
        "-moz-float-edge": "border-box|content-box|margin-box|padding-box",
        "-moz-force-broken-image-icon": "0|1",
        "-moz-image-region": "<shape>|auto",
        "-moz-orient": "inline|block|horizontal|vertical",
        "-moz-outline-radius": "<outline-radius>{1,4} [/ <outline-radius>{1,4}]?",
        "-moz-outline-radius-bottomleft": "<outline-radius>",
        "-moz-outline-radius-bottomright": "<outline-radius>",
        "-moz-outline-radius-topleft": "<outline-radius>",
        "-moz-outline-radius-topright": "<outline-radius>",
        "-moz-stack-sizing": "ignore|stretch-to-fit",
        "-moz-text-blink": "none|blink",
        "-moz-user-focus": "ignore|normal|select-after|select-before|select-menu|select-same|select-all|none",
        "-moz-user-input": "auto|none|enabled|disabled",
        "-moz-user-modify": "read-only|read-write|write-only",
        "-moz-window-dragging": "drag|no-drag",
        "-moz-window-shadow": "default|menu|tooltip|sheet|none",
        "-webkit-appearance": "none|button|button-bevel|caps-lock-indicator|caret|checkbox|default-button|inner-spin-button|listbox|listitem|media-controls-background|media-controls-fullscreen-background|media-current-time-display|media-enter-fullscreen-button|media-exit-fullscreen-button|media-fullscreen-button|media-mute-button|media-overlay-play-button|media-play-button|media-seek-back-button|media-seek-forward-button|media-slider|media-sliderthumb|media-time-remaining-display|media-toggle-closed-captions-button|media-volume-slider|media-volume-slider-container|media-volume-sliderthumb|menulist|menulist-button|menulist-text|menulist-textfield|meter|progress-bar|progress-bar-value|push-button|radio|scrollbarbutton-down|scrollbarbutton-left|scrollbarbutton-right|scrollbarbutton-up|scrollbargripper-horizontal|scrollbargripper-vertical|scrollbarthumb-horizontal|scrollbarthumb-vertical|scrollbartrack-horizontal|scrollbartrack-vertical|searchfield|searchfield-cancel-button|searchfield-decoration|searchfield-results-button|searchfield-results-decoration|slider-horizontal|slider-vertical|sliderthumb-horizontal|sliderthumb-vertical|square-button|textarea|textfield|-apple-pay-button",
        "-webkit-border-before": "<'border-width'>||<'border-style'>||<color>",
        "-webkit-border-before-color": "<color>",
        "-webkit-border-before-style": "<'border-style'>",
        "-webkit-border-before-width": "<'border-width'>",
        "-webkit-box-reflect": "[above|below|right|left]? <length>? <image>?",
        "-webkit-line-clamp": "none|<integer>",
        "-webkit-mask": "[<mask-reference>||<position> [/ <bg-size>]?||<repeat-style>||[<box>|border|padding|content|text]||[<box>|border|padding|content]]#",
        "-webkit-mask-attachment": "<attachment>#",
        "-webkit-mask-clip": "[<box>|border|padding|content|text]#",
        "-webkit-mask-composite": "<composite-style>#",
        "-webkit-mask-image": "<mask-reference>#",
        "-webkit-mask-origin": "[<box>|border|padding|content]#",
        "-webkit-mask-position": "<position>#",
        "-webkit-mask-position-x": "[<length-percentage>|left|center|right]#",
        "-webkit-mask-position-y": "[<length-percentage>|top|center|bottom]#",
        "-webkit-mask-repeat": "<repeat-style>#",
        "-webkit-mask-repeat-x": "repeat|no-repeat|space|round",
        "-webkit-mask-repeat-y": "repeat|no-repeat|space|round",
        "-webkit-mask-size": "<bg-size>#",
        "-webkit-overflow-scrolling": "auto|touch",
        "-webkit-tap-highlight-color": "<color>",
        "-webkit-text-fill-color": "<color>",
        "-webkit-text-stroke": "<length>||<color>",
        "-webkit-text-stroke-color": "<color>",
        "-webkit-text-stroke-width": "<length>",
        "-webkit-touch-callout": "default|none",
        "-webkit-user-modify": "read-only|read-write|read-write-plaintext-only",
        "accent-color": "auto|<color>",
        "align-content": "normal|<baseline-position>|<content-distribution>|<overflow-position>? <content-position>",
        "align-items": "normal|stretch|<baseline-position>|[<overflow-position>? <self-position>]",
        "align-self": "auto|normal|stretch|<baseline-position>|<overflow-position>? <self-position>",
        "align-tracks": "[normal|<baseline-position>|<content-distribution>|<overflow-position>? <content-position>]#",
        "all": "initial|inherit|unset|revert|revert-layer",
        "animation": "<single-animation>#",
        "animation-delay": "<time>#",
        "animation-direction": "<single-animation-direction>#",
        "animation-duration": "<time>#",
        "animation-fill-mode": "<single-animation-fill-mode>#",
        "animation-iteration-count": "<single-animation-iteration-count>#",
        "animation-name": "[none|<keyframes-name>]#",
        "animation-play-state": "<single-animation-play-state>#",
        "animation-timing-function": "<easing-function>#",
        "animation-timeline": "<single-animation-timeline>#",
        "appearance": "none|auto|textfield|menulist-button|<compat-auto>",
        "aspect-ratio": "auto|<ratio>",
        "azimuth": "<angle>|[[left-side|far-left|left|center-left|center|center-right|right|far-right|right-side]||behind]|leftwards|rightwards",
        "backdrop-filter": "none|<filter-function-list>",
        "backface-visibility": "visible|hidden",
        "background": "[<bg-layer> ,]* <final-bg-layer>",
        "background-attachment": "<attachment>#",
        "background-blend-mode": "<blend-mode>#",
        "background-clip": "<bg-clip>#",
        "background-color": "<color>",
        "background-image": "<bg-image>#",
        "background-origin": "<box>#",
        "background-position": "<bg-position>#",
        "background-position-x": "[center|[[left|right|x-start|x-end]? <length-percentage>?]!]#",
        "background-position-y": "[center|[[top|bottom|y-start|y-end]? <length-percentage>?]!]#",
        "background-repeat": "<repeat-style>#",
        "background-size": "<bg-size>#",
        "block-overflow": "clip|ellipsis|<string>",
        "block-size": "<'width'>",
        "border": "<line-width>||<line-style>||<color>",
        "border-block": "<'border-top-width'>||<'border-top-style'>||<color>",
        "border-block-color": "<'border-top-color'>{1,2}",
        "border-block-style": "<'border-top-style'>",
        "border-block-width": "<'border-top-width'>",
        "border-block-end": "<'border-top-width'>||<'border-top-style'>||<color>",
        "border-block-end-color": "<'border-top-color'>",
        "border-block-end-style": "<'border-top-style'>",
        "border-block-end-width": "<'border-top-width'>",
        "border-block-start": "<'border-top-width'>||<'border-top-style'>||<color>",
        "border-block-start-color": "<'border-top-color'>",
        "border-block-start-style": "<'border-top-style'>",
        "border-block-start-width": "<'border-top-width'>",
        "border-bottom": "<line-width>||<line-style>||<color>",
        "border-bottom-color": "<'border-top-color'>",
        "border-bottom-left-radius": "<length-percentage>{1,2}",
        "border-bottom-right-radius": "<length-percentage>{1,2}",
        "border-bottom-style": "<line-style>",
        "border-bottom-width": "<line-width>",
        "border-collapse": "collapse|separate",
        "border-color": "<color>{1,4}",
        "border-end-end-radius": "<length-percentage>{1,2}",
        "border-end-start-radius": "<length-percentage>{1,2}",
        "border-image": "<'border-image-source'>||<'border-image-slice'> [/ <'border-image-width'>|/ <'border-image-width'>? / <'border-image-outset'>]?||<'border-image-repeat'>",
        "border-image-outset": "[<length>|<number>]{1,4}",
        "border-image-repeat": "[stretch|repeat|round|space]{1,2}",
        "border-image-slice": "<number-percentage>{1,4}&&fill?",
        "border-image-source": "none|<image>",
        "border-image-width": "[<length-percentage>|<number>|auto]{1,4}",
        "border-inline": "<'border-top-width'>||<'border-top-style'>||<color>",
        "border-inline-end": "<'border-top-width'>||<'border-top-style'>||<color>",
        "border-inline-color": "<'border-top-color'>{1,2}",
        "border-inline-style": "<'border-top-style'>",
        "border-inline-width": "<'border-top-width'>",
        "border-inline-end-color": "<'border-top-color'>",
        "border-inline-end-style": "<'border-top-style'>",
        "border-inline-end-width": "<'border-top-width'>",
        "border-inline-start": "<'border-top-width'>||<'border-top-style'>||<color>",
        "border-inline-start-color": "<'border-top-color'>",
        "border-inline-start-style": "<'border-top-style'>",
        "border-inline-start-width": "<'border-top-width'>",
        "border-left": "<line-width>||<line-style>||<color>",
        "border-left-color": "<color>",
        "border-left-style": "<line-style>",
        "border-left-width": "<line-width>",
        "border-radius": "<length-percentage>{1,4} [/ <length-percentage>{1,4}]?",
        "border-right": "<line-width>||<line-style>||<color>",
        "border-right-color": "<color>",
        "border-right-style": "<line-style>",
        "border-right-width": "<line-width>",
        "border-spacing": "<length> <length>?",
        "border-start-end-radius": "<length-percentage>{1,2}",
        "border-start-start-radius": "<length-percentage>{1,2}",
        "border-style": "<line-style>{1,4}",
        "border-top": "<line-width>||<line-style>||<color>",
        "border-top-color": "<color>",
        "border-top-left-radius": "<length-percentage>{1,2}",
        "border-top-right-radius": "<length-percentage>{1,2}",
        "border-top-style": "<line-style>",
        "border-top-width": "<line-width>",
        "border-width": "<line-width>{1,4}",
        "bottom": "<length>|<percentage>|auto",
        "box-align": "start|center|end|baseline|stretch",
        "box-decoration-break": "slice|clone",
        "box-direction": "normal|reverse|inherit",
        "box-flex": "<number>",
        "box-flex-group": "<integer>",
        "box-lines": "single|multiple",
        "box-ordinal-group": "<integer>",
        "box-orient": "horizontal|vertical|inline-axis|block-axis|inherit",
        "box-pack": "start|center|end|justify",
        "box-shadow": "none|<shadow>#",
        "box-sizing": "content-box|border-box",
        "break-after": "auto|avoid|always|all|avoid-page|page|left|right|recto|verso|avoid-column|column|avoid-region|region",
        "break-before": "auto|avoid|always|all|avoid-page|page|left|right|recto|verso|avoid-column|column|avoid-region|region",
        "break-inside": "auto|avoid|avoid-page|avoid-column|avoid-region",
        "caption-side": "top|bottom|block-start|block-end|inline-start|inline-end",
        "caret-color": "auto|<color>",
        "clear": "none|left|right|both|inline-start|inline-end",
        "clip": "<shape>|auto",
        "clip-path": "<clip-source>|[<basic-shape>||<geometry-box>]|none",
        "color": "<color>",
        "print-color-adjust": "economy|exact",
        "color-scheme": "normal|[light|dark|<custom-ident>]+&&only?",
        "column-count": "<integer>|auto",
        "column-fill": "auto|balance|balance-all",
        "column-gap": "normal|<length-percentage>",
        "column-rule": "<'column-rule-width'>||<'column-rule-style'>||<'column-rule-color'>",
        "column-rule-color": "<color>",
        "column-rule-style": "<'border-style'>",
        "column-rule-width": "<'border-width'>",
        "column-span": "none|all",
        "column-width": "<length>|auto",
        "columns": "<'column-width'>||<'column-count'>",
        "contain": "none|strict|content|[size||layout||style||paint]",
        "content": "normal|none|[<content-replacement>|<content-list>] [/ [<string>|<counter>]+]?",
        "content-visibility": "visible|auto|hidden",
        "counter-increment": "[<counter-name> <integer>?]+|none",
        "counter-reset": "[<counter-name> <integer>?|<reversed-counter-name> <integer>?]+|none",
        "counter-set": "[<counter-name> <integer>?]+|none",
        "cursor": "[[<url> [<x> <y>]? ,]* [auto|default|none|context-menu|help|pointer|progress|wait|cell|crosshair|text|vertical-text|alias|copy|move|no-drop|not-allowed|e-resize|n-resize|ne-resize|nw-resize|s-resize|se-resize|sw-resize|w-resize|ew-resize|ns-resize|nesw-resize|nwse-resize|col-resize|row-resize|all-scroll|zoom-in|zoom-out|grab|grabbing|hand|-webkit-grab|-webkit-grabbing|-webkit-zoom-in|-webkit-zoom-out|-moz-grab|-moz-grabbing|-moz-zoom-in|-moz-zoom-out]]",
        "direction": "ltr|rtl",
        "display": "[<display-outside>||<display-inside>]|<display-listitem>|<display-internal>|<display-box>|<display-legacy>|<-non-standard-display>",
        "empty-cells": "show|hide",
        "filter": "none|<filter-function-list>|<-ms-filter-function-list>",
        "flex": "none|[<'flex-grow'> <'flex-shrink'>?||<'flex-basis'>]",
        "flex-basis": "content|<'width'>",
        "flex-direction": "row|row-reverse|column|column-reverse",
        "flex-flow": "<'flex-direction'>||<'flex-wrap'>",
        "flex-grow": "<number>",
        "flex-shrink": "<number>",
        "flex-wrap": "nowrap|wrap|wrap-reverse",
        "float": "left|right|none|inline-start|inline-end",
        "font": "[[<'font-style'>||<font-variant-css21>||<'font-weight'>||<'font-stretch'>]? <'font-size'> [/ <'line-height'>]? <'font-family'>]|caption|icon|menu|message-box|small-caption|status-bar",
        "font-family": "[<family-name>|<generic-family>]#",
        "font-feature-settings": "normal|<feature-tag-value>#",
        "font-kerning": "auto|normal|none",
        "font-language-override": "normal|<string>",
        "font-optical-sizing": "auto|none",
        "font-variation-settings": "normal|[<string> <number>]#",
        "font-size": "<absolute-size>|<relative-size>|<length-percentage>",
        "font-size-adjust": "none|[ex-height|cap-height|ch-width|ic-width|ic-height]? [from-font|<number>]",
        "font-smooth": "auto|never|always|<absolute-size>|<length>",
        "font-stretch": "<font-stretch-absolute>",
        "font-style": "normal|italic|oblique <angle>?",
        "font-synthesis": "none|[weight||style||small-caps]",
        "font-variant": "normal|none|[<common-lig-values>||<discretionary-lig-values>||<historical-lig-values>||<contextual-alt-values>||stylistic( <feature-value-name> )||historical-forms||styleset( <feature-value-name># )||character-variant( <feature-value-name># )||swash( <feature-value-name> )||ornaments( <feature-value-name> )||annotation( <feature-value-name> )||[small-caps|all-small-caps|petite-caps|all-petite-caps|unicase|titling-caps]||<numeric-figure-values>||<numeric-spacing-values>||<numeric-fraction-values>||ordinal||slashed-zero||<east-asian-variant-values>||<east-asian-width-values>||ruby]",
        "font-variant-alternates": "normal|[stylistic( <feature-value-name> )||historical-forms||styleset( <feature-value-name># )||character-variant( <feature-value-name># )||swash( <feature-value-name> )||ornaments( <feature-value-name> )||annotation( <feature-value-name> )]",
        "font-variant-caps": "normal|small-caps|all-small-caps|petite-caps|all-petite-caps|unicase|titling-caps",
        "font-variant-east-asian": "normal|[<east-asian-variant-values>||<east-asian-width-values>||ruby]",
        "font-variant-ligatures": "normal|none|[<common-lig-values>||<discretionary-lig-values>||<historical-lig-values>||<contextual-alt-values>]",
        "font-variant-numeric": "normal|[<numeric-figure-values>||<numeric-spacing-values>||<numeric-fraction-values>||ordinal||slashed-zero]",
        "font-variant-position": "normal|sub|super",
        "font-weight": "<font-weight-absolute>|bolder|lighter",
        "forced-color-adjust": "auto|none",
        "gap": "<'row-gap'> <'column-gap'>?",
        "grid": "<'grid-template'>|<'grid-template-rows'> / [auto-flow&&dense?] <'grid-auto-columns'>?|[auto-flow&&dense?] <'grid-auto-rows'>? / <'grid-template-columns'>",
        "grid-area": "<grid-line> [/ <grid-line>]{0,3}",
        "grid-auto-columns": "<track-size>+",
        "grid-auto-flow": "[row|column]||dense",
        "grid-auto-rows": "<track-size>+",
        "grid-column": "<grid-line> [/ <grid-line>]?",
        "grid-column-end": "<grid-line>",
        "grid-column-gap": "<length-percentage>",
        "grid-column-start": "<grid-line>",
        "grid-gap": "<'grid-row-gap'> <'grid-column-gap'>?",
        "grid-row": "<grid-line> [/ <grid-line>]?",
        "grid-row-end": "<grid-line>",
        "grid-row-gap": "<length-percentage>",
        "grid-row-start": "<grid-line>",
        "grid-template": "none|[<'grid-template-rows'> / <'grid-template-columns'>]|[<line-names>? <string> <track-size>? <line-names>?]+ [/ <explicit-track-list>]?",
        "grid-template-areas": "none|<string>+",
        "grid-template-columns": "none|<track-list>|<auto-track-list>|subgrid <line-name-list>?",
        "grid-template-rows": "none|<track-list>|<auto-track-list>|subgrid <line-name-list>?",
        "hanging-punctuation": "none|[first||[force-end|allow-end]||last]",
        "height": "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )",
        "hyphenate-character": "auto|<string>",
        "hyphens": "none|manual|auto",
        "image-orientation": "from-image|<angle>|[<angle>? flip]",
        "image-rendering": "auto|crisp-edges|pixelated|optimizeSpeed|optimizeQuality|<-non-standard-image-rendering>",
        "image-resolution": "[from-image||<resolution>]&&snap?",
        "ime-mode": "auto|normal|active|inactive|disabled",
        "initial-letter": "normal|[<number> <integer>?]",
        "initial-letter-align": "[auto|alphabetic|hanging|ideographic]",
        "inline-size": "<'width'>",
        "input-security": "auto|none",
        "inset": "<'top'>{1,4}",
        "inset-block": "<'top'>{1,2}",
        "inset-block-end": "<'top'>",
        "inset-block-start": "<'top'>",
        "inset-inline": "<'top'>{1,2}",
        "inset-inline-end": "<'top'>",
        "inset-inline-start": "<'top'>",
        "isolation": "auto|isolate",
        "justify-content": "normal|<content-distribution>|<overflow-position>? [<content-position>|left|right]",
        "justify-items": "normal|stretch|<baseline-position>|<overflow-position>? [<self-position>|left|right]|legacy|legacy&&[left|right|center]",
        "justify-self": "auto|normal|stretch|<baseline-position>|<overflow-position>? [<self-position>|left|right]",
        "justify-tracks": "[normal|<content-distribution>|<overflow-position>? [<content-position>|left|right]]#",
        "left": "<length>|<percentage>|auto",
        "letter-spacing": "normal|<length-percentage>",
        "line-break": "auto|loose|normal|strict|anywhere",
        "line-clamp": "none|<integer>",
        "line-height": "normal|<number>|<length>|<percentage>",
        "line-height-step": "<length>",
        "list-style": "<'list-style-type'>||<'list-style-position'>||<'list-style-image'>",
        "list-style-image": "<image>|none",
        "list-style-position": "inside|outside",
        "list-style-type": "<counter-style>|<string>|none",
        "margin": "[<length>|<percentage>|auto]{1,4}",
        "margin-block": "<'margin-left'>{1,2}",
        "margin-block-end": "<'margin-left'>",
        "margin-block-start": "<'margin-left'>",
        "margin-bottom": "<length>|<percentage>|auto",
        "margin-inline": "<'margin-left'>{1,2}",
        "margin-inline-end": "<'margin-left'>",
        "margin-inline-start": "<'margin-left'>",
        "margin-left": "<length>|<percentage>|auto",
        "margin-right": "<length>|<percentage>|auto",
        "margin-top": "<length>|<percentage>|auto",
        "margin-trim": "none|in-flow|all",
        "mask": "<mask-layer>#",
        "mask-border": "<'mask-border-source'>||<'mask-border-slice'> [/ <'mask-border-width'>? [/ <'mask-border-outset'>]?]?||<'mask-border-repeat'>||<'mask-border-mode'>",
        "mask-border-mode": "luminance|alpha",
        "mask-border-outset": "[<length>|<number>]{1,4}",
        "mask-border-repeat": "[stretch|repeat|round|space]{1,2}",
        "mask-border-slice": "<number-percentage>{1,4} fill?",
        "mask-border-source": "none|<image>",
        "mask-border-width": "[<length-percentage>|<number>|auto]{1,4}",
        "mask-clip": "[<geometry-box>|no-clip]#",
        "mask-composite": "<compositing-operator>#",
        "mask-image": "<mask-reference>#",
        "mask-mode": "<masking-mode>#",
        "mask-origin": "<geometry-box>#",
        "mask-position": "<position>#",
        "mask-repeat": "<repeat-style>#",
        "mask-size": "<bg-size>#",
        "mask-type": "luminance|alpha",
        "masonry-auto-flow": "[pack|next]||[definite-first|ordered]",
        "math-style": "normal|compact",
        "max-block-size": "<'max-width'>",
        "max-height": "none|<length-percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )",
        "max-inline-size": "<'max-width'>",
        "max-lines": "none|<integer>",
        "max-width": "none|<length-percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|<-non-standard-width>",
        "min-block-size": "<'min-width'>",
        "min-height": "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )",
        "min-inline-size": "<'min-width'>",
        "min-width": "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|<-non-standard-width>",
        "mix-blend-mode": "<blend-mode>|plus-lighter",
        "object-fit": "fill|contain|cover|none|scale-down",
        "object-position": "<position>",
        "offset": "[<'offset-position'>? [<'offset-path'> [<'offset-distance'>||<'offset-rotate'>]?]?]! [/ <'offset-anchor'>]?",
        "offset-anchor": "auto|<position>",
        "offset-distance": "<length-percentage>",
        "offset-path": "none|ray( [<angle>&&<size>&&contain?] )|<path()>|<url>|[<basic-shape>||<geometry-box>]",
        "offset-position": "auto|<position>",
        "offset-rotate": "[auto|reverse]||<angle>",
        "opacity": "<alpha-value>",
        "order": "<integer>",
        "orphans": "<integer>",
        "outline": "[<'outline-color'>||<'outline-style'>||<'outline-width'>]",
        "outline-color": "<color>|invert",
        "outline-offset": "<length>",
        "outline-style": "auto|<'border-style'>",
        "outline-width": "<line-width>",
        "overflow": "[visible|hidden|clip|scroll|auto]{1,2}|<-non-standard-overflow>",
        "overflow-anchor": "auto|none",
        "overflow-block": "visible|hidden|clip|scroll|auto",
        "overflow-clip-box": "padding-box|content-box",
        "overflow-clip-margin": "<visual-box>||<length [0,]>",
        "overflow-inline": "visible|hidden|clip|scroll|auto",
        "overflow-wrap": "normal|break-word|anywhere",
        "overflow-x": "visible|hidden|clip|scroll|auto",
        "overflow-y": "visible|hidden|clip|scroll|auto",
        "overscroll-behavior": "[contain|none|auto]{1,2}",
        "overscroll-behavior-block": "contain|none|auto",
        "overscroll-behavior-inline": "contain|none|auto",
        "overscroll-behavior-x": "contain|none|auto",
        "overscroll-behavior-y": "contain|none|auto",
        "padding": "[<length>|<percentage>]{1,4}",
        "padding-block": "<'padding-left'>{1,2}",
        "padding-block-end": "<'padding-left'>",
        "padding-block-start": "<'padding-left'>",
        "padding-bottom": "<length>|<percentage>",
        "padding-inline": "<'padding-left'>{1,2}",
        "padding-inline-end": "<'padding-left'>",
        "padding-inline-start": "<'padding-left'>",
        "padding-left": "<length>|<percentage>",
        "padding-right": "<length>|<percentage>",
        "padding-top": "<length>|<percentage>",
        "page-break-after": "auto|always|avoid|left|right|recto|verso",
        "page-break-before": "auto|always|avoid|left|right|recto|verso",
        "page-break-inside": "auto|avoid",
        "paint-order": "normal|[fill||stroke||markers]",
        "perspective": "none|<length>",
        "perspective-origin": "<position>",
        "place-content": "<'align-content'> <'justify-content'>?",
        "place-items": "<'align-items'> <'justify-items'>?",
        "place-self": "<'align-self'> <'justify-self'>?",
        "pointer-events": "auto|none|visiblePainted|visibleFill|visibleStroke|visible|painted|fill|stroke|all|inherit",
        "position": "static|relative|absolute|sticky|fixed|-webkit-sticky",
        "quotes": "none|auto|[<string> <string>]+",
        "resize": "none|both|horizontal|vertical|block|inline",
        "right": "<length>|<percentage>|auto",
        "rotate": "none|<angle>|[x|y|z|<number>{3}]&&<angle>",
        "row-gap": "normal|<length-percentage>",
        "ruby-align": "start|center|space-between|space-around",
        "ruby-merge": "separate|collapse|auto",
        "ruby-position": "[alternate||[over|under]]|inter-character",
        "scale": "none|<number>{1,3}",
        "scrollbar-color": "auto|<color>{2}",
        "scrollbar-gutter": "auto|stable&&both-edges?",
        "scrollbar-width": "auto|thin|none",
        "scroll-behavior": "auto|smooth",
        "scroll-margin": "<length>{1,4}",
        "scroll-margin-block": "<length>{1,2}",
        "scroll-margin-block-start": "<length>",
        "scroll-margin-block-end": "<length>",
        "scroll-margin-bottom": "<length>",
        "scroll-margin-inline": "<length>{1,2}",
        "scroll-margin-inline-start": "<length>",
        "scroll-margin-inline-end": "<length>",
        "scroll-margin-left": "<length>",
        "scroll-margin-right": "<length>",
        "scroll-margin-top": "<length>",
        "scroll-padding": "[auto|<length-percentage>]{1,4}",
        "scroll-padding-block": "[auto|<length-percentage>]{1,2}",
        "scroll-padding-block-start": "auto|<length-percentage>",
        "scroll-padding-block-end": "auto|<length-percentage>",
        "scroll-padding-bottom": "auto|<length-percentage>",
        "scroll-padding-inline": "[auto|<length-percentage>]{1,2}",
        "scroll-padding-inline-start": "auto|<length-percentage>",
        "scroll-padding-inline-end": "auto|<length-percentage>",
        "scroll-padding-left": "auto|<length-percentage>",
        "scroll-padding-right": "auto|<length-percentage>",
        "scroll-padding-top": "auto|<length-percentage>",
        "scroll-snap-align": "[none|start|end|center]{1,2}",
        "scroll-snap-coordinate": "none|<position>#",
        "scroll-snap-destination": "<position>",
        "scroll-snap-points-x": "none|repeat( <length-percentage> )",
        "scroll-snap-points-y": "none|repeat( <length-percentage> )",
        "scroll-snap-stop": "normal|always",
        "scroll-snap-type": "none|[x|y|block|inline|both] [mandatory|proximity]?",
        "scroll-snap-type-x": "none|mandatory|proximity",
        "scroll-snap-type-y": "none|mandatory|proximity",
        "shape-image-threshold": "<alpha-value>",
        "shape-margin": "<length-percentage>",
        "shape-outside": "none|[<shape-box>||<basic-shape>]|<image>",
        "tab-size": "<integer>|<length>",
        "table-layout": "auto|fixed",
        "text-align": "start|end|left|right|center|justify|match-parent",
        "text-align-last": "auto|start|end|left|right|center|justify",
        "text-combine-upright": "none|all|[digits <integer>?]",
        "text-decoration": "<'text-decoration-line'>||<'text-decoration-style'>||<'text-decoration-color'>||<'text-decoration-thickness'>",
        "text-decoration-color": "<color>",
        "text-decoration-line": "none|[underline||overline||line-through||blink]|spelling-error|grammar-error",
        "text-decoration-skip": "none|[objects||[spaces|[leading-spaces||trailing-spaces]]||edges||box-decoration]",
        "text-decoration-skip-ink": "auto|all|none",
        "text-decoration-style": "solid|double|dotted|dashed|wavy",
        "text-decoration-thickness": "auto|from-font|<length>|<percentage>",
        "text-emphasis": "<'text-emphasis-style'>||<'text-emphasis-color'>",
        "text-emphasis-color": "<color>",
        "text-emphasis-position": "[over|under]&&[right|left]",
        "text-emphasis-style": "none|[[filled|open]||[dot|circle|double-circle|triangle|sesame]]|<string>",
        "text-indent": "<length-percentage>&&hanging?&&each-line?",
        "text-justify": "auto|inter-character|inter-word|none",
        "text-orientation": "mixed|upright|sideways",
        "text-overflow": "[clip|ellipsis|<string>]{1,2}",
        "text-rendering": "auto|optimizeSpeed|optimizeLegibility|geometricPrecision",
        "text-shadow": "none|<shadow-t>#",
        "text-size-adjust": "none|auto|<percentage>",
        "text-transform": "none|capitalize|uppercase|lowercase|full-width|full-size-kana",
        "text-underline-offset": "auto|<length>|<percentage>",
        "text-underline-position": "auto|from-font|[under||[left|right]]",
        "top": "<length>|<percentage>|auto",
        "touch-action": "auto|none|[[pan-x|pan-left|pan-right]||[pan-y|pan-up|pan-down]||pinch-zoom]|manipulation",
        "transform": "none|<transform-list>",
        "transform-box": "content-box|border-box|fill-box|stroke-box|view-box",
        "transform-origin": "[<length-percentage>|left|center|right|top|bottom]|[[<length-percentage>|left|center|right]&&[<length-percentage>|top|center|bottom]] <length>?",
        "transform-style": "flat|preserve-3d",
        "transition": "<single-transition>#",
        "transition-delay": "<time>#",
        "transition-duration": "<time>#",
        "transition-property": "none|<single-transition-property>#",
        "transition-timing-function": "<easing-function>#",
        "translate": "none|<length-percentage> [<length-percentage> <length>?]?",
        "unicode-bidi": "normal|embed|isolate|bidi-override|isolate-override|plaintext|-moz-isolate|-moz-isolate-override|-moz-plaintext|-webkit-isolate|-webkit-isolate-override|-webkit-plaintext",
        "user-select": "auto|text|none|contain|all",
        "vertical-align": "baseline|sub|super|text-top|text-bottom|middle|top|bottom|<percentage>|<length>",
        "visibility": "visible|hidden|collapse",
        "white-space": "normal|pre|nowrap|pre-wrap|pre-line|break-spaces",
        "widows": "<integer>",
        "width": "auto|<length>|<percentage>|min-content|max-content|fit-content|fit-content( <length-percentage> )|fill|stretch|intrinsic|-moz-max-content|-webkit-max-content|-moz-fit-content|-webkit-fit-content",
        "will-change": "auto|<animateable-feature>#",
        "word-break": "normal|break-all|keep-all|break-word",
        "word-spacing": "normal|<length>",
        "word-wrap": "normal|break-word",
        "writing-mode": "horizontal-tb|vertical-rl|vertical-lr|sideways-rl|sideways-lr|<svg-writing-mode>",
        "z-index": "auto|<integer>",
        "zoom": "normal|reset|<number>|<percentage>",
        "-moz-background-clip": "padding|border",
        "-moz-border-radius-bottomleft": "<'border-bottom-left-radius'>",
        "-moz-border-radius-bottomright": "<'border-bottom-right-radius'>",
        "-moz-border-radius-topleft": "<'border-top-left-radius'>",
        "-moz-border-radius-topright": "<'border-bottom-right-radius'>",
        "-moz-control-character-visibility": "visible|hidden",
        "-moz-osx-font-smoothing": "auto|grayscale",
        "-moz-user-select": "none|text|all|-moz-none",
        "-ms-flex-align": "start|end|center|baseline|stretch",
        "-ms-flex-item-align": "auto|start|end|center|baseline|stretch",
        "-ms-flex-line-pack": "start|end|center|justify|distribute|stretch",
        "-ms-flex-negative": "<'flex-shrink'>",
        "-ms-flex-pack": "start|end|center|justify|distribute",
        "-ms-flex-order": "<integer>",
        "-ms-flex-positive": "<'flex-grow'>",
        "-ms-flex-preferred-size": "<'flex-basis'>",
        "-ms-interpolation-mode": "nearest-neighbor|bicubic",
        "-ms-grid-column-align": "start|end|center|stretch",
        "-ms-grid-row-align": "start|end|center|stretch",
        "-ms-hyphenate-limit-last": "none|always|column|page|spread",
        "-webkit-background-clip": "[<box>|border|padding|content|text]#",
        "-webkit-column-break-after": "always|auto|avoid",
        "-webkit-column-break-before": "always|auto|avoid",
        "-webkit-column-break-inside": "always|auto|avoid",
        "-webkit-font-smoothing": "auto|none|antialiased|subpixel-antialiased",
        "-webkit-mask-box-image": "[<url>|<gradient>|none] [<length-percentage>{4} <-webkit-mask-box-repeat>{2}]?",
        "-webkit-print-color-adjust": "economy|exact",
        "-webkit-text-security": "none|circle|disc|square",
        "-webkit-user-drag": "none|element|auto",
        "-webkit-user-select": "auto|none|text|all",
        "alignment-baseline": "auto|baseline|before-edge|text-before-edge|middle|central|after-edge|text-after-edge|ideographic|alphabetic|hanging|mathematical",
        "baseline-shift": "baseline|sub|super|<svg-length>",
        "behavior": "<url>+",
        "clip-rule": "nonzero|evenodd",
        "cue": "<'cue-before'> <'cue-after'>?",
        "cue-after": "<url> <decibel>?|none",
        "cue-before": "<url> <decibel>?|none",
        "dominant-baseline": "auto|use-script|no-change|reset-size|ideographic|alphabetic|hanging|mathematical|central|middle|text-after-edge|text-before-edge",
        "fill": "<paint>",
        "fill-opacity": "<number-zero-one>",
        "fill-rule": "nonzero|evenodd",
        "glyph-orientation-horizontal": "<angle>",
        "glyph-orientation-vertical": "<angle>",
        "kerning": "auto|<svg-length>",
        "marker": "none|<url>",
        "marker-end": "none|<url>",
        "marker-mid": "none|<url>",
        "marker-start": "none|<url>",
        "pause": "<'pause-before'> <'pause-after'>?",
        "pause-after": "<time>|none|x-weak|weak|medium|strong|x-strong",
        "pause-before": "<time>|none|x-weak|weak|medium|strong|x-strong",
        "rest": "<'rest-before'> <'rest-after'>?",
        "rest-after": "<time>|none|x-weak|weak|medium|strong|x-strong",
        "rest-before": "<time>|none|x-weak|weak|medium|strong|x-strong",
        "shape-rendering": "auto|optimizeSpeed|crispEdges|geometricPrecision",
        "src": "[<url> [format( <string># )]?|local( <family-name> )]#",
        "speak": "auto|none|normal",
        "speak-as": "normal|spell-out||digits||[literal-punctuation|no-punctuation]",
        "stroke": "<paint>",
        "stroke-dasharray": "none|[<svg-length>+]#",
        "stroke-dashoffset": "<svg-length>",
        "stroke-linecap": "butt|round|square",
        "stroke-linejoin": "miter|round|bevel",
        "stroke-miterlimit": "<number-one-or-greater>",
        "stroke-opacity": "<number-zero-one>",
        "stroke-width": "<svg-length>",
        "text-anchor": "start|middle|end",
        "unicode-range": "<urange>#",
        "voice-balance": "<number>|left|center|right|leftwards|rightwards",
        "voice-duration": "auto|<time>",
        "voice-family": "[[<family-name>|<generic-voice>] ,]* [<family-name>|<generic-voice>]|preserve",
        "voice-pitch": "<frequency>&&absolute|[[x-low|low|medium|high|x-high]||[<frequency>|<semitones>|<percentage>]]",
        "voice-range": "<frequency>&&absolute|[[x-low|low|medium|high|x-high]||[<frequency>|<semitones>|<percentage>]]",
        "voice-rate": "[normal|x-slow|slow|medium|fast|x-fast]||<percentage>",
        "voice-stress": "normal|strong|moderate|none|reduced",
        "voice-volume": "silent|[[x-soft|soft|medium|loud|x-loud]||<decibel>]"
    },
    "atrules": {
        "charset": {
            "prelude": "<string>",
            "descriptors": null
        },
        "counter-style": {
            "prelude": "<counter-style-name>",
            "descriptors": {
                "additive-symbols": "[<integer>&&<symbol>]#",
                "fallback": "<counter-style-name>",
                "negative": "<symbol> <symbol>?",
                "pad": "<integer>&&<symbol>",
                "prefix": "<symbol>",
                "range": "[[<integer>|infinite]{2}]#|auto",
                "speak-as": "auto|bullets|numbers|words|spell-out|<counter-style-name>",
                "suffix": "<symbol>",
                "symbols": "<symbol>+",
                "system": "cyclic|numeric|alphabetic|symbolic|additive|[fixed <integer>?]|[extends <counter-style-name>]"
            }
        },
        "document": {
            "prelude": "[<url>|url-prefix( <string> )|domain( <string> )|media-document( <string> )|regexp( <string> )]#",
            "descriptors": null
        },
        "font-face": {
            "prelude": null,
            "descriptors": {
                "ascent-override": "normal|<percentage>",
                "descent-override": "normal|<percentage>",
                "font-display": "[auto|block|swap|fallback|optional]",
                "font-family": "<family-name>",
                "font-feature-settings": "normal|<feature-tag-value>#",
                "font-variation-settings": "normal|[<string> <number>]#",
                "font-stretch": "<font-stretch-absolute>{1,2}",
                "font-style": "normal|italic|oblique <angle>{0,2}",
                "font-weight": "<font-weight-absolute>{1,2}",
                "font-variant": "normal|none|[<common-lig-values>||<discretionary-lig-values>||<historical-lig-values>||<contextual-alt-values>||stylistic( <feature-value-name> )||historical-forms||styleset( <feature-value-name># )||character-variant( <feature-value-name># )||swash( <feature-value-name> )||ornaments( <feature-value-name> )||annotation( <feature-value-name> )||[small-caps|all-small-caps|petite-caps|all-petite-caps|unicase|titling-caps]||<numeric-figure-values>||<numeric-spacing-values>||<numeric-fraction-values>||ordinal||slashed-zero||<east-asian-variant-values>||<east-asian-width-values>||ruby]",
                "line-gap-override": "normal|<percentage>",
                "size-adjust": "<percentage>",
                "src": "[<url> [format( <string># )]?|local( <family-name> )]#",
                "unicode-range": "<urange>#"
            }
        },
        "font-feature-values": {
            "prelude": "<family-name>#",
            "descriptors": null
        },
        "import": {
            "prelude": "[<string>|<url>] [layer|layer( <layer-name> )]? [supports( [<supports-condition>|<declaration>] )]? <media-query-list>?",
            "descriptors": null
        },
        "keyframes": {
            "prelude": "<keyframes-name>",
            "descriptors": null
        },
        "layer": {
            "prelude": "[<layer-name>#|<layer-name>?]",
            "descriptors": null
        },
        "media": {
            "prelude": "<media-query-list>",
            "descriptors": null
        },
        "namespace": {
            "prelude": "<namespace-prefix>? [<string>|<url>]",
            "descriptors": null
        },
        "page": {
            "prelude": "<page-selector-list>",
            "descriptors": {
                "bleed": "auto|<length>",
                "marks": "none|[crop||cross]",
                "size": "<length>{1,2}|auto|[<page-size>||[portrait|landscape]]"
            }
        },
        "property": {
            "prelude": "<custom-property-name>",
            "descriptors": {
                "syntax": "<string>",
                "inherits": "true|false",
                "initial-value": "<string>"
            }
        },
        "scroll-timeline": {
            "prelude": "<timeline-name>",
            "descriptors": null
        },
        "supports": {
            "prelude": "<supports-condition>",
            "descriptors": null
        },
        "viewport": {
            "prelude": null,
            "descriptors": {
                "height": "<viewport-length>{1,2}",
                "max-height": "<viewport-length>",
                "max-width": "<viewport-length>",
                "max-zoom": "auto|<number>|<percentage>",
                "min-height": "<viewport-length>",
                "min-width": "<viewport-length>",
                "min-zoom": "auto|<number>|<percentage>",
                "orientation": "auto|portrait|landscape",
                "user-zoom": "zoom|fixed",
                "viewport-fit": "auto|contain|cover",
                "width": "<viewport-length>{1,2}",
                "zoom": "auto|<number>|<percentage>"
            }
        }
    }
});
;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/node/AnPlusB.js


const AnPlusB_PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
const AnPlusB_HYPHENMINUS = 0x002D; // U+002D HYPHEN-MINUS (-)
const AnPlusB_N = 0x006E;           // U+006E LATIN SMALL LETTER N (n)
const AnPlusB_DISALLOW_SIGN = true;
const AnPlusB_ALLOW_SIGN = false;

function AnPlusB_checkInteger(offset, disallowSign) {
    let pos = this.tokenStart + offset;
    const code = this.charCodeAt(pos);

    if (code === AnPlusB_PLUSSIGN || code === AnPlusB_HYPHENMINUS) {
        if (disallowSign) {
            this.error('Number sign is not allowed');
        }
        pos++;
    }

    for (; pos < this.tokenEnd; pos++) {
        if (!isDigit(this.charCodeAt(pos))) {
            this.error('Integer is expected', pos);
        }
    }
}

function checkTokenIsInteger(disallowSign) {
    return AnPlusB_checkInteger.call(this, 0, disallowSign);
}

function expectCharCode(offset, code) {
    if (!this.cmpChar(this.tokenStart + offset, code)) {
        let msg = '';

        switch (code) {
            case AnPlusB_N:
                msg = 'N is expected';
                break;
            case AnPlusB_HYPHENMINUS:
                msg = 'HyphenMinus is expected';
                break;
        }

        this.error(msg, this.tokenStart + offset);
    }
}

// ... <signed-integer>
// ... ['+' | '-'] <signless-integer>
function AnPlusB_consumeB() {
    let offset = 0;
    let sign = 0;
    let type = this.tokenType;

    while (type === WhiteSpace || type === Comment) {
        type = this.lookupType(++offset);
    }

    if (type !== types_Number) {
        if (this.isDelim(AnPlusB_PLUSSIGN, offset) ||
            this.isDelim(AnPlusB_HYPHENMINUS, offset)) {
            sign = this.isDelim(AnPlusB_PLUSSIGN, offset) ? AnPlusB_PLUSSIGN : AnPlusB_HYPHENMINUS;

            do {
                type = this.lookupType(++offset);
            } while (type === WhiteSpace || type === Comment);

            if (type !== types_Number) {
                this.skip(offset);
                checkTokenIsInteger.call(this, AnPlusB_DISALLOW_SIGN);
            }
        } else {
            return null;
        }
    }

    if (offset > 0) {
        this.skip(offset);
    }

    if (sign === 0) {
        type = this.charCodeAt(this.tokenStart);
        if (type !== AnPlusB_PLUSSIGN && type !== AnPlusB_HYPHENMINUS) {
            this.error('Number sign is expected');
        }
    }

    checkTokenIsInteger.call(this, sign !== 0);
    return sign === AnPlusB_HYPHENMINUS ? '-' + this.consume(types_Number) : this.consume(types_Number);
}

// An+B microsyntax https://www.w3.org/TR/css-syntax-3/#anb
const AnPlusB_name = 'AnPlusB';
const structure = {
    a: [String, null],
    b: [String, null]
};

function AnPlusB_parse() {
    /* eslint-disable brace-style*/
    const start = this.tokenStart;
    let a = null;
    let b = null;

    // <integer>
    if (this.tokenType === types_Number) {
        checkTokenIsInteger.call(this, AnPlusB_ALLOW_SIGN);
        b = this.consume(types_Number);
    }

    // -n
    // -n <signed-integer>
    // -n ['+' | '-'] <signless-integer>
    // -n- <signless-integer>
    // <dashndashdigit-ident>
    else if (this.tokenType === Ident && this.cmpChar(this.tokenStart, AnPlusB_HYPHENMINUS)) {
        a = '-1';

        expectCharCode.call(this, 1, AnPlusB_N);

        switch (this.tokenEnd - this.tokenStart) {
            // -n
            // -n <signed-integer>
            // -n ['+' | '-'] <signless-integer>
            case 2:
                this.next();
                b = AnPlusB_consumeB.call(this);
                break;

            // -n- <signless-integer>
            case 3:
                expectCharCode.call(this, 2, AnPlusB_HYPHENMINUS);

                this.next();
                this.skipSC();

                checkTokenIsInteger.call(this, AnPlusB_DISALLOW_SIGN);

                b = '-' + this.consume(types_Number);
                break;

            // <dashndashdigit-ident>
            default:
                expectCharCode.call(this, 2, AnPlusB_HYPHENMINUS);
                AnPlusB_checkInteger.call(this, 3, AnPlusB_DISALLOW_SIGN);
                this.next();

                b = this.substrToCursor(start + 2);
        }
    }

    // '+'? n
    // '+'? n <signed-integer>
    // '+'? n ['+' | '-'] <signless-integer>
    // '+'? n- <signless-integer>
    // '+'? <ndashdigit-ident>
    else if (this.tokenType === Ident || (this.isDelim(AnPlusB_PLUSSIGN) && this.lookupType(1) === Ident)) {
        let sign = 0;
        a = '1';

        // just ignore a plus
        if (this.isDelim(AnPlusB_PLUSSIGN)) {
            sign = 1;
            this.next();
        }

        expectCharCode.call(this, 0, AnPlusB_N);

        switch (this.tokenEnd - this.tokenStart) {
            // '+'? n
            // '+'? n <signed-integer>
            // '+'? n ['+' | '-'] <signless-integer>
            case 1:
                this.next();
                b = AnPlusB_consumeB.call(this);
                break;

            // '+'? n- <signless-integer>
            case 2:
                expectCharCode.call(this, 1, AnPlusB_HYPHENMINUS);

                this.next();
                this.skipSC();

                checkTokenIsInteger.call(this, AnPlusB_DISALLOW_SIGN);

                b = '-' + this.consume(types_Number);
                break;

            // '+'? <ndashdigit-ident>
            default:
                expectCharCode.call(this, 1, AnPlusB_HYPHENMINUS);
                AnPlusB_checkInteger.call(this, 2, AnPlusB_DISALLOW_SIGN);
                this.next();

                b = this.substrToCursor(start + sign + 1);
        }
    }

    // <ndashdigit-dimension>
    // <ndash-dimension> <signless-integer>
    // <n-dimension>
    // <n-dimension> <signed-integer>
    // <n-dimension> ['+' | '-'] <signless-integer>
    else if (this.tokenType === Dimension) {
        const code = this.charCodeAt(this.tokenStart);
        const sign = code === AnPlusB_PLUSSIGN || code === AnPlusB_HYPHENMINUS;
        let i = this.tokenStart + sign;

        for (; i < this.tokenEnd; i++) {
            if (!isDigit(this.charCodeAt(i))) {
                break;
            }
        }

        if (i === this.tokenStart + sign) {
            this.error('Integer is expected', this.tokenStart + sign);
        }

        expectCharCode.call(this, i - this.tokenStart, AnPlusB_N);
        a = this.substring(start, i);

        // <n-dimension>
        // <n-dimension> <signed-integer>
        // <n-dimension> ['+' | '-'] <signless-integer>
        if (i + 1 === this.tokenEnd) {
            this.next();
            b = AnPlusB_consumeB.call(this);
        } else {
            expectCharCode.call(this, i - this.tokenStart + 1, AnPlusB_HYPHENMINUS);

            // <ndash-dimension> <signless-integer>
            if (i + 2 === this.tokenEnd) {
                this.next();
                this.skipSC();
                checkTokenIsInteger.call(this, AnPlusB_DISALLOW_SIGN);
                b = '-' + this.consume(types_Number);
            }
            // <ndashdigit-dimension>
            else {
                AnPlusB_checkInteger.call(this, i - this.tokenStart + 2, AnPlusB_DISALLOW_SIGN);
                this.next();
                b = this.substrToCursor(i + 1);
            }
        }
    } else {
        this.error();
    }

    if (a !== null && a.charCodeAt(0) === AnPlusB_PLUSSIGN) {
        a = a.substr(1);
    }

    if (b !== null && b.charCodeAt(0) === AnPlusB_PLUSSIGN) {
        b = b.substr(1);
    }

    return {
        type: 'AnPlusB',
        loc: this.getLocation(start, this.tokenStart),
        a,
        b
    };
}

function AnPlusB_generate(node) {
    if (node.a) {
        const a =
            node.a === '+1' && 'n' ||
            node.a ===  '1' && 'n' ||
            node.a === '-1' && '-n' ||
            node.a + 'n';

        if (node.b) {
            const b = node.b[0] === '-' || node.b[0] === '+'
                ? node.b
                : '+' + node.b;
            this.tokenize(a + b);
        } else {
            this.tokenize(a);
        }
    } else {
        this.tokenize(node.b);
    }
}

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/node/Atrule.js


function consumeRaw(startToken) {
    return this.Raw(startToken, this.consumeUntilLeftCurlyBracketOrSemicolon, true);
}

function isDeclarationBlockAtrule() {
    for (let offset = 1, type; type = this.lookupType(offset); offset++) {
        if (type === RightCurlyBracket) {
            return true;
        }

        if (type === LeftCurlyBracket ||
            type === AtKeyword) {
            return false;
        }
    }

    return false;
}


const Atrule_name = 'Atrule';
const walkContext = 'atrule';
const Atrule_structure = {
    name: String,
    prelude: ['AtrulePrelude', 'Raw', null],
    block: ['Block', null]
};

function Atrule_parse() {
    const start = this.tokenStart;
    let name;
    let nameLowerCase;
    let prelude = null;
    let block = null;

    this.eat(AtKeyword);

    name = this.substrToCursor(start + 1);
    nameLowerCase = name.toLowerCase();
    this.skipSC();

    // parse prelude
    if (this.eof === false &&
        this.tokenType !== LeftCurlyBracket &&
        this.tokenType !== Semicolon) {
        if (this.parseAtrulePrelude) {
            prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name), consumeRaw);
        } else {
            prelude = consumeRaw.call(this, this.tokenIndex);
        }

        this.skipSC();
    }

    switch (this.tokenType) {
        case Semicolon:
            this.next();
            break;

        case LeftCurlyBracket:
            if (hasOwnProperty.call(this.atrule, nameLowerCase) &&
                typeof this.atrule[nameLowerCase].block === 'function') {
                block = this.atrule[nameLowerCase].block.call(this);
            } else {
                // TODO: should consume block content as Raw?
                block = this.Block(isDeclarationBlockAtrule.call(this));
            }

            break;
    }

    return {
        type: 'Atrule',
        loc: this.getLocation(start, this.tokenStart),
        name,
        prelude,
        block
    };
}

function Atrule_generate(node) {
    this.token(AtKeyword, '@' + node.name);

    if (node.prelude !== null) {
        this.node(node.prelude);
    }

    if (node.block) {
        this.node(node.block);
    } else {
        this.token(Semicolon, ';');
    }
}

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/node/AtrulePrelude.js


const AtrulePrelude_name = 'AtrulePrelude';
const AtrulePrelude_walkContext = 'atrulePrelude';
const AtrulePrelude_structure = {
    children: [[]]
};

function AtrulePrelude_parse(name) {
    let children = null;

    if (name !== null) {
        name = name.toLowerCase();
    }

    this.skipSC();

    if (hasOwnProperty.call(this.atrule, name) &&
        typeof this.atrule[name].prelude === 'function') {
        // custom consumer
        children = this.atrule[name].prelude.call(this);
    } else {
        // default consumer
        children = this.readSequence(this.scope.AtrulePrelude);
    }

    this.skipSC();

    if (this.eof !== true &&
        this.tokenType !== LeftCurlyBracket &&
        this.tokenType !== Semicolon) {
        this.error('Semicolon or block is expected');
    }

    return {
        type: 'AtrulePrelude',
        loc: this.getLocationFromList(children),
        children
    };
}

function AtrulePrelude_generate(node) {
    this.children(node);
}

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/node/AttributeSelector.js


const DOLLARSIGN = 0x0024;       // U+0024 DOLLAR SIGN ($)
const AttributeSelector_ASTERISK = 0x002A;         // U+002A ASTERISK (*)
const EQUALSSIGN = 0x003D;       // U+003D EQUALS SIGN (=)
const CIRCUMFLEXACCENT = 0x005E; // U+005E (^)
const AttributeSelector_VERTICALLINE = 0x007C;     // U+007C VERTICAL LINE (|)
const TILDE = 0x007E;            // U+007E TILDE (~)

function getAttributeName() {
    if (this.eof) {
        this.error('Unexpected end of input');
    }

    const start = this.tokenStart;
    let expectIdent = false;

    if (this.isDelim(AttributeSelector_ASTERISK)) {
        expectIdent = true;
        this.next();
    } else if (!this.isDelim(AttributeSelector_VERTICALLINE)) {
        this.eat(Ident);
    }

    if (this.isDelim(AttributeSelector_VERTICALLINE)) {
        if (this.charCodeAt(this.tokenStart + 1) !== EQUALSSIGN) {
            this.next();
            this.eat(Ident);
        } else if (expectIdent) {
            this.error('Identifier is expected', this.tokenEnd);
        }
    } else if (expectIdent) {
        this.error('Vertical line is expected');
    }

    return {
        type: 'Identifier',
        loc: this.getLocation(start, this.tokenStart),
        name: this.substrToCursor(start)
    };
}

function getOperator() {
    const start = this.tokenStart;
    const code = this.charCodeAt(start);

    if (code !== EQUALSSIGN &&        // =
        code !== TILDE &&             // ~=
        code !== CIRCUMFLEXACCENT &&  // ^=
        code !== DOLLARSIGN &&        // $=
        code !== AttributeSelector_ASTERISK &&          // *=
        code !== AttributeSelector_VERTICALLINE         // |=
    ) {
        this.error('Attribute selector (=, ~=, ^=, $=, *=, |=) is expected');
    }

    this.next();

    if (code !== EQUALSSIGN) {
        if (!this.isDelim(EQUALSSIGN)) {
            this.error('Equal sign is expected');
        }

        this.next();
    }

    return this.substrToCursor(start);
}

// '[' <wq-name> ']'
// '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'
const AttributeSelector_name = 'AttributeSelector';
const AttributeSelector_structure = {
    name: 'Identifier',
    matcher: [String, null],
    value: ['String', 'Identifier', null],
    flags: [String, null]
};

function AttributeSelector_parse() {
    const start = this.tokenStart;
    let name;
    let matcher = null;
    let value = null;
    let flags = null;

    this.eat(LeftSquareBracket);
    this.skipSC();

    name = getAttributeName.call(this);
    this.skipSC();

    if (this.tokenType !== RightSquareBracket) {
        // avoid case `[name i]`
        if (this.tokenType !== Ident) {
            matcher = getOperator.call(this);

            this.skipSC();

            value = this.tokenType === types_String
                ? this.String()
                : this.Identifier();

            this.skipSC();
        }

        // attribute flags
        if (this.tokenType === Ident) {
            flags = this.consume(Ident);

            this.skipSC();
        }
    }

    this.eat(RightSquareBracket);

    return {
        type: 'AttributeSelector',
        loc: this.getLocation(start, this.tokenStart),
        name,
        matcher,
        value,
        flags
    };
}

function AttributeSelector_generate(node) {
    this.token(Delim, '[');
    this.node(node.name);

    if (node.matcher !== null) {
        this.tokenize(node.matcher);
        this.node(node.value);
    }

    if (node.flags !== null) {
        this.token(Ident, node.flags);
    }

    this.token(Delim, ']');
}

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/node/Block.js


function Block_consumeRaw(startToken) {
    return this.Raw(startToken, null, true);
}
function consumeRule() {
    return this.parseWithFallback(this.Rule, Block_consumeRaw);
}
function consumeRawDeclaration(startToken) {
    return this.Raw(startToken, this.consumeUntilSemicolonIncluded, true);
}
function consumeDeclaration() {
    if (this.tokenType === Semicolon) {
        return consumeRawDeclaration.call(this, this.tokenIndex);
    }

    const node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);

    if (this.tokenType === Semicolon) {
        this.next();
    }

    return node;
}

const Block_name = 'Block';
const Block_walkContext = 'block';
const Block_structure = {
    children: [[
        'Atrule',
        'Rule',
        'Declaration'
    ]]
};

function Block_parse(isDeclaration) {
    const consumer = isDeclaration ? consumeDeclaration : consumeRule;
    const start = this.tokenStart;
    let children = this.createList();

    this.eat(LeftCurlyBracket);

    scan:
    while (!this.eof) {
        switch (this.tokenType) {
            case RightCurlyBracket:
                break scan;

            case WhiteSpace:
            case Comment:
                this.next();
                break;

            case AtKeyword:
                children.push(this.parseWithFallback(this.Atrule, Block_consumeRaw));
                break;

            default:
                children.push(consumer.call(this));
        }
    }

    if (!this.eof) {
        this.eat(RightCurlyBracket);
    }

    return {
        type: 'Block',
        loc: this.getLocation(start, this.tokenStart),
        children
    };
}

function Block_generate(node) {
    this.token(LeftCurlyBracket, '{');
    this.children(node, prev => {
        if (prev.type === 'Declaration') {
            this.token(Semicolon, ';');
        }
    });
    this.token(RightCurlyBracket, '}');
}

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/node/Brackets.js


const Brackets_name = 'Brackets';
const Brackets_structure = {
    children: [[]]
};

function Brackets_parse(readSequence, recognizer) {
    const start = this.tokenStart;
    let children = null;

    this.eat(LeftSquareBracket);

    children = readSequence.call(this, recognizer);

    if (!this.eof) {
        this.eat(RightSquareBracket);
    }

    return {
        type: 'Brackets',
        loc: this.getLocation(start, this.tokenStart),
        children
    };
}

function Brackets_generate(node) {
    this.token(Delim, '[');
    this.children(node);
    this.token(Delim, ']');
}

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/node/CDC.js


const CDC_name = 'CDC';
const CDC_structure = [];

function CDC_parse() {
    const start = this.tokenStart;

    this.eat(CDC); // -->

    return {
        type: 'CDC',
        loc: this.getLocation(start, this.tokenStart)
    };
}

function CDC_generate() {
    this.token(CDC, '-->');
}

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/node/CDO.js


const CDO_name = 'CDO';
const CDO_structure = [];

function CDO_parse() {
    const start = this.tokenStart;

    this.eat(CDO); // <!--

    return {
        type: 'CDO',
        loc: this.getLocation(start, this.tokenStart)
    };
}

function CDO_generate() {
    this.token(CDO, '<!--');
}

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/node/ClassSelector.js


const FULLSTOP = 0x002E; // U+002E FULL STOP (.)

// '.' ident
const ClassSelector_name = 'ClassSelector';
const ClassSelector_structure = {
    name: String
};

function ClassSelector_parse() {
    this.eatDelim(FULLSTOP);

    return {
        type: 'ClassSelector',
        loc: this.getLocation(this.tokenStart - 1, this.tokenEnd),
        name: this.consume(Ident)
    };
}

function ClassSelector_generate(node) {
    this.token(Delim, '.');
    this.token(Ident, node.name);
}

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/node/Combinator.js


const Combinator_PLUSSIGN = 0x002B;        // U+002B PLUS SIGN (+)
const SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
const Combinator_GREATERTHANSIGN = 0x003E; // U+003E GREATER-THAN SIGN (>)
const Combinator_TILDE = 0x007E;           // U+007E TILDE (~)

const Combinator_name = 'Combinator';
const Combinator_structure = {
    name: String
};

// + | > | ~ | /deep/
function Combinator_parse() {
    const start = this.tokenStart;
    let name;

    switch (this.tokenType) {
        case WhiteSpace:
            name = ' ';
            break;

        case Delim:
            switch (this.charCodeAt(this.tokenStart)) {
                case Combinator_GREATERTHANSIGN:
                case Combinator_PLUSSIGN:
                case Combinator_TILDE:
                    this.next();
                    break;

                case SOLIDUS:
                    this.next();
                    this.eatIdent('deep');
                    this.eatDelim(SOLIDUS);
                    break;

                default:
                    this.error('Combinator is expected');
            }

            name = this.substrToCursor(start);
            break;
    }

    return {
        type: 'Combinator',
        loc: this.getLocation(start, this.tokenStart),
        name
    };
}

function Combinator_generate(node) {
    this.tokenize(node.name);
}

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/node/Comment.js


const Comment_ASTERISK = 0x002A;        // U+002A ASTERISK (*)
const Comment_SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)


const Comment_name = 'Comment';
const Comment_structure = {
    value: String
};

function Comment_parse() {
    const start = this.tokenStart;
    let end = this.tokenEnd;

    this.eat(Comment);

    if ((end - start + 2) >= 2 &&
        this.charCodeAt(end - 2) === Comment_ASTERISK &&
        this.charCodeAt(end - 1) === Comment_SOLIDUS) {
        end -= 2;
    }

    return {
        type: 'Comment',
        loc: this.getLocation(start, this.tokenStart),
        value: this.substring(start + 2, end)
    };
}

function Comment_generate(node) {
    this.token(Comment, '/*' + node.value + '*/');
}

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/node/Declaration.js



const Declaration_EXCLAMATIONMARK = 0x0021; // U+0021 EXCLAMATION MARK (!)
const Declaration_NUMBERSIGN = 0x0023;      // U+0023 NUMBER SIGN (#)
const Declaration_DOLLARSIGN = 0x0024;      // U+0024 DOLLAR SIGN ($)
const Declaration_AMPERSAND = 0x0026;       // U+0026 AMPERSAND (&)
const Declaration_ASTERISK = 0x002A;        // U+002A ASTERISK (*)
const Declaration_PLUSSIGN = 0x002B;        // U+002B PLUS SIGN (+)
const Declaration_SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)

function consumeValueRaw(startToken) {
    return this.Raw(startToken, this.consumeUntilExclamationMarkOrSemicolon, true);
}

function consumeCustomPropertyRaw(startToken) {
    return this.Raw(startToken, this.consumeUntilExclamationMarkOrSemicolon, false);
}

function consumeValue() {
    const startValueToken = this.tokenIndex;
    const value = this.Value();

    if (value.type !== 'Raw' &&
        this.eof === false &&
        this.tokenType !== Semicolon &&
        this.isDelim(Declaration_EXCLAMATIONMARK) === false &&
        this.isBalanceEdge(startValueToken) === false) {
        this.error();
    }

    return value;
}

const Declaration_name = 'Declaration';
const Declaration_walkContext = 'declaration';
const Declaration_structure = {
    important: [Boolean, String],
    property: String,
    value: ['Value', 'Raw']
};

function Declaration_parse() {
    const start = this.tokenStart;
    const startToken = this.tokenIndex;
    const property = Declaration_readProperty.call(this);
    const customProperty = isCustomProperty(property);
    const parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
    const consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
    let important = false;
    let value;

    this.skipSC();
    this.eat(Colon);

    const valueStart = this.tokenIndex;

    if (!customProperty) {
        this.skipSC();
    }

    if (parseValue) {
        value = this.parseWithFallback(consumeValue, consumeRaw);
    } else {
        value = consumeRaw.call(this, this.tokenIndex);
    }

    if (customProperty && value.type === 'Value' && value.children.isEmpty) {
        for (let offset = valueStart - this.tokenIndex; offset <= 0; offset++) {
            if (this.lookupType(offset) === WhiteSpace) {
                value.children.appendData({
                    type: 'WhiteSpace',
                    loc: null,
                    value: ' '
                });
                break;
            }
        }
    }

    if (this.isDelim(Declaration_EXCLAMATIONMARK)) {
        important = getImportant.call(this);
        this.skipSC();
    }

    // Do not include semicolon to range per spec
    // https://drafts.csswg.org/css-syntax/#declaration-diagram

    if (this.eof === false &&
        this.tokenType !== Semicolon &&
        this.isBalanceEdge(startToken) === false) {
        this.error();
    }

    return {
        type: 'Declaration',
        loc: this.getLocation(start, this.tokenStart),
        important,
        property,
        value
    };
}

function Declaration_generate(node) {
    this.token(Ident, node.property);
    this.token(Colon, ':');
    this.node(node.value);

    if (node.important) {
        this.token(Delim, '!');
        this.token(Ident, node.important === true ? 'important' : node.important);
    }
}

function Declaration_readProperty() {
    const start = this.tokenStart;

    // hacks
    if (this.tokenType === Delim) {
        switch (this.charCodeAt(this.tokenStart)) {
            case Declaration_ASTERISK:
            case Declaration_DOLLARSIGN:
            case Declaration_PLUSSIGN:
            case Declaration_NUMBERSIGN:
            case Declaration_AMPERSAND:
                this.next();
                break;

            // TODO: not sure we should support this hack
            case Declaration_SOLIDUS:
                this.next();
                if (this.isDelim(Declaration_SOLIDUS)) {
                    this.next();
                }
                break;
        }
    }

    if (this.tokenType === Hash) {
        this.eat(Hash);
    } else {
        this.eat(Ident);
    }

    return this.substrToCursor(start);
}

// ! ws* important
function getImportant() {
    this.eat(Delim);
    this.skipSC();

    const important = this.consume(Ident);

    // store original value in case it differ from `important`
    // for better original source restoring and hacks like `!ie` support
    return important === 'important' ? true : important;
}

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/node/DeclarationList.js


function DeclarationList_consumeRaw(startToken) {
    return this.Raw(startToken, this.consumeUntilSemicolonIncluded, true);
}

const DeclarationList_name = 'DeclarationList';
const DeclarationList_structure = {
    children: [[
        'Declaration'
    ]]
};

function DeclarationList_parse() {
    const children = this.createList();

    scan:
    while (!this.eof) {
        switch (this.tokenType) {
            case WhiteSpace:
            case Comment:
            case Semicolon:
                this.next();
                break;

            default:
                children.push(this.parseWithFallback(this.Declaration, DeclarationList_consumeRaw));
        }
    }

    return {
        type: 'DeclarationList',
        loc: this.getLocationFromList(children),
        children
    };
}

function DeclarationList_generate(node) {
    this.children(node, prev => {
        if (prev.type === 'Declaration') {
            this.token(Semicolon, ';');
        }
    });
}


;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/node/Dimension.js


const Dimension_name = 'Dimension';
const Dimension_structure = {
    value: String,
    unit: String
};

function Dimension_parse() {
    const start = this.tokenStart;
    const value = this.consumeNumber(Dimension);

    return {
        type: 'Dimension',
        loc: this.getLocation(start, this.tokenStart),
        value,
        unit: this.substring(start + value.length, this.tokenStart)
    };
}

function Dimension_generate(node) {
    this.token(Dimension, node.value + node.unit);
}

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/node/Function.js



const Function_name = 'Function';
const Function_walkContext = 'function';
const Function_structure = {
    name: String,
    children: [[]]
};

// <function-token> <sequence> )
function Function_parse(readSequence, recognizer) {
    const start = this.tokenStart;
    const name = this.consumeFunctionName();
    const nameLowerCase = name.toLowerCase();
    let children;

    children = recognizer.hasOwnProperty(nameLowerCase)
        ? recognizer[nameLowerCase].call(this, recognizer)
        : readSequence.call(this, recognizer);

    if (!this.eof) {
        this.eat(RightParenthesis);
    }

    return {
        type: 'Function',
        loc: this.getLocation(start, this.tokenStart),
        name,
        children
    };
}

function Function_generate(node) {
    this.token(types_Function, node.name + '(');
    this.children(node);
    this.token(RightParenthesis, ')');
}

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/node/Hash.js


// '#' ident
const xxx = 'XXX';
const Hash_name = 'Hash';
const Hash_structure = {
    value: String
};
function Hash_parse() {
    const start = this.tokenStart;

    this.eat(Hash);

    return {
        type: 'Hash',
        loc: this.getLocation(start, this.tokenStart),
        value: this.substrToCursor(start + 1)
    };
}
function Hash_generate(node) {
    this.token(Hash, '#' + node.value);
}


;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/node/Identifier.js


const Identifier_name = 'Identifier';
const Identifier_structure = {
    name: String
};

function Identifier_parse() {
    return {
        type: 'Identifier',
        loc: this.getLocation(this.tokenStart, this.tokenEnd),
        name: this.consume(Ident)
    };
}

function Identifier_generate(node) {
    this.token(Ident, node.name);
}

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/node/IdSelector.js


const IdSelector_name = 'IdSelector';
const IdSelector_structure = {
    name: String
};

function IdSelector_parse() {
    const start = this.tokenStart;

    // TODO: check value is an ident
    this.eat(Hash);

    return {
        type: 'IdSelector',
        loc: this.getLocation(start, this.tokenStart),
        name: this.substrToCursor(start + 1)
    };
}

function IdSelector_generate(node) {
    // Using Delim instead of Hash is a hack to avoid for a whitespace between ident and id-selector
    // in safe mode (e.g. "a#id"), because IE11 doesn't allow a sequence <ident-token> <hash-token>
    // without a whitespace in values (e.g. "1px solid#000")
    this.token(Delim, '#' + node.name);
}

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/node/MediaFeature.js


const MediaFeature_name = 'MediaFeature';
const MediaFeature_structure = {
    name: String,
    value: ['Identifier', 'Number', 'Dimension', 'Ratio', null]
};

function MediaFeature_parse() {
    const start = this.tokenStart;
    let name;
    let value = null;

    this.eat(LeftParenthesis);
    this.skipSC();

    name = this.consume(Ident);
    this.skipSC();

    if (this.tokenType !== RightParenthesis) {
        this.eat(Colon);
        this.skipSC();

        switch (this.tokenType) {
            case types_Number:
                if (this.lookupNonWSType(1) === Delim) {
                    value = this.Ratio();
                } else {
                    value = this.Number();
                }

                break;

            case Dimension:
                value = this.Dimension();
                break;

            case Ident:
                value = this.Identifier();
                break;

            default:
                this.error('Number, dimension, ratio or identifier is expected');
        }

        this.skipSC();
    }

    this.eat(RightParenthesis);

    return {
        type: 'MediaFeature',
        loc: this.getLocation(start, this.tokenStart),
        name,
        value
    };
}

function MediaFeature_generate(node) {
    this.token(LeftParenthesis, '(');
    this.token(Ident, node.name);

    if (node.value !== null) {
        this.token(Colon, ':');
        this.node(node.value);
    }

    this.token(RightParenthesis, ')');
}

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/node/MediaQuery.js


const MediaQuery_name = 'MediaQuery';
const MediaQuery_structure = {
    children: [[
        'Identifier',
        'MediaFeature',
        'WhiteSpace'
    ]]
};

function MediaQuery_parse() {
    const children = this.createList();
    let child = null;

    this.skipSC();

    scan:
    while (!this.eof) {
        switch (this.tokenType) {
            case Comment:
            case WhiteSpace:
                this.next();
                continue;

            case Ident:
                child = this.Identifier();
                break;

            case LeftParenthesis:
                child = this.MediaFeature();
                break;

            default:
                break scan;
        }

        children.push(child);
    }

    if (child === null) {
        this.error('Identifier or parenthesis is expected');
    }

    return {
        type: 'MediaQuery',
        loc: this.getLocationFromList(children),
        children
    };
}

function MediaQuery_generate(node) {
    this.children(node);
}


;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/node/MediaQueryList.js


const MediaQueryList_name = 'MediaQueryList';
const MediaQueryList_structure = {
    children: [[
        'MediaQuery'
    ]]
};

function MediaQueryList_parse() {
    const children = this.createList();

    this.skipSC();

    while (!this.eof) {
        children.push(this.MediaQuery());

        if (this.tokenType !== Comma) {
            break;
        }

        this.next();
    }

    return {
        type: 'MediaQueryList',
        loc: this.getLocationFromList(children),
        children
    };
}

function MediaQueryList_generate(node) {
    this.children(node, () => this.token(Comma, ','));
}

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/node/Nth.js


const Nth_name = 'Nth';
const Nth_structure = {
    nth: ['AnPlusB', 'Identifier'],
    selector: ['SelectorList', null]
};

function Nth_parse() {
    this.skipSC();

    const start = this.tokenStart;
    let end = start;
    let selector = null;
    let nth;

    if (this.lookupValue(0, 'odd') || this.lookupValue(0, 'even')) {
        nth = this.Identifier();
    } else {
        nth = this.AnPlusB();
    }

    end = this.tokenStart;
    this.skipSC();

    if (this.lookupValue(0, 'of')) {
        this.next();

        selector = this.SelectorList();
        end = this.tokenStart;
    }

    return {
        type: 'Nth',
        loc: this.getLocation(start, end),
        nth,
        selector
    };
}

function Nth_generate(node) {
    this.node(node.nth);
    if (node.selector !== null) {
        this.token(Ident, 'of');
        this.node(node.selector);
    }
}

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/node/Number.js


const Number_name = 'Number';
const Number_structure = {
    value: String
};

function Number_parse() {
    return {
        type: 'Number',
        loc: this.getLocation(this.tokenStart, this.tokenEnd),
        value: this.consume(types_Number)
    };
}

function Number_generate(node) {
    this.token(types_Number, node.value);
}

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/node/Operator.js
// '/' | '*' | ',' | ':' | '+' | '-'
const Operator_name = 'Operator';
const Operator_structure = {
    value: String
};

function Operator_parse() {
    const start = this.tokenStart;

    this.next();

    return {
        type: 'Operator',
        loc: this.getLocation(start, this.tokenStart),
        value: this.substrToCursor(start)
    };
}

function Operator_generate(node) {
    this.tokenize(node.value);
}

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/node/Parentheses.js


const Parentheses_name = 'Parentheses';
const Parentheses_structure = {
    children: [[]]
};

function Parentheses_parse(readSequence, recognizer) {
    const start = this.tokenStart;
    let children = null;

    this.eat(LeftParenthesis);

    children = readSequence.call(this, recognizer);

    if (!this.eof) {
        this.eat(RightParenthesis);
    }

    return {
        type: 'Parentheses',
        loc: this.getLocation(start, this.tokenStart),
        children
    };
}

function Parentheses_generate(node) {
    this.token(LeftParenthesis, '(');
    this.children(node);
    this.token(RightParenthesis, ')');
}

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/node/Percentage.js


const Percentage_name = 'Percentage';
const Percentage_structure = {
    value: String
};

function Percentage_parse() {
    return {
        type: 'Percentage',
        loc: this.getLocation(this.tokenStart, this.tokenEnd),
        value: this.consumeNumber(Percentage)
    };
}

function Percentage_generate(node) {
    this.token(Percentage, node.value + '%');
}

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/node/PseudoClassSelector.js



const PseudoClassSelector_name = 'PseudoClassSelector';
const PseudoClassSelector_walkContext = 'function';
const PseudoClassSelector_structure = {
    name: String,
    children: [['Raw'], null]
};

// : [ <ident> | <function-token> <any-value>? ) ]
function PseudoClassSelector_parse() {
    const start = this.tokenStart;
    let children = null;
    let name;
    let nameLowerCase;

    this.eat(Colon);

    if (this.tokenType === types_Function) {
        name = this.consumeFunctionName();
        nameLowerCase = name.toLowerCase();

        if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {
            this.skipSC();
            children = this.pseudo[nameLowerCase].call(this);
            this.skipSC();
        } else {
            children = this.createList();
            children.push(
                this.Raw(this.tokenIndex, null, false)
            );
        }

        this.eat(RightParenthesis);
    } else {
        name = this.consume(Ident);
    }

    return {
        type: 'PseudoClassSelector',
        loc: this.getLocation(start, this.tokenStart),
        name,
        children
    };
}

function PseudoClassSelector_generate(node) {
    this.token(Colon, ':');

    if (node.children === null) {
        this.token(Ident, node.name);
    } else {
        this.token(types_Function, node.name + '(');
        this.children(node);
        this.token(RightParenthesis, ')');
    }
}

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/node/PseudoElementSelector.js


const PseudoElementSelector_name = 'PseudoElementSelector';
const PseudoElementSelector_walkContext = 'function';
const PseudoElementSelector_structure = {
    name: String,
    children: [['Raw'], null]
};

// :: [ <ident> | <function-token> <any-value>? ) ]
function PseudoElementSelector_parse() {
    const start = this.tokenStart;
    let children = null;
    let name;
    let nameLowerCase;

    this.eat(Colon);
    this.eat(Colon);

    if (this.tokenType === types_Function) {
        name = this.consumeFunctionName();
        nameLowerCase = name.toLowerCase();

        if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {
            this.skipSC();
            children = this.pseudo[nameLowerCase].call(this);
            this.skipSC();
        } else {
            children = this.createList();
            children.push(
                this.Raw(this.tokenIndex, null, false)
            );
        }

        this.eat(RightParenthesis);
    } else {
        name = this.consume(Ident);
    }

    return {
        type: 'PseudoElementSelector',
        loc: this.getLocation(start, this.tokenStart),
        name,
        children
    };
}

function PseudoElementSelector_generate(node) {
    this.token(Colon, ':');
    this.token(Colon, ':');

    if (node.children === null) {
        this.token(Ident, node.name);
    } else {
        this.token(types_Function, node.name + '(');
        this.children(node);
        this.token(RightParenthesis, ')');
    }
}

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/node/Ratio.js


const Ratio_SOLIDUS = 0x002F;  // U+002F SOLIDUS (/)
const Ratio_FULLSTOP = 0x002E; // U+002E FULL STOP (.)

// Terms of <ratio> should be a positive numbers (not zero or negative)
// (see https://drafts.csswg.org/mediaqueries-3/#values)
// However, -o-min-device-pixel-ratio takes fractional values as a ratio's term
// and this is using by various sites. Therefore we relax checking on parse
// to test a term is unsigned number without an exponent part.
// Additional checking may be applied on lexer validation.
function Ratio_consumeNumber() {
    this.skipSC();

    const value = this.consume(types_Number);

    for (let i = 0; i < value.length; i++) {
        const code = value.charCodeAt(i);
        if (!isDigit(code) && code !== Ratio_FULLSTOP) {
            this.error('Unsigned number is expected', this.tokenStart - value.length + i);
        }
    }

    if (Number(value) === 0) {
        this.error('Zero number is not allowed', this.tokenStart - value.length);
    }

    return value;
}

const Ratio_name = 'Ratio';
const Ratio_structure = {
    left: String,
    right: String
};

// <positive-integer> S* '/' S* <positive-integer>
function Ratio_parse() {
    const start = this.tokenStart;
    const left = Ratio_consumeNumber.call(this);
    let right;

    this.skipSC();
    this.eatDelim(Ratio_SOLIDUS);
    right = Ratio_consumeNumber.call(this);

    return {
        type: 'Ratio',
        loc: this.getLocation(start, this.tokenStart),
        left,
        right
    };
}

function Ratio_generate(node) {
    this.token(types_Number, node.left);
    this.token(Delim, '/');
    this.token(types_Number, node.right);
}

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/node/Raw.js


function getOffsetExcludeWS() {
    if (this.tokenIndex > 0) {
        if (this.lookupType(-1) === WhiteSpace) {
            return this.tokenIndex > 1
                ? this.getTokenStart(this.tokenIndex - 1)
                : this.firstCharOffset;
        }
    }

    return this.tokenStart;
}

const Raw_name = 'Raw';
const Raw_structure = {
    value: String
};

function Raw_parse(startToken, consumeUntil, excludeWhiteSpace) {
    const startOffset = this.getTokenStart(startToken);
    let endOffset;

    this.skipUntilBalanced(startToken, consumeUntil || this.consumeUntilBalanceEnd);

    if (excludeWhiteSpace && this.tokenStart > startOffset) {
        endOffset = getOffsetExcludeWS.call(this);
    } else {
        endOffset = this.tokenStart;
    }

    return {
        type: 'Raw',
        loc: this.getLocation(startOffset, endOffset),
        value: this.substring(startOffset, endOffset)
    };
}

function Raw_generate(node) {
    this.tokenize(node.value);
}

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/node/Rule.js


function Rule_consumeRaw(startToken) {
    return this.Raw(startToken, this.consumeUntilLeftCurlyBracket, true);
}

function consumePrelude() {
    const prelude = this.SelectorList();

    if (prelude.type !== 'Raw' &&
        this.eof === false &&
        this.tokenType !== LeftCurlyBracket) {
        this.error();
    }

    return prelude;
}

const Rule_name = 'Rule';
const Rule_walkContext = 'rule';
const Rule_structure = {
    prelude: ['SelectorList', 'Raw'],
    block: ['Block']
};

function Rule_parse() {
    const startToken = this.tokenIndex;
    const startOffset = this.tokenStart;
    let prelude;
    let block;

    if (this.parseRulePrelude) {
        prelude = this.parseWithFallback(consumePrelude, Rule_consumeRaw);
    } else {
        prelude = Rule_consumeRaw.call(this, startToken);
    }

    block = this.Block(true);

    return {
        type: 'Rule',
        loc: this.getLocation(startOffset, this.tokenStart),
        prelude,
        block
    };
}
function Rule_generate(node) {
    this.node(node.prelude);
    this.node(node.block);
}


;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/node/Selector.js
const Selector_name = 'Selector';
const Selector_structure = {
    children: [[
        'TypeSelector',
        'IdSelector',
        'ClassSelector',
        'AttributeSelector',
        'PseudoClassSelector',
        'PseudoElementSelector',
        'Combinator',
        'WhiteSpace'
    ]]
};

function Selector_parse() {
    const children = this.readSequence(this.scope.Selector);

    // nothing were consumed
    if (this.getFirstListNode(children) === null) {
        this.error('Selector is expected');
    }

    return {
        type: 'Selector',
        loc: this.getLocationFromList(children),
        children
    };
}

function Selector_generate(node) {
    this.children(node);
}

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/node/SelectorList.js


const SelectorList_name = 'SelectorList';
const SelectorList_walkContext = 'selector';
const SelectorList_structure = {
    children: [[
        'Selector',
        'Raw'
    ]]
};

function SelectorList_parse() {
    const children = this.createList();

    while (!this.eof) {
        children.push(this.Selector());

        if (this.tokenType === Comma) {
            this.next();
            continue;
        }

        break;
    }

    return {
        type: 'SelectorList',
        loc: this.getLocationFromList(children),
        children
    };
}

function SelectorList_generate(node) {
    this.children(node, () => this.token(Comma, ','));
}

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/utils/string.js


const REVERSE_SOLIDUS = 0x005c; // U+005C REVERSE SOLIDUS (\)
const QUOTATION_MARK = 0x0022;  // "
const string_APOSTROPHE = 0x0027;      // '

function decode(str) {
    const len = str.length;
    const firstChar = str.charCodeAt(0);
    const start = firstChar === QUOTATION_MARK || firstChar === string_APOSTROPHE ? 1 : 0;
    const end = start === 1 && len > 1 && str.charCodeAt(len - 1) === firstChar ? len - 2 : len - 1;
    let decoded = '';

    for (let i = start; i <= end; i++) {
        let code = str.charCodeAt(i);

        if (code === REVERSE_SOLIDUS) {
            // special case at the ending
            if (i === end) {
                // if the next input code point is EOF, do nothing
                // otherwise include last quote as escaped
                if (i !== len - 1) {
                    decoded = str.substr(i + 1);
                }
                break;
            }

            code = str.charCodeAt(++i);

            // consume escaped
            if (char_code_definitions_isValidEscape(REVERSE_SOLIDUS, code)) {
                const escapeStart = i - 1;
                const escapeEnd = utils_consumeEscaped(str, escapeStart);

                i = escapeEnd - 1;
                decoded += utils_decodeEscaped(str.substring(escapeStart + 1, escapeEnd));
            } else {
                // \r\n
                if (code === 0x000d && str.charCodeAt(i + 1) === 0x000a) {
                    i++;
                }
            }
        } else {
            decoded += str[i];
        }
    }

    return decoded;
}

// https://drafts.csswg.org/cssom/#serialize-a-string
//  2.1. Common Serializing Idioms
function encode(str, apostrophe) {
    const quote = apostrophe ? '\'' : '"';
    const quoteCode = apostrophe ? string_APOSTROPHE : QUOTATION_MARK;
    let encoded = '';
    let wsBeforeHexIsNeeded = false;

    for (let i = 0; i < str.length; i++) {
        const code = str.charCodeAt(i);

        // If the character is NULL (U+0000), then the REPLACEMENT CHARACTER (U+FFFD).
        if (code === 0x0000) {
            encoded += '\uFFFD';
            continue;
        }

        // If the character is in the range [\1-\1f] (U+0001 to U+001F) or is U+007F,
        // the character escaped as code point.
        // Note: Do not compare with 0x0001 since 0x0000 is precessed before
        if (code <= 0x001f || code === 0x007F) {
            encoded += '\\' + code.toString(16);
            wsBeforeHexIsNeeded = true;
            continue;
        }

        // If the character is '"' (U+0022) or "\" (U+005C), the escaped character.
        if (code === quoteCode || code === REVERSE_SOLIDUS) {
            encoded += '\\' + str.charAt(i);
            wsBeforeHexIsNeeded = false;
        } else {
            if (wsBeforeHexIsNeeded && (isHexDigit(code) || isWhiteSpace(code))) {
                encoded += ' ';
            }

            // Otherwise, the character itself.
            encoded += str.charAt(i);
            wsBeforeHexIsNeeded = false;
        }
    }

    return quote + encoded + quote;
}

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/node/String.js



const String_name = 'String';
const String_structure = {
    value: String
};

function String_parse() {
    return {
        type: 'String',
        loc: this.getLocation(this.tokenStart, this.tokenEnd),
        value: decode(this.consume(types_String))
    };
}

function String_generate(node) {
    this.token(types_String, encode(node.value));
}

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/node/StyleSheet.js


const StyleSheet_EXCLAMATIONMARK = 0x0021; // U+0021 EXCLAMATION MARK (!)

function StyleSheet_consumeRaw(startToken) {
    return this.Raw(startToken, null, false);
}

const StyleSheet_name = 'StyleSheet';
const StyleSheet_walkContext = 'stylesheet';
const StyleSheet_structure = {
    children: [[
        'Comment',
        'CDO',
        'CDC',
        'Atrule',
        'Rule',
        'Raw'
    ]]
};

function StyleSheet_parse() {
    const start = this.tokenStart;
    const children = this.createList();
    let child;

    scan:
    while (!this.eof) {
        switch (this.tokenType) {
            case WhiteSpace:
                this.next();
                continue;

            case Comment:
                // ignore comments except exclamation comments (i.e. /*! .. */) on top level
                if (this.charCodeAt(this.tokenStart + 2) !== StyleSheet_EXCLAMATIONMARK) {
                    this.next();
                    continue;
                }

                child = this.Comment();
                break;

            case CDO: // <!--
                child = this.CDO();
                break;

            case CDC: // -->
                child = this.CDC();
                break;

            // CSS Syntax Module Level 3
            // 2.2 Error handling
            // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
            case AtKeyword:
                child = this.parseWithFallback(this.Atrule, StyleSheet_consumeRaw);
                break;

            // Anything else starts a qualified rule ...
            default:
                child = this.parseWithFallback(this.Rule, StyleSheet_consumeRaw);
        }

        children.push(child);
    }

    return {
        type: 'StyleSheet',
        loc: this.getLocation(start, this.tokenStart),
        children
    };
}

function StyleSheet_generate(node) {
    this.children(node);
}

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/node/TypeSelector.js


const TypeSelector_ASTERISK = 0x002A;     // U+002A ASTERISK (*)
const TypeSelector_VERTICALLINE = 0x007C; // U+007C VERTICAL LINE (|)

function eatIdentifierOrAsterisk() {
    if (this.tokenType !== Ident &&
        this.isDelim(TypeSelector_ASTERISK) === false) {
        this.error('Identifier or asterisk is expected');
    }

    this.next();
}

const TypeSelector_name = 'TypeSelector';
const TypeSelector_structure = {
    name: String
};

// ident
// ident|ident
// ident|*
// *
// *|ident
// *|*
// |ident
// |*
function TypeSelector_parse() {
    const start = this.tokenStart;

    if (this.isDelim(TypeSelector_VERTICALLINE)) {
        this.next();
        eatIdentifierOrAsterisk.call(this);
    } else {
        eatIdentifierOrAsterisk.call(this);

        if (this.isDelim(TypeSelector_VERTICALLINE)) {
            this.next();
            eatIdentifierOrAsterisk.call(this);
        }
    }

    return {
        type: 'TypeSelector',
        loc: this.getLocation(start, this.tokenStart),
        name: this.substrToCursor(start)
    };
}

function TypeSelector_generate(node) {
    this.tokenize(node.name);
}

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/node/UnicodeRange.js


const UnicodeRange_PLUSSIGN = 0x002B;     // U+002B PLUS SIGN (+)
const UnicodeRange_HYPHENMINUS = 0x002D;  // U+002D HYPHEN-MINUS (-)
const UnicodeRange_QUESTIONMARK = 0x003F; // U+003F QUESTION MARK (?)

function eatHexSequence(offset, allowDash) {
    let len = 0;

    for (let pos = this.tokenStart + offset; pos < this.tokenEnd; pos++) {
        const code = this.charCodeAt(pos);

        if (code === UnicodeRange_HYPHENMINUS && allowDash && len !== 0) {
            eatHexSequence.call(this, offset + len + 1, false);
            return -1;
        }

        if (!isHexDigit(code)) {
            this.error(
                allowDash && len !== 0
                    ? 'Hyphen minus' + (len < 6 ? ' or hex digit' : '') + ' is expected'
                    : (len < 6 ? 'Hex digit is expected' : 'Unexpected input'),
                pos
            );
        }

        if (++len > 6) {
            this.error('Too many hex digits', pos);
        };
    }

    this.next();
    return len;
}

function eatQuestionMarkSequence(max) {
    let count = 0;

    while (this.isDelim(UnicodeRange_QUESTIONMARK)) {
        if (++count > max) {
            this.error('Too many question marks');
        }

        this.next();
    }
}

function UnicodeRange_startsWith(code) {
    if (this.charCodeAt(this.tokenStart) !== code) {
        this.error((code === UnicodeRange_PLUSSIGN ? 'Plus sign' : 'Hyphen minus') + ' is expected');
    }
}

// https://drafts.csswg.org/css-syntax/#urange
// Informally, the <urange> production has three forms:
// U+0001
//      Defines a range consisting of a single code point, in this case the code point "1".
// U+0001-00ff
//      Defines a range of codepoints between the first and the second value, in this case
//      the range between "1" and "ff" (255 in decimal) inclusive.
// U+00??
//      Defines a range of codepoints where the "?" characters range over all hex digits,
//      in this case defining the same as the value U+0000-00ff.
// In each form, a maximum of 6 digits is allowed for each hexadecimal number (if you treat "?" as a hexadecimal digit).
//
// <urange> =
//   u '+' <ident-token> '?'* |
//   u <dimension-token> '?'* |
//   u <number-token> '?'* |
//   u <number-token> <dimension-token> |
//   u <number-token> <number-token> |
//   u '+' '?'+
function scanUnicodeRange() {
    let hexLength = 0;

    switch (this.tokenType) {
        case types_Number:
            // u <number-token> '?'*
            // u <number-token> <dimension-token>
            // u <number-token> <number-token>
            hexLength = eatHexSequence.call(this, 1, true);

            if (this.isDelim(UnicodeRange_QUESTIONMARK)) {
                eatQuestionMarkSequence.call(this, 6 - hexLength);
                break;
            }

            if (this.tokenType === Dimension ||
                this.tokenType === types_Number) {
                UnicodeRange_startsWith.call(this, UnicodeRange_HYPHENMINUS);
                eatHexSequence.call(this, 1, false);
                break;
            }

            break;

        case Dimension:
            // u <dimension-token> '?'*
            hexLength = eatHexSequence.call(this, 1, true);

            if (hexLength > 0) {
                eatQuestionMarkSequence.call(this, 6 - hexLength);
            }

            break;

        default:
            // u '+' <ident-token> '?'*
            // u '+' '?'+
            this.eatDelim(UnicodeRange_PLUSSIGN);

            if (this.tokenType === Ident) {
                hexLength = eatHexSequence.call(this, 0, true);
                if (hexLength > 0) {
                    eatQuestionMarkSequence.call(this, 6 - hexLength);
                }
                break;
            }

            if (this.isDelim(UnicodeRange_QUESTIONMARK)) {
                this.next();
                eatQuestionMarkSequence.call(this, 5);
                break;
            }

            this.error('Hex digit or question mark is expected');
    }
}

const UnicodeRange_name = 'UnicodeRange';
const UnicodeRange_structure = {
    value: String
};

function UnicodeRange_parse() {
    const start = this.tokenStart;

    // U or u
    this.eatIdent('u');
    scanUnicodeRange.call(this);

    return {
        type: 'UnicodeRange',
        loc: this.getLocation(start, this.tokenStart),
        value: this.substrToCursor(start)
    };
}

function UnicodeRange_generate(node) {
    this.tokenize(node.value);
}

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/utils/url.js


const url_SPACE = 0x0020;            // U+0020 SPACE
const url_REVERSE_SOLIDUS = 0x005c;  // U+005C REVERSE SOLIDUS (\)
const url_QUOTATION_MARK = 0x0022;   // "
const url_APOSTROPHE = 0x0027;       // '
const url_LEFTPARENTHESIS = 0x0028;  // U+0028 LEFT PARENTHESIS (()
const url_RIGHTPARENTHESIS = 0x0029; // U+0029 RIGHT PARENTHESIS ())

function url_decode(str) {
    const len = str.length;
    let start = 4; // length of "url("
    let end = str.charCodeAt(len - 1) === url_RIGHTPARENTHESIS ? len - 2 : len - 1;
    let decoded = '';

    while (start < end && isWhiteSpace(str.charCodeAt(start))) {
        start++;
    }

    while (start < end && isWhiteSpace(str.charCodeAt(end))) {
        end--;
    }

    for (let i = start; i <= end; i++) {
        let code = str.charCodeAt(i);

        if (code === url_REVERSE_SOLIDUS) {
            // special case at the ending
            if (i === end) {
                // if the next input code point is EOF, do nothing
                // otherwise include last left parenthesis as escaped
                if (i !== len - 1) {
                    decoded = str.substr(i + 1);
                }
                break;
            }

            code = str.charCodeAt(++i);

            // consume escaped
            if (char_code_definitions_isValidEscape(url_REVERSE_SOLIDUS, code)) {
                const escapeStart = i - 1;
                const escapeEnd = utils_consumeEscaped(str, escapeStart);

                i = escapeEnd - 1;
                decoded += utils_decodeEscaped(str.substring(escapeStart + 1, escapeEnd));
            } else {
                // \r\n
                if (code === 0x000d && str.charCodeAt(i + 1) === 0x000a) {
                    i++;
                }
            }
        } else {
            decoded += str[i];
        }
    }

    return decoded;
}

function url_encode(str) {
    let encoded = '';
    let wsBeforeHexIsNeeded = false;

    for (let i = 0; i < str.length; i++) {
        const code = str.charCodeAt(i);

        // If the character is NULL (U+0000), then the REPLACEMENT CHARACTER (U+FFFD).
        if (code === 0x0000) {
            encoded += '\uFFFD';
            continue;
        }

        // If the character is in the range [\1-\1f] (U+0001 to U+001F) or is U+007F,
        // the character escaped as code point.
        // Note: Do not compare with 0x0001 since 0x0000 is precessed before
        if (code <= 0x001f || code === 0x007F) {
            encoded += '\\' + code.toString(16);
            wsBeforeHexIsNeeded = true;
            continue;
        }

        if (code === url_SPACE ||
            code === url_REVERSE_SOLIDUS ||
            code === url_QUOTATION_MARK ||
            code === url_APOSTROPHE ||
            code === url_LEFTPARENTHESIS ||
            code === url_RIGHTPARENTHESIS) {
            encoded += '\\' + str.charAt(i);
            wsBeforeHexIsNeeded = false;
        } else {
            if (wsBeforeHexIsNeeded && isHexDigit(code)) {
                encoded += ' ';
            }

            encoded += str.charAt(i);
            wsBeforeHexIsNeeded = false;
        }
    }

    return 'url(' + encoded + ')';
}

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/node/Url.js




const Url_name = 'Url';
const Url_structure = {
    value: String
};

// <url-token> | <function-token> <string> )
function Url_parse() {
    const start = this.tokenStart;
    let value;

    switch (this.tokenType) {
        case Url:
            value = url_decode(this.consume(Url));
            break;

        case types_Function:
            if (!this.cmpStr(this.tokenStart, this.tokenEnd, 'url(')) {
                this.error('Function name must be `url`');
            }

            this.eat(types_Function);
            this.skipSC();
            value = decode(this.consume(types_String));
            this.skipSC();
            if (!this.eof) {
                this.eat(RightParenthesis);
            }
            break;

        default:
            this.error('Url or Function is expected');
    }

    return {
        type: 'Url',
        loc: this.getLocation(start, this.tokenStart),
        value
    };
}

function Url_generate(node) {
    this.token(Url, url_encode(node.value));
}

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/node/Value.js
const Value_name = 'Value';
const Value_structure = {
    children: [[]]
};

function Value_parse() {
    const start = this.tokenStart;
    const children = this.readSequence(this.scope.Value);

    return {
        type: 'Value',
        loc: this.getLocation(start, this.tokenStart),
        children
    };
}

function Value_generate(node) {
    this.children(node);
}

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/node/WhiteSpace.js


const WhiteSpace_SPACE = Object.freeze({
    type: 'WhiteSpace',
    loc: null,
    value: ' '
});

const WhiteSpace_name = 'WhiteSpace';
const WhiteSpace_structure = {
    value: String
};

function WhiteSpace_parse() {
    this.eat(WhiteSpace);
    return WhiteSpace_SPACE;

    // return {
    //     type: 'WhiteSpace',
    //     loc: this.getLocation(this.tokenStart, this.tokenEnd),
    //     value: this.consume(WHITESPACE)
    // };
}

function WhiteSpace_generate(node) {
    this.token(WhiteSpace, node.value);
}

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/node/index.js









































;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/config/lexer.js



/* harmony default export */ const lexer = ({
    generic: true,
    ...data,
    node: node_namespaceObject
});

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/scope/default.js


const default_NUMBERSIGN = 0x0023;  // U+0023 NUMBER SIGN (#)
const default_ASTERISK = 0x002A;    // U+002A ASTERISK (*)
const default_PLUSSIGN = 0x002B;    // U+002B PLUS SIGN (+)
const default_HYPHENMINUS = 0x002D; // U+002D HYPHEN-MINUS (-)
const default_SOLIDUS = 0x002F;     // U+002F SOLIDUS (/)
const default_U = 0x0075;           // U+0075 LATIN SMALL LETTER U (u)

function defaultRecognizer(context) {
    switch (this.tokenType) {
        case Hash:
            return this.Hash();

        case Comma:
            return this.Operator();

        case LeftParenthesis:
            return this.Parentheses(this.readSequence, context.recognizer);

        case LeftSquareBracket:
            return this.Brackets(this.readSequence, context.recognizer);

        case types_String:
            return this.String();

        case Dimension:
            return this.Dimension();

        case Percentage:
            return this.Percentage();

        case types_Number:
            return this.Number();

        case types_Function:
            return this.cmpStr(this.tokenStart, this.tokenEnd, 'url(')
                ? this.Url()
                : this.Function(this.readSequence, context.recognizer);

        case Url:
            return this.Url();

        case Ident:
            // check for unicode range, it should start with u+ or U+
            if (this.cmpChar(this.tokenStart, default_U) &&
                this.cmpChar(this.tokenStart + 1, default_PLUSSIGN)) {
                return this.UnicodeRange();
            } else {
                return this.Identifier();
            }

        case Delim: {
            const code = this.charCodeAt(this.tokenStart);

            if (code === default_SOLIDUS ||
                code === default_ASTERISK ||
                code === default_PLUSSIGN ||
                code === default_HYPHENMINUS) {
                return this.Operator(); // TODO: replace with Delim
            }

            // TODO: produce a node with Delim node type

            if (code === default_NUMBERSIGN) {
                this.error('Hex or identifier is expected', this.tokenStart + 1);
            }

            break;
        }
    }
};

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/scope/atrulePrelude.js


/* harmony default export */ const atrulePrelude = ({
    getNode: defaultRecognizer
});

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/scope/selector.js


const selector_NUMBERSIGN = 0x0023;      // U+0023 NUMBER SIGN (#)
const selector_ASTERISK = 0x002A;        // U+002A ASTERISK (*)
const selector_PLUSSIGN = 0x002B;        // U+002B PLUS SIGN (+)
const selector_SOLIDUS = 0x002F;         // U+002F SOLIDUS (/)
const selector_FULLSTOP = 0x002E;        // U+002E FULL STOP (.)
const selector_GREATERTHANSIGN = 0x003E; // U+003E GREATER-THAN SIGN (>)
const selector_VERTICALLINE = 0x007C;    // U+007C VERTICAL LINE (|)
const selector_TILDE = 0x007E;           // U+007E TILDE (~)

function onWhiteSpace(next, children) {
    if (children.last !== null && children.last.type !== 'Combinator' &&
        next !== null && next.type !== 'Combinator') {
        children.push({  // FIXME: this.Combinator() should be used instead
            type: 'Combinator',
            loc: null,
            name: ' '
        });
    }
}

function getNode() {
    switch (this.tokenType) {
        case LeftSquareBracket:
            return this.AttributeSelector();

        case Hash:
            return this.IdSelector();

        case Colon:
            if (this.lookupType(1) === Colon) {
                return this.PseudoElementSelector();
            } else {
                return this.PseudoClassSelector();
            }

        case Ident:
            return this.TypeSelector();

        case types_Number:
        case Percentage:
            return this.Percentage();

        case Dimension:
            // throws when .123ident
            if (this.charCodeAt(this.tokenStart) === selector_FULLSTOP) {
                this.error('Identifier is expected', this.tokenStart + 1);
            }
            break;

        case Delim: {
            const code = this.charCodeAt(this.tokenStart);

            switch (code) {
                case selector_PLUSSIGN:
                case selector_GREATERTHANSIGN:
                case selector_TILDE:
                case selector_SOLIDUS:  // /deep/
                    return this.Combinator();

                case selector_FULLSTOP:
                    return this.ClassSelector();

                case selector_ASTERISK:
                case selector_VERTICALLINE:
                    return this.TypeSelector();

                case selector_NUMBERSIGN:
                    return this.IdSelector();
            }

            break;
        }
    }
};

/* harmony default export */ const selector = ({
    onWhiteSpace,
    getNode
});

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/function/expression.js
// legacy IE function
// expression( <any-value> )
/* harmony default export */ function expression() {
    return this.createSingleNodeList(
        this.Raw(this.tokenIndex, null, false)
    );
}

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/function/var.js


// var( <ident> , <value>? )
/* harmony default export */ function function_var() {
    const children = this.createList();

    this.skipSC();

    // NOTE: Don't check more than a first argument is an ident, rest checks are for lexer
    children.push(this.Identifier());

    this.skipSC();

    if (this.tokenType === Comma) {
        children.push(this.Operator());

        const startIndex = this.tokenIndex;
        const value = this.parseCustomProperty
            ? this.Value(null)
            : this.Raw(this.tokenIndex, this.consumeUntilExclamationMarkOrSemicolon, false);

        if (value.type === 'Value' && value.children.isEmpty) {
            for (let offset = startIndex - this.tokenIndex; offset <= 0; offset++) {
                if (this.lookupType(offset) === WhiteSpace) {
                    value.children.appendData({
                        type: 'WhiteSpace',
                        loc: null,
                        value: ' '
                    });
                    break;
                }
            }
        }

        children.push(value);
    }

    return children;
};

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/scope/value.js




function isPlusMinusOperator(node) {
    return (
        node !== null &&
        node.type === 'Operator' &&
        (node.value[node.value.length - 1] === '-' || node.value[node.value.length - 1] === '+')
    );
}

/* harmony default export */ const value = ({
    getNode: defaultRecognizer,
    onWhiteSpace(next, children) {
        if (isPlusMinusOperator(next)) {
            next.value = ' ' + next.value;
        }
        if (isPlusMinusOperator(children.last)) {
            children.last.value += ' ';
        }
    },
    'expression': expression,
    'var': function_var
});

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/scope/index.js




;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/atrule/font-face.js
/* harmony default export */ const font_face = ({
    parse: {
        prelude: null,
        block() {
            return this.Block(true);
        }
    }
});

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/atrule/import.js


/* harmony default export */ const atrule_import = ({
    parse: {
        prelude() {
            const children = this.createList();

            this.skipSC();

            switch (this.tokenType) {
                case types_String:
                    children.push(this.String());
                    break;

                case Url:
                case types_Function:
                    children.push(this.Url());
                    break;

                default:
                    this.error('String or url() is expected');
            }

            if (this.lookupNonWSType(0) === Ident ||
                this.lookupNonWSType(0) === LeftParenthesis) {
                children.push(this.MediaQueryList());
            }

            return children;
        },
        block: null
    }
});

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/atrule/media.js
/* harmony default export */ const media = ({
    parse: {
        prelude() {
            return this.createSingleNodeList(
                this.MediaQueryList()
            );
        },
        block() {
            return this.Block(false);
        }
    }
});

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/atrule/page.js
/* harmony default export */ const page = ({
    parse: {
        prelude() {
            return this.createSingleNodeList(
                this.SelectorList()
            );
        },
        block() {
            return this.Block(true);
        }
    }
});

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/atrule/supports.js


function supports_consumeRaw() {
    return this.createSingleNodeList(
        this.Raw(this.tokenIndex, null, false)
    );
}

function parentheses() {
    this.skipSC();

    if (this.tokenType === Ident &&
        this.lookupNonWSType(1) === Colon) {
        return this.createSingleNodeList(
            this.Declaration()
        );
    }

    return supports_readSequence.call(this);
}

function supports_readSequence() {
    const children = this.createList();
    let child;

    this.skipSC();

    scan:
    while (!this.eof) {
        switch (this.tokenType) {
            case Comment:
            case WhiteSpace:
                this.next();
                continue;

            case types_Function:
                child = this.Function(supports_consumeRaw, this.scope.AtrulePrelude);
                break;

            case Ident:
                child = this.Identifier();
                break;

            case LeftParenthesis:
                child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
                break;

            default:
                break scan;
        }

        children.push(child);
    }

    return children;
}

/* harmony default export */ const supports = ({
    parse: {
        prelude() {
            const children = supports_readSequence.call(this);

            if (this.getFirstListNode(children) === null) {
                this.error('Condition is expected');
            }

            return children;
        },
        block() {
            return this.Block(false);
        }
    }
});

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/atrule/index.js






/* harmony default export */ const atrule = ({
    'font-face': font_face,
    'import': atrule_import,
    media: media,
    page: page,
    supports: supports
});

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/pseudo/index.js
const selectorList = {
    parse() {
        return this.createSingleNodeList(
            this.SelectorList()
        );
    }
};

const pseudo_selector = {
    parse() {
        return this.createSingleNodeList(
            this.Selector()
        );
    }
};

const identList = {
    parse() {
        return this.createSingleNodeList(
            this.Identifier()
        );
    }
};

const nth = {
    parse() {
        return this.createSingleNodeList(
            this.Nth()
        );
    }
};

/* harmony default export */ const pseudo = ({
    'dir': identList,
    'has': selectorList,
    'lang': identList,
    'matches': selectorList,
    'is': selectorList,
    '-moz-any': selectorList,
    '-webkit-any': selectorList,
    'where': selectorList,
    'not': selectorList,
    'nth-child': nth,
    'nth-last-child': nth,
    'nth-last-of-type': nth,
    'nth-of-type': nth,
    'slotted': pseudo_selector
});

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/node/index-parse.js









































;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/config/parser.js





/* harmony default export */ const parser = ({
    parseContext: {
        default: 'StyleSheet',
        stylesheet: 'StyleSheet',
        atrule: 'Atrule',
        atrulePrelude(options) {
            return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
        },
        mediaQueryList: 'MediaQueryList',
        mediaQuery: 'MediaQuery',
        rule: 'Rule',
        selectorList: 'SelectorList',
        selector: 'Selector',
        block() {
            return this.Block(true);
        },
        declarationList: 'DeclarationList',
        declaration: 'Declaration',
        value: 'Value'
    },
    scope: scope_namespaceObject,
    atrule: atrule,
    pseudo: pseudo,
    node: index_parse_namespaceObject
});

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/config/walker.js


/* harmony default export */ const walker = ({
    node: node_namespaceObject
});

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/syntax/index.js





/* harmony default export */ const syntax = (create({
    ...lexer,
    ...parser,
    ...walker
}));

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/utils/clone.js


function clone(node) {
    const result = {};

    for (const key in node) {
        let value = node[key];

        if (value) {
            if (Array.isArray(value) || value instanceof List) {
                value = value.map(clone);
            } else if (value.constructor === Object) {
                value = clone(value);
            }
        }

        result[key] = value;
    }

    return result;
}

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/utils/ident.js


const ident_REVERSE_SOLIDUS = 0x005c; // U+005C REVERSE SOLIDUS (\)

function ident_decode(str) {
    const end = str.length - 1;
    let decoded = '';

    for (let i = 0; i < str.length; i++) {
        let code = str.charCodeAt(i);

        if (code === ident_REVERSE_SOLIDUS) {
            // special case at the ending
            if (i === end) {
                // if the next input code point is EOF, do nothing
                break;
            }

            code = str.charCodeAt(++i);

            // consume escaped
            if (isValidEscape(ident_REVERSE_SOLIDUS, code)) {
                const escapeStart = i - 1;
                const escapeEnd = consumeEscaped(str, escapeStart);

                i = escapeEnd - 1;
                decoded += decodeEscaped(str.substring(escapeStart + 1, escapeEnd));
            } else {
                // \r\n
                if (code === 0x000d && str.charCodeAt(i + 1) === 0x000a) {
                    i++;
                }
            }
        } else {
            decoded += str[i];
        }
    }

    return decoded;
}

// https://drafts.csswg.org/cssom/#serialize-an-identifier
//  2.1. Common Serializing Idioms
function ident_encode(str) {
    let encoded = '';

    // If the character is the first character and is a "-" (U+002D),
    // and there is no second character, then the escaped character.
    // Note: That's means a single dash string "-" return as escaped dash,
    // so move the condition out of the main loop
    if (str.length === 1 && str.charCodeAt(0) === 0x002D) {
        return '\\-';
    }

    // To serialize an identifier means to create a string represented
    // by the concatenation of, for each character of the identifier:
    for (let i = 0; i < str.length; i++) {
        const code = str.charCodeAt(i);

        // If the character is NULL (U+0000), then the REPLACEMENT CHARACTER (U+FFFD).
        if (code === 0x0000) {
            encoded += '\uFFFD';
            continue;
        }

        if (
            // If the character is in the range [\1-\1f] (U+0001 to U+001F) or is U+007F ...
            // Note: Do not compare with 0x0001 since 0x0000 is precessed before
            code <= 0x001F || code === 0x007F ||
            // [or] ... is in the range [0-9] (U+0030 to U+0039),
            (code >= 0x0030 && code <= 0x0039 && (
                // If the character is the first character ...
                i === 0 ||
                // If the character is the second character ... and the first character is a "-" (U+002D)
                i === 1 && str.charCodeAt(0) === 0x002D
            ))
        ) {
            // ... then the character escaped as code point.
            encoded += '\\' + code.toString(16) + ' ';
            continue;
        }

        // If the character is not handled by one of the above rules and is greater
        // than or equal to U+0080, is "-" (U+002D) or "_" (U+005F), or is in one
        // of the ranges [0-9] (U+0030 to U+0039), [A-Z] (U+0041 to U+005A),
        // or \[a-z] (U+0061 to U+007A), then the character itself.
        if (isName(code)) {
            encoded += str.charAt(i);
        } else {
            // Otherwise, the escaped character.
            encoded += '\\' + str.charAt(i);
        }
    }

    return encoded;
}

;// CONCATENATED MODULE: ./node_modules/css-tree/lib/index.js













const {
    tokenize: lib_tokenize,
    parse: lib_parse,
    generate: lib_generate,
    lexer: lib_lexer,
    createLexer,

    walk: lib_walk,
    find,
    findLast,
    findAll,

    toPlainObject,
    fromPlainObject,

    fork
} = syntax;

;// CONCATENATED MODULE: ./node_modules/csso/lib/usage.js
const { hasOwnProperty: usage_hasOwnProperty } = Object.prototype;

function buildMap(list, caseInsensitive) {
    const map = Object.create(null);

    if (!Array.isArray(list)) {
        return null;
    }

    for (let name of list) {
        if (caseInsensitive) {
            name = name.toLowerCase();
        }

        map[name] = true;
    }

    return map;
}

function buildList(data) {
    if (!data) {
        return null;
    }

    const tags = buildMap(data.tags, true);
    const ids = buildMap(data.ids);
    const classes = buildMap(data.classes);

    if (tags === null &&
        ids === null &&
        classes === null) {
        return null;
    }

    return {
        tags,
        ids,
        classes
    };
}

function buildIndex(data) {
    let scopes = false;

    if (data.scopes && Array.isArray(data.scopes)) {
        scopes = Object.create(null);

        for (let i = 0; i < data.scopes.length; i++) {
            const list = data.scopes[i];

            if (!list || !Array.isArray(list)) {
                throw new Error('Wrong usage format');
            }

            for (const name of list) {
                if (usage_hasOwnProperty.call(scopes, name)) {
                    throw new Error(`Class can't be used for several scopes: ${name}`);
                }

                scopes[name] = i + 1;
            }
        }
    }

    return {
        whitelist: buildList(data),
        blacklist: buildList(data.blacklist),
        scopes
    };
}

;// CONCATENATED MODULE: ./node_modules/csso/lib/clean/utils.js
function hasNoChildren(node) {
    return !node || !node.children || node.children.isEmpty;
}

function isNodeChildrenList(node, list) {
    return node !== null && node.children === list;
}

;// CONCATENATED MODULE: ./node_modules/csso/lib/clean/Atrule.js



function cleanAtrule(node, item, list) {
    if (node.block) {
        // otherwise removed at-rule don't prevent @import for removal
        if (this.stylesheet !== null) {
            this.stylesheet.firstAtrulesAllowed = false;
        }

        if (hasNoChildren(node.block)) {
            list.remove(item);
            return;
        }
    }

    switch (node.name) {
        case 'charset':
            if (hasNoChildren(node.prelude)) {
                list.remove(item);
                return;
            }

            // if there is any rule before @charset -> remove it
            if (item.prev) {
                list.remove(item);
                return;
            }

            break;

        case 'import':
            if (this.stylesheet === null || !this.stylesheet.firstAtrulesAllowed) {
                list.remove(item);
                return;
            }

            // if there are some rules that not an @import or @charset before @import
            // remove it
            list.prevUntil(item.prev, function(rule) {
                if (rule.type === 'Atrule') {
                    if (rule.name === 'import' || rule.name === 'charset') {
                        return;
                    }
                }

                this.root.firstAtrulesAllowed = false;
                list.remove(item);

                return true;
            }, this);

            break;

        default: {
            const name = keyword(node.name).basename;

            if (name === 'keyframes' ||
                name === 'media' ||
                name === 'supports') {

                // drop at-rule with no prelude
                if (hasNoChildren(node.prelude) || hasNoChildren(node.block)) {
                    list.remove(item);
                }
            }
        }
    }
};

;// CONCATENATED MODULE: ./node_modules/csso/lib/clean/Comment.js
function cleanComment(data, item, list) {
    list.remove(item);
};

;// CONCATENATED MODULE: ./node_modules/csso/lib/clean/Declaration.js


function cleanDeclartion(node, item, list) {
    if (node.value.children && node.value.children.isEmpty) {
        list.remove(item);
        return;
    }

    if (names_property(node.property).custom) {
        if (/\S/.test(node.value.value)) {
            node.value.value = node.value.value.trim();
        }
    }
};

;// CONCATENATED MODULE: ./node_modules/csso/lib/clean/Raw.js


function cleanRaw(node, item, list) {
    // raw in stylesheet or block children
    if (isNodeChildrenList(this.stylesheet, list) ||
        isNodeChildrenList(this.block, list)) {
        list.remove(item);
    }
};

;// CONCATENATED MODULE: ./node_modules/csso/lib/clean/Rule.js



const { hasOwnProperty: Rule_hasOwnProperty } = Object.prototype;
const skipUsageFilteringAtrule = new Set(['keyframes']);

function cleanUnused(selectorList, usageData) {
    selectorList.children.forEach((selector, item, list) => {
        let shouldRemove = false;

        lib_walk(selector, function(node) {
            // ignore nodes in nested selectors
            if (this.selector === null || this.selector === selectorList) {
                switch (node.type) {
                    case 'SelectorList':
                        // TODO: remove toLowerCase when pseudo selectors will be normalized
                        // ignore selectors inside :not()
                        if (this.function === null || this.function.name.toLowerCase() !== 'not') {
                            if (cleanUnused(node, usageData)) {
                                shouldRemove = true;
                            }
                        }
                        break;

                    case 'ClassSelector':
                        if (usageData.whitelist !== null &&
                            usageData.whitelist.classes !== null &&
                            !Rule_hasOwnProperty.call(usageData.whitelist.classes, node.name)) {
                            shouldRemove = true;
                        }
                        if (usageData.blacklist !== null &&
                            usageData.blacklist.classes !== null &&
                            Rule_hasOwnProperty.call(usageData.blacklist.classes, node.name)) {
                            shouldRemove = true;
                        }
                        break;

                    case 'IdSelector':
                        if (usageData.whitelist !== null &&
                            usageData.whitelist.ids !== null &&
                            !Rule_hasOwnProperty.call(usageData.whitelist.ids, node.name)) {
                            shouldRemove = true;
                        }
                        if (usageData.blacklist !== null &&
                            usageData.blacklist.ids !== null &&
                            Rule_hasOwnProperty.call(usageData.blacklist.ids, node.name)) {
                            shouldRemove = true;
                        }
                        break;

                    case 'TypeSelector':
                        // TODO: remove toLowerCase when type selectors will be normalized
                        // ignore universal selectors
                        if (node.name.charAt(node.name.length - 1) !== '*') {
                            if (usageData.whitelist !== null &&
                                usageData.whitelist.tags !== null &&
                                !Rule_hasOwnProperty.call(usageData.whitelist.tags, node.name.toLowerCase())) {
                                shouldRemove = true;
                            }
                            if (usageData.blacklist !== null &&
                                usageData.blacklist.tags !== null &&
                                Rule_hasOwnProperty.call(usageData.blacklist.tags, node.name.toLowerCase())) {
                                shouldRemove = true;
                            }
                        }
                        break;
                }
            }
        });

        if (shouldRemove) {
            list.remove(item);
        }
    });

    return selectorList.children.isEmpty;
}

function cleanRule(node, item, list, options) {
    if (hasNoChildren(node.prelude) || hasNoChildren(node.block)) {
        list.remove(item);
        return;
    }

    // avoid usage filtering for some at-rules
    if (this.atrule && skipUsageFilteringAtrule.has(keyword(this.atrule.name).basename)) {
        return;
    }

    const { usage } = options;

    if (usage && (usage.whitelist !== null || usage.blacklist !== null)) {
        cleanUnused(node.prelude, usage);

        if (hasNoChildren(node.prelude)) {
            list.remove(item);
            return;
        }
    }
};

;// CONCATENATED MODULE: ./node_modules/csso/lib/clean/TypeSelector.js
// remove useless universal selector
function cleanTypeSelector(node, item, list) {
    const name = item.data.name;

    // check it's a non-namespaced universal selector
    if (name !== '*') {
        return;
    }

    // remove when universal selector before other selectors
    const nextType = item.next && item.next.data.type;
    if (nextType === 'IdSelector' ||
        nextType === 'ClassSelector' ||
        nextType === 'AttributeSelector' ||
        nextType === 'PseudoClassSelector' ||
        nextType === 'PseudoElementSelector') {
        list.remove(item);
    }
};

;// CONCATENATED MODULE: ./node_modules/csso/lib/clean/WhiteSpace.js
function cleanWhitespace(node, item, list) {
    list.remove(item);
};

;// CONCATENATED MODULE: ./node_modules/csso/lib/clean/index.js









const handlers = {
    Atrule: cleanAtrule,
    Comment: cleanComment,
    Declaration: cleanDeclartion,
    Raw: cleanRaw,
    Rule: cleanRule,
    TypeSelector: cleanTypeSelector,
    WhiteSpace: cleanWhitespace
};

/* harmony default export */ function clean(ast, options) {
    lib_walk(ast, {
        leave(node, item, list) {
            if (handlers.hasOwnProperty(node.type)) {
                handlers[node.type].call(this, node, item, list, options);
            }
        }
    });
};

;// CONCATENATED MODULE: ./node_modules/csso/lib/replace/atrule/keyframes.js
/* harmony default export */ function keyframes(node) {
    node.block.children.forEach((rule) => {
        rule.prelude.children.forEach((simpleselector) => {
            simpleselector.children.forEach((data, item) => {
                if (data.type === 'Percentage' && data.value === '100') {
                    item.data = {
                        type: 'TypeSelector',
                        loc: data.loc,
                        name: 'to'
                    };
                } else if (data.type === 'TypeSelector' && data.name === 'from') {
                    item.data = {
                        type: 'Percentage',
                        loc: data.loc,
                        value: '0'
                    };
                }
            });
        });
    });
};

;// CONCATENATED MODULE: ./node_modules/csso/lib/replace/Atrule.js



/* harmony default export */ function Atrule(node) {
    // compress @keyframe selectors
    if (keyword(node.name).basename === 'keyframes') {
        keyframes(node);
    }
};

;// CONCATENATED MODULE: ./node_modules/csso/lib/replace/AttributeSelector.js
// Can unquote attribute detection
// Adopted implementation of Mathias Bynens
// https://github.com/mathiasbynens/mothereff.in/blob/master/unquoted-attributes/eff.js
const blockUnquoteRx = /^(-?\d|--)|[\u0000-\u002c\u002e\u002f\u003A-\u0040\u005B-\u005E\u0060\u007B-\u009f]/;

function canUnquote(value) {
    if (value === '' || value === '-') {
        return false;
    }

    return !blockUnquoteRx.test(value);
}

/* harmony default export */ function AttributeSelector(node) {
    const attrValue = node.value;

    if (!attrValue || attrValue.type !== 'String') {
        return;
    }

    if (canUnquote(attrValue.value)) {
        node.value = {
            type: 'Identifier',
            loc: attrValue.loc,
            name: attrValue.value
        };
    }
};

;// CONCATENATED MODULE: ./node_modules/csso/lib/replace/property/font.js
function compressFont(node) {
    const list = node.children;

    list.forEachRight(function(node, item) {
        if (node.type === 'Identifier') {
            if (node.name === 'bold') {
                item.data = {
                    type: 'Number',
                    loc: node.loc,
                    value: '700'
                };
            } else if (node.name === 'normal') {
                const prev = item.prev;

                if (prev && prev.data.type === 'Operator' && prev.data.value === '/') {
                    this.remove(prev);
                }

                this.remove(item);
            }
        }
    });

    if (list.isEmpty) {
        list.insert(list.createItem({
            type: 'Identifier',
            name: 'normal'
        }));
    }
};

;// CONCATENATED MODULE: ./node_modules/csso/lib/replace/property/font-weight.js
function compressFontWeight(node) {
    const value = node.children.head.data;

    if (value.type === 'Identifier') {
        switch (value.name) {
            case 'normal':
                node.children.head.data = {
                    type: 'Number',
                    loc: value.loc,
                    value: '400'
                };
                break;
            case 'bold':
                node.children.head.data = {
                    type: 'Number',
                    loc: value.loc,
                    value: '700'
                };
                break;
        }
    }
};

;// CONCATENATED MODULE: ./node_modules/csso/lib/replace/property/background.js


function compressBackground(node) {
    function flush() {
        if (!buffer.length) {
            buffer.unshift(
                {
                    type: 'Number',
                    loc: null,
                    value: '0'
                },
                {
                    type: 'Number',
                    loc: null,
                    value: '0'
                }
            );
        }

        newValue.push.apply(newValue, buffer);

        buffer = [];
    }

    let newValue = [];
    let buffer = [];

    node.children.forEach((node) => {
        if (node.type === 'Operator' && node.value === ',') {
            flush();
            newValue.push(node);
            return;
        }

        // remove defaults
        if (node.type === 'Identifier') {
            if (node.name === 'transparent' ||
                node.name === 'none' ||
                node.name === 'repeat' ||
                node.name === 'scroll') {
                return;
            }
        }

        buffer.push(node);
    });

    flush();
    node.children = new List().fromArray(newValue);
};

;// CONCATENATED MODULE: ./node_modules/csso/lib/replace/property/border.js
function compressBorder(node) {
    node.children.forEach((node, item, list) => {
        if (node.type === 'Identifier' && node.name.toLowerCase() === 'none') {
            if (list.head === list.tail) {
                // replace `none` for zero when `none` is a single term
                item.data = {
                    type: 'Number',
                    loc: node.loc,
                    value: '0'
                };
            } else {
                list.remove(item);
            }
        }
    });
};

;// CONCATENATED MODULE: ./node_modules/csso/lib/replace/Value.js







const Value_handlers = {
    'font': compressFont,
    'font-weight': compressFontWeight,
    'background': compressBackground,
    'border': compressBorder,
    'outline': compressBorder
};

function compressValue(node) {
    if (!this.declaration) {
        return;
    }

    const property = names_property(this.declaration.property);

    if (Value_handlers.hasOwnProperty(property.basename)) {
        Value_handlers[property.basename](node);
    }
};

;// CONCATENATED MODULE: ./node_modules/csso/lib/replace/Number.js
const OMIT_PLUSSIGN = /^(?:\+|(-))?0*(\d*)(?:\.0*|(\.\d*?)0*)?$/;
const KEEP_PLUSSIGN = /^([\+\-])?0*(\d*)(?:\.0*|(\.\d*?)0*)?$/;
const unsafeToRemovePlusSignAfter = new Set([
    'Dimension',
    'Hash',
    'Identifier',
    'Number',
    'Raw',
    'UnicodeRange'
]);

function packNumber(value, item) {
    // omit plus sign only if no prev or prev is safe type
    const regexp = item && item.prev !== null && unsafeToRemovePlusSignAfter.has(item.prev.data.type)
        ? KEEP_PLUSSIGN
        : OMIT_PLUSSIGN;

    // 100 -> '100'
    // 00100 -> '100'
    // +100 -> '100'
    // -100 -> '-100'
    // 0.123 -> '.123'
    // 0.12300 -> '.123'
    // 0.0 -> ''
    // 0 -> ''
    // -0 -> '-'
    value = String(value).replace(regexp, '$1$2$3');

    if (value === '' || value === '-') {
        value = '0';
    }
    // FIXME: is it solution simplier?
    // value = String(Number(value)).replace(/^(-?)0+\./, '$1.');

    return value;
}

function Number_Number(node) {
    node.value = packNumber(node.value);
};

;// CONCATENATED MODULE: ./node_modules/csso/lib/replace/Dimension.js


const MATH_FUNCTIONS = new Set([
    'calc',
    'min',
    'max',
    'clamp'
]);
const LENGTH_UNIT = new Set([
    // absolute length units
    'px',
    'mm',
    'cm',
    'in',
    'pt',
    'pc',

    // relative length units
    'em',
    'ex',
    'ch',
    'rem',

    // viewport-percentage lengths
    'vh',
    'vw',
    'vmin',
    'vmax',
    'vm'
]);

function compressDimension(node, item) {
    const value = packNumber(node.value);

    node.value = value;

    if (value === '0' && this.declaration !== null && this.atrulePrelude === null) {
        const unit = node.unit.toLowerCase();

        // only length values can be compressed
        if (!LENGTH_UNIT.has(unit)) {
            return;
        }

        // issue #362: shouldn't remove unit in -ms-flex since it breaks flex in IE10/11
        // issue #200: shouldn't remove unit in flex since it breaks flex in IE10/11
        if (this.declaration.property === '-ms-flex' ||
            this.declaration.property === 'flex') {
            return;
        }

        // issue #222: don't remove units inside calc
        if (this.function && MATH_FUNCTIONS.has(this.function.name)) {
            return;
        }

        item.data = {
            type: 'Number',
            loc: node.loc,
            value
        };
    }
};

;// CONCATENATED MODULE: ./node_modules/csso/lib/replace/Percentage.js



const blacklist = new Set([
    // see https://github.com/jakubpawlowicz/clean-css/issues/957
    'width',
    'min-width',
    'max-width',
    'height',
    'min-height',
    'max-height',

    // issue #410: Dont remove units in flex-basis value for (-ms-)flex shorthand
    // issue #362: shouldn't remove unit in -ms-flex since it breaks flex in IE10/11
    // issue #200: shouldn't remove unit in flex since it breaks flex in IE10/11
    'flex',
    '-ms-flex'
]);

function compressPercentage(node, item) {
    node.value = packNumber(node.value);

    if (node.value === '0' && this.declaration && !blacklist.has(this.declaration.property)) {
        // try to convert a number
        item.data = {
            type: 'Number',
            loc: node.loc,
            value: node.value
        };

        // that's ok only when new value matches on length
        if (!lib_lexer.matchDeclaration(this.declaration).isType(item.data, 'length')) {
            // otherwise rollback changes
            item.data = node;
        }
    }
};

;// CONCATENATED MODULE: ./node_modules/csso/lib/replace/Url.js
/* harmony default export */ function replace_Url(node) {
    // convert `\\` to `/`
    node.value = node.value.replace(/\\/g, '/');
};

;// CONCATENATED MODULE: ./node_modules/csso/lib/replace/color.js



// http://www.w3.org/TR/css3-color/#svg-color
const NAME_TO_HEX = {
    'aliceblue': 'f0f8ff',
    'antiquewhite': 'faebd7',
    'aqua': '0ff',
    'aquamarine': '7fffd4',
    'azure': 'f0ffff',
    'beige': 'f5f5dc',
    'bisque': 'ffe4c4',
    'black': '000',
    'blanchedalmond': 'ffebcd',
    'blue': '00f',
    'blueviolet': '8a2be2',
    'brown': 'a52a2a',
    'burlywood': 'deb887',
    'cadetblue': '5f9ea0',
    'chartreuse': '7fff00',
    'chocolate': 'd2691e',
    'coral': 'ff7f50',
    'cornflowerblue': '6495ed',
    'cornsilk': 'fff8dc',
    'crimson': 'dc143c',
    'cyan': '0ff',
    'darkblue': '00008b',
    'darkcyan': '008b8b',
    'darkgoldenrod': 'b8860b',
    'darkgray': 'a9a9a9',
    'darkgrey': 'a9a9a9',
    'darkgreen': '006400',
    'darkkhaki': 'bdb76b',
    'darkmagenta': '8b008b',
    'darkolivegreen': '556b2f',
    'darkorange': 'ff8c00',
    'darkorchid': '9932cc',
    'darkred': '8b0000',
    'darksalmon': 'e9967a',
    'darkseagreen': '8fbc8f',
    'darkslateblue': '483d8b',
    'darkslategray': '2f4f4f',
    'darkslategrey': '2f4f4f',
    'darkturquoise': '00ced1',
    'darkviolet': '9400d3',
    'deeppink': 'ff1493',
    'deepskyblue': '00bfff',
    'dimgray': '696969',
    'dimgrey': '696969',
    'dodgerblue': '1e90ff',
    'firebrick': 'b22222',
    'floralwhite': 'fffaf0',
    'forestgreen': '228b22',
    'fuchsia': 'f0f',
    'gainsboro': 'dcdcdc',
    'ghostwhite': 'f8f8ff',
    'gold': 'ffd700',
    'goldenrod': 'daa520',
    'gray': '808080',
    'grey': '808080',
    'green': '008000',
    'greenyellow': 'adff2f',
    'honeydew': 'f0fff0',
    'hotpink': 'ff69b4',
    'indianred': 'cd5c5c',
    'indigo': '4b0082',
    'ivory': 'fffff0',
    'khaki': 'f0e68c',
    'lavender': 'e6e6fa',
    'lavenderblush': 'fff0f5',
    'lawngreen': '7cfc00',
    'lemonchiffon': 'fffacd',
    'lightblue': 'add8e6',
    'lightcoral': 'f08080',
    'lightcyan': 'e0ffff',
    'lightgoldenrodyellow': 'fafad2',
    'lightgray': 'd3d3d3',
    'lightgrey': 'd3d3d3',
    'lightgreen': '90ee90',
    'lightpink': 'ffb6c1',
    'lightsalmon': 'ffa07a',
    'lightseagreen': '20b2aa',
    'lightskyblue': '87cefa',
    'lightslategray': '789',
    'lightslategrey': '789',
    'lightsteelblue': 'b0c4de',
    'lightyellow': 'ffffe0',
    'lime': '0f0',
    'limegreen': '32cd32',
    'linen': 'faf0e6',
    'magenta': 'f0f',
    'maroon': '800000',
    'mediumaquamarine': '66cdaa',
    'mediumblue': '0000cd',
    'mediumorchid': 'ba55d3',
    'mediumpurple': '9370db',
    'mediumseagreen': '3cb371',
    'mediumslateblue': '7b68ee',
    'mediumspringgreen': '00fa9a',
    'mediumturquoise': '48d1cc',
    'mediumvioletred': 'c71585',
    'midnightblue': '191970',
    'mintcream': 'f5fffa',
    'mistyrose': 'ffe4e1',
    'moccasin': 'ffe4b5',
    'navajowhite': 'ffdead',
    'navy': '000080',
    'oldlace': 'fdf5e6',
    'olive': '808000',
    'olivedrab': '6b8e23',
    'orange': 'ffa500',
    'orangered': 'ff4500',
    'orchid': 'da70d6',
    'palegoldenrod': 'eee8aa',
    'palegreen': '98fb98',
    'paleturquoise': 'afeeee',
    'palevioletred': 'db7093',
    'papayawhip': 'ffefd5',
    'peachpuff': 'ffdab9',
    'peru': 'cd853f',
    'pink': 'ffc0cb',
    'plum': 'dda0dd',
    'powderblue': 'b0e0e6',
    'purple': '800080',
    'rebeccapurple': '639',
    'red': 'f00',
    'rosybrown': 'bc8f8f',
    'royalblue': '4169e1',
    'saddlebrown': '8b4513',
    'salmon': 'fa8072',
    'sandybrown': 'f4a460',
    'seagreen': '2e8b57',
    'seashell': 'fff5ee',
    'sienna': 'a0522d',
    'silver': 'c0c0c0',
    'skyblue': '87ceeb',
    'slateblue': '6a5acd',
    'slategray': '708090',
    'slategrey': '708090',
    'snow': 'fffafa',
    'springgreen': '00ff7f',
    'steelblue': '4682b4',
    'tan': 'd2b48c',
    'teal': '008080',
    'thistle': 'd8bfd8',
    'tomato': 'ff6347',
    'turquoise': '40e0d0',
    'violet': 'ee82ee',
    'wheat': 'f5deb3',
    'white': 'fff',
    'whitesmoke': 'f5f5f5',
    'yellow': 'ff0',
    'yellowgreen': '9acd32'
};

const HEX_TO_NAME = {
    '800000': 'maroon',
    '800080': 'purple',
    '808000': 'olive',
    '808080': 'gray',
    '00ffff': 'cyan',
    'f0ffff': 'azure',
    'f5f5dc': 'beige',
    'ffe4c4': 'bisque',
    '000000': 'black',
    '0000ff': 'blue',
    'a52a2a': 'brown',
    'ff7f50': 'coral',
    'ffd700': 'gold',
    '008000': 'green',
    '4b0082': 'indigo',
    'fffff0': 'ivory',
    'f0e68c': 'khaki',
    '00ff00': 'lime',
    'faf0e6': 'linen',
    '000080': 'navy',
    'ffa500': 'orange',
    'da70d6': 'orchid',
    'cd853f': 'peru',
    'ffc0cb': 'pink',
    'dda0dd': 'plum',
    'f00': 'red',
    'ff0000': 'red',
    'fa8072': 'salmon',
    'a0522d': 'sienna',
    'c0c0c0': 'silver',
    'fffafa': 'snow',
    'd2b48c': 'tan',
    '008080': 'teal',
    'ff6347': 'tomato',
    'ee82ee': 'violet',
    'f5deb3': 'wheat',
    'ffffff': 'white',
    'ffff00': 'yellow'
};

function hueToRgb(p, q, t) {
    if (t < 0) {
        t += 1;
    }
    if (t > 1) {
        t -= 1;
    }
    if (t < 1 / 6) {
        return p + (q - p) * 6 * t;
    }
    if (t < 1 / 2) {
        return q;
    }
    if (t < 2 / 3) {
        return p + (q - p) * (2 / 3 - t) * 6;
    }
    return p;
}

function hslToRgb(h, s, l, a) {
    let r;
    let g;
    let b;

    if (s === 0) {
        r = g = b = l; // achromatic
    } else {
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;

        r = hueToRgb(p, q, h + 1 / 3);
        g = hueToRgb(p, q, h);
        b = hueToRgb(p, q, h - 1 / 3);
    }

    return [
        Math.round(r * 255),
        Math.round(g * 255),
        Math.round(b * 255),
        a
    ];
}

function toHex(value) {
    value = value.toString(16);

    return value.length === 1 ? '0' + value : value;
}

function parseFunctionArgs(functionArgs, count, rgb) {
    let cursor = functionArgs.head;
    let args = [];
    let wasValue = false;

    while (cursor !== null) {
        const { type, value } = cursor.data;

        switch (type) {
            case 'Number':
            case 'Percentage':
                if (wasValue) {
                    return;
                }

                wasValue = true;
                args.push({
                    type,
                    value: Number(value)
                });

                break;

            case 'Operator':
                if (value === ',') {
                    if (!wasValue) {
                        return;
                    }
                    wasValue = false;
                } else if (wasValue || value !== '+') {
                    return;
                }

                break;

            default:
                // something we couldn't understand
                return;
        }

        cursor = cursor.next;
    }

    if (args.length !== count) {
        // invalid arguments count
        // TODO: remove those tokens
        return;
    }

    if (args.length === 4) {
        if (args[3].type !== 'Number') {
            // 4th argument should be a number
            // TODO: remove those tokens
            return;
        }

        args[3].type = 'Alpha';
    }

    if (rgb) {
        if (args[0].type !== args[1].type || args[0].type !== args[2].type) {
            // invalid color, numbers and percentage shouldn't be mixed
            // TODO: remove those tokens
            return;
        }
    } else {
        if (args[0].type !== 'Number' ||
            args[1].type !== 'Percentage' ||
            args[2].type !== 'Percentage') {
            // invalid color, for hsl values should be: number, percentage, percentage
            // TODO: remove those tokens
            return;
        }

        args[0].type = 'Angle';
    }

    return args.map(function(arg) {
        let value = Math.max(0, arg.value);

        switch (arg.type) {
            case 'Number':
                // fit value to [0..255] range
                value = Math.min(value, 255);
                break;

            case 'Percentage':
                // convert 0..100% to value in [0..255] range
                value = Math.min(value, 100) / 100;

                if (!rgb) {
                    return value;
                }

                value = 255 * value;
                break;

            case 'Angle':
                // fit value to (-360..360) range
                return (((value % 360) + 360) % 360) / 360;

            case 'Alpha':
                // fit value to [0..1] range
                return Math.min(value, 1);
        }

        return Math.round(value);
    });
}

function compressFunction(node, item) {
    let functionName = node.name;
    let args;

    if (functionName === 'rgba' || functionName === 'hsla') {
        args = parseFunctionArgs(node.children, 4, functionName === 'rgba');

        if (!args) {
            // something went wrong
            return;
        }

        if (functionName === 'hsla') {
            args = hslToRgb(...args);
            node.name = 'rgba';
        }

        if (args[3] === 0) {
            // try to replace `rgba(x, x, x, 0)` to `transparent`
            // always replace `rgba(0, 0, 0, 0)` to `transparent`
            // otherwise avoid replacement in gradients since it may break color transition
            // http://stackoverflow.com/questions/11829410/css3-gradient-rendering-issues-from-transparent-to-white
            const scopeFunctionName = this.function && this.function.name;

            if ((args[0] === 0 && args[1] === 0 && args[2] === 0) ||
                !/^(?:to|from|color-stop)$|gradient$/i.test(scopeFunctionName)) {

                item.data = {
                    type: 'Identifier',
                    loc: node.loc,
                    name: 'transparent'
                };

                return;
            }
        }

        if (args[3] !== 1) {
            // replace argument values for normalized/interpolated
            node.children.forEach((node, item, list) => {
                if (node.type === 'Operator') {
                    if (node.value !== ',') {
                        list.remove(item);
                    }
                    return;
                }

                item.data = {
                    type: 'Number',
                    loc: node.loc,
                    value: packNumber(args.shift())
                };
            });

            return;
        }

        // otherwise convert to rgb, i.e. rgba(255, 0, 0, 1) -> rgb(255, 0, 0)
        functionName = 'rgb';
    }

    if (functionName === 'hsl') {
        args = args || parseFunctionArgs(node.children, 3, false);

        if (!args) {
            // something went wrong
            return;
        }

        // convert to rgb
        args = hslToRgb(...args);
        functionName = 'rgb';
    }

    if (functionName === 'rgb') {
        args = args || parseFunctionArgs(node.children, 3, true);

        if (!args) {
            // something went wrong
            return;
        }

        item.data = {
            type: 'Hash',
            loc: node.loc,
            value: toHex(args[0]) + toHex(args[1]) + toHex(args[2])
        };

        compressHex(item.data, item);
    }
}

function compressIdent(node, item) {
    if (this.declaration === null) {
        return;
    }

    let color = node.name.toLowerCase();

    if (NAME_TO_HEX.hasOwnProperty(color) &&
        lib_lexer.matchDeclaration(this.declaration).isType(node, 'color')) {
        const hex = NAME_TO_HEX[color];

        if (hex.length + 1 <= color.length) {
            // replace for shorter hex value
            item.data = {
                type: 'Hash',
                loc: node.loc,
                value: hex
            };
        } else {
            // special case for consistent colors
            if (color === 'grey') {
                color = 'gray';
            }

            // just replace value for lower cased name
            node.name = color;
        }
    }
}

function compressHex(node, item) {
    let color = node.value.toLowerCase();

    // #112233 -> #123
    if (color.length === 6 &&
        color[0] === color[1] &&
        color[2] === color[3] &&
        color[4] === color[5]) {
        color = color[0] + color[2] + color[4];
    }

    if (HEX_TO_NAME[color]) {
        item.data = {
            type: 'Identifier',
            loc: node.loc,
            name: HEX_TO_NAME[color]
        };
    } else {
        node.value = color;
    }
}

;// CONCATENATED MODULE: ./node_modules/csso/lib/replace/index.js










const replace_handlers = {
    Atrule: Atrule,
    AttributeSelector: AttributeSelector,
    Value: compressValue,
    Dimension: compressDimension,
    Percentage: compressPercentage,
    Number: Number_Number,
    Url: replace_Url,
    Hash: compressHex,
    Identifier: compressIdent,
    Function: compressFunction
};

/* harmony default export */ function replace(ast) {
    lib_walk(ast, {
        leave(node, item, list) {
            if (replace_handlers.hasOwnProperty(node.type)) {
                replace_handlers[node.type].call(this, node, item, list);
            }
        }
    });
};

;// CONCATENATED MODULE: ./node_modules/csso/lib/restructure/prepare/createDeclarationIndexer.js


class Index {
    constructor() {
        this.map = new Map();
    }
    resolve(str) {
        let index = this.map.get(str);

        if (index === undefined) {
            index = this.map.size + 1;
            this.map.set(str, index);
        }

        return index;
    }
};

function createDeclarationIndexer() {
    const ids = new Index();

    return function markDeclaration(node) {
        const id = lib_generate(node);

        node.id = ids.resolve(id);
        node.length = id.length;
        node.fingerprint = null;

        return node;
    };
};

;// CONCATENATED MODULE: ./node_modules/csso/lib/restructure/prepare/specificity.js


function ensureSelectorList(node) {
    if (node.type === 'Raw') {
        return lib_parse(node.value, { context: 'selectorList' });
    }

    return node;
}

function maxSpecificity(a, b) {
    for (let i = 0; i < 3; i++) {
        if (a[i] !== b[i]) {
            return a[i] > b[i] ? a : b;
        }
    }

    return a;
}

function maxSelectorListSpecificity(selectorList) {
    return ensureSelectorList(selectorList).children.reduce(
        (result, node) => maxSpecificity(specificity(node), result),
        [0, 0, 0]
    );
}

// 16. Calculating a selectors specificity
// https://www.w3.org/TR/selectors-4/#specificity-rules
function specificity(simpleSelector) {
    let A = 0;
    let B = 0;
    let C = 0;

    // A selectors specificity is calculated for a given element as follows:
    simpleSelector.children.forEach((node) => {
        switch (node.type) {
            // count the number of ID selectors in the selector (= A)
            case 'IdSelector':
                A++;
                break;

            // count the number of class selectors, attributes selectors, ...
            case 'ClassSelector':
            case 'AttributeSelector':
                B++;
                break;

            // ... and pseudo-classes in the selector (= B)
            case 'PseudoClassSelector':
                switch (node.name.toLowerCase()) {
                    // The specificity of an :is(), :not(), or :has() pseudo-class is replaced
                    // by the specificity of the most specific complex selector in its selector list argument.
                    case 'not':
                    case 'has':
                    case 'is':
                    // :matches() is used before it was renamed to :is()
                    // https://github.com/w3c/csswg-drafts/issues/3258
                    case 'matches':
                    // Older browsers support :is() functionality as prefixed pseudo-class :any()
                    // https://developer.mozilla.org/en-US/docs/Web/CSS/:is
                    case '-webkit-any':
                    case '-moz-any': {
                        const [a, b, c] = maxSelectorListSpecificity(node.children.first);

                        A += a;
                        B += b;
                        C += c;

                        break;
                    }

                    // Analogously, the specificity of an :nth-child() or :nth-last-child() selector
                    // is the specificity of the pseudo class itself (counting as one pseudo-class selector)
                    // plus the specificity of the most specific complex selector in its selector list argument (if any).
                    case 'nth-child':
                    case 'nth-last-child': {
                        const arg = node.children.first;

                        if (arg.type === 'Nth' && arg.selector) {
                            const [a, b, c] = maxSelectorListSpecificity(arg.selector);

                            A += a;
                            B += b + 1;
                            C += c;
                        } else {
                            B++;
                        }

                        break;
                    }

                    // The specificity of a :where() pseudo-class is replaced by zero.
                    case 'where':
                        break;

                    // The four Level 2 pseudo-elements (::before, ::after, ::first-line, and ::first-letter) may,
                    // for legacy reasons, be represented using the <pseudo-class-selector> grammar,
                    // with only a single ":" character at their start.
                    // https://www.w3.org/TR/selectors-4/#single-colon-pseudos
                    case 'before':
                    case 'after':
                    case 'first-line':
                    case 'first-letter':
                        C++;
                        break;

                    default:
                        B++;
                }
                break;

            // count the number of type selectors ...
            case 'TypeSelector':
                // ignore the universal selector
                if (!node.name.endsWith('*')) {
                    C++;
                }
                break;

            // ... and pseudo-elements in the selector (= C)
            case 'PseudoElementSelector':
                C++;
                break;
        }
    });

    return [A, B, C];
};

/* harmony default export */ const prepare_specificity = (specificity);

;// CONCATENATED MODULE: ./node_modules/csso/lib/restructure/prepare/processSelector.js



const nonFreezePseudoElements = new Set([
    'first-letter',
    'first-line',
    'after',
    'before'
]);
const nonFreezePseudoClasses = new Set([
    'link',
    'visited',
    'hover',
    'active',
    'first-letter',
    'first-line',
    'after',
    'before'
]);

function processSelector(node, usageData) {
    const pseudos = new Set();

    node.prelude.children.forEach(function(simpleSelector) {
        let tagName = '*';
        let scope = 0;

        simpleSelector.children.forEach(function(node) {
            switch (node.type) {
                case 'ClassSelector':
                    if (usageData && usageData.scopes) {
                        const classScope = usageData.scopes[node.name] || 0;

                        if (scope !== 0 && classScope !== scope) {
                            throw new Error('Selector can\'t has classes from different scopes: ' + lib_generate(simpleSelector));
                        }

                        scope = classScope;
                    }

                    break;

                case 'PseudoClassSelector': {
                    const name = node.name.toLowerCase();

                    if (!nonFreezePseudoClasses.has(name)) {
                        pseudos.add(`:${name}`);
                    }

                    break;
                }

                case 'PseudoElementSelector': {
                    const name = node.name.toLowerCase();

                    if (!nonFreezePseudoElements.has(name)) {
                        pseudos.add(`::${name}`);
                    }

                    break;
                }

                case 'TypeSelector':
                    tagName = node.name.toLowerCase();
                    break;

                case 'AttributeSelector':
                    if (node.flags) {
                        pseudos.add(`[${node.flags.toLowerCase()}]`);
                    }

                    break;

                case 'Combinator':
                    tagName = '*';
                    break;
            }
        });

        simpleSelector.compareMarker = prepare_specificity(simpleSelector).toString();
        simpleSelector.id = null; // pre-init property to avoid multiple hidden class
        simpleSelector.id = lib_generate(simpleSelector);

        if (scope) {
            simpleSelector.compareMarker += ':' + scope;
        }

        if (tagName !== '*') {
            simpleSelector.compareMarker += ',' + tagName;
        }
    });

    // add property to all rule nodes to avoid multiple hidden class
    node.pseudoSignature = pseudos.size > 0
        ? [...pseudos].sort().join(',')
        : false;
};

;// CONCATENATED MODULE: ./node_modules/csso/lib/restructure/prepare/index.js




function prepare(ast, options) {
    const markDeclaration = createDeclarationIndexer();

    lib_walk(ast, {
        visit: 'Rule',
        enter(node) {
            node.block.children.forEach(markDeclaration);
            processSelector(node, options.usage);
        }
    });

    lib_walk(ast, {
        visit: 'Atrule',
        enter(node) {
            if (node.prelude) {
                node.prelude.id = null; // pre-init property to avoid multiple hidden class for generate
                node.prelude.id = lib_generate(node.prelude);
            }

            // compare keyframe selectors by its values
            // NOTE: still no clarification about problems with keyframes selector grouping (issue #197)
            if (keyword(node.name).basename === 'keyframes') {
                node.block.avoidRulesMerge = true;  /* probably we don't need to prevent those merges for @keyframes
                                                       TODO: need to be checked */
                node.block.children.forEach(function(rule) {
                    rule.prelude.children.forEach(function(simpleselector) {
                        simpleselector.compareMarker = simpleselector.id;
                    });
                });
            }
        }
    });

    return {
        declaration: markDeclaration
    };
};

;// CONCATENATED MODULE: ./node_modules/csso/lib/restructure/1-mergeAtrule.js


const { hasOwnProperty: _1_mergeAtrule_hasOwnProperty } = Object.prototype;

function addRuleToMap(map, item, list, single) {
    const node = item.data;
    const name = keyword(node.name).basename;
    const id = node.name.toLowerCase() + '/' + (node.prelude ? node.prelude.id : null);

    if (!_1_mergeAtrule_hasOwnProperty.call(map, name)) {
        map[name] = Object.create(null);
    }

    if (single) {
        delete map[name][id];
    }

    if (!_1_mergeAtrule_hasOwnProperty.call(map[name], id)) {
        map[name][id] = new List();
    }

    map[name][id].append(list.remove(item));
}

function relocateAtrules(ast, options) {
    const collected = Object.create(null);
    let topInjectPoint = null;

    ast.children.forEach(function(node, item, list) {
        if (node.type === 'Atrule') {
            const name = keyword(node.name).basename;

            switch (name) {
                case 'keyframes':
                    addRuleToMap(collected, item, list, true);
                    return;

                case 'media':
                    if (options.forceMediaMerge) {
                        addRuleToMap(collected, item, list, false);
                        return;
                    }
                    break;
            }

            if (topInjectPoint === null &&
                name !== 'charset' &&
                name !== 'import') {
                topInjectPoint = item;
            }
        } else {
            if (topInjectPoint === null) {
                topInjectPoint = item;
            }
        }
    });

    for (const atrule in collected) {
        for (const id in collected[atrule]) {
            ast.children.insertList(
                collected[atrule][id],
                atrule === 'media' ? null : topInjectPoint
            );
        }
    }
};

function isMediaRule(node) {
    return node.type === 'Atrule' && node.name === 'media';
}

function processAtrule(node, item, list) {
    if (!isMediaRule(node)) {
        return;
    }

    const prev = item.prev && item.prev.data;

    if (!prev || !isMediaRule(prev)) {
        return;
    }

    // merge @media with same query
    if (node.prelude &&
        prev.prelude &&
        node.prelude.id === prev.prelude.id) {
        prev.block.children.appendList(node.block.children);
        list.remove(item);

        // TODO: use it when we can refer to several points in source
        // prev.loc = {
        //     primary: prev.loc,
        //     merged: node.loc
        // };
    }
}

function rejoinAtrule(ast, options) {
    relocateAtrules(ast, options);

    lib_walk(ast, {
        visit: 'Atrule',
        reverse: true,
        enter: processAtrule
    });
};

;// CONCATENATED MODULE: ./node_modules/csso/lib/restructure/utils.js
const { hasOwnProperty: utils_hasOwnProperty } = Object.prototype;

function isEqualSelectors(a, b) {
    let cursor1 = a.head;
    let cursor2 = b.head;

    while (cursor1 !== null && cursor2 !== null && cursor1.data.id === cursor2.data.id) {
        cursor1 = cursor1.next;
        cursor2 = cursor2.next;
    }

    return cursor1 === null && cursor2 === null;
}

function isEqualDeclarations(a, b) {
    let cursor1 = a.head;
    let cursor2 = b.head;

    while (cursor1 !== null && cursor2 !== null && cursor1.data.id === cursor2.data.id) {
        cursor1 = cursor1.next;
        cursor2 = cursor2.next;
    }

    return cursor1 === null && cursor2 === null;
}

function compareDeclarations(declarations1, declarations2) {
    const result = {
        eq: [],
        ne1: [],
        ne2: [],
        ne2overrided: []
    };

    const fingerprints = Object.create(null);
    const declarations2hash = Object.create(null);

    for (let cursor = declarations2.head; cursor; cursor = cursor.next)  {
        declarations2hash[cursor.data.id] = true;
    }

    for (let cursor = declarations1.head; cursor; cursor = cursor.next)  {
        const data = cursor.data;

        if (data.fingerprint) {
            fingerprints[data.fingerprint] = data.important;
        }

        if (declarations2hash[data.id]) {
            declarations2hash[data.id] = false;
            result.eq.push(data);
        } else {
            result.ne1.push(data);
        }
    }

    for (let cursor = declarations2.head; cursor; cursor = cursor.next)  {
        const data = cursor.data;

        if (declarations2hash[data.id]) {
            // when declarations1 has an overriding declaration, this is not a difference
            // unless no !important is used on prev and !important is used on the following
            if (!utils_hasOwnProperty.call(fingerprints, data.fingerprint) ||
                (!fingerprints[data.fingerprint] && data.important)) {
                result.ne2.push(data);
            }

            result.ne2overrided.push(data);
        }
    }

    return result;
}

function addSelectors(dest, source) {
    source.forEach((sourceData) => {
        const newStr = sourceData.id;
        let cursor = dest.head;

        while (cursor) {
            const nextStr = cursor.data.id;

            if (nextStr === newStr) {
                return;
            }

            if (nextStr > newStr) {
                break;
            }

            cursor = cursor.next;
        }

        dest.insert(dest.createItem(sourceData), cursor);
    });

    return dest;
}

// check if simpleselectors has no equal specificity and element selector
function hasSimilarSelectors(selectors1, selectors2) {
    let cursor1 = selectors1.head;

    while (cursor1 !== null) {
        let cursor2 = selectors2.head;

        while (cursor2 !== null) {
            if (cursor1.data.compareMarker === cursor2.data.compareMarker) {
                return true;
            }

            cursor2 = cursor2.next;
        }

        cursor1 = cursor1.next;
    }

    return false;
}

// test node can't to be skipped
function unsafeToSkipNode(node) {
    switch (node.type) {
        case 'Rule':
            // unsafe skip ruleset with selector similarities
            return hasSimilarSelectors(node.prelude.children, this);

        case 'Atrule':
            // can skip at-rules with blocks
            if (node.block) {
                // unsafe skip at-rule if block contains something unsafe to skip
                return node.block.children.some(unsafeToSkipNode, this);
            }
            break;

        case 'Declaration':
            return false;
    }

    // unsafe by default
    return true;
}

;// CONCATENATED MODULE: ./node_modules/csso/lib/restructure/2-initialMergeRuleset.js



function processRule(node, item, list) {
    const selectors = node.prelude.children;
    const declarations = node.block.children;

    list.prevUntil(item.prev, function(prev) {
        // skip non-ruleset node if safe
        if (prev.type !== 'Rule') {
            return unsafeToSkipNode.call(selectors, prev);
        }

        const prevSelectors = prev.prelude.children;
        const prevDeclarations = prev.block.children;

        // try to join rulesets with equal pseudo signature
        if (node.pseudoSignature === prev.pseudoSignature) {
            // try to join by selectors
            if (isEqualSelectors(prevSelectors, selectors)) {
                prevDeclarations.appendList(declarations);
                list.remove(item);
                return true;
            }

            // try to join by declarations
            if (isEqualDeclarations(declarations, prevDeclarations)) {
                addSelectors(prevSelectors, selectors);
                list.remove(item);
                return true;
            }
        }

        // go to prev ruleset if has no selector similarities
        return hasSimilarSelectors(selectors, prevSelectors);
    });
}

// NOTE: direction should be left to right, since rulesets merge to left
// ruleset. When direction right to left unmerged rulesets may prevent lookup
// TODO: remove initial merge
function initialMergeRule(ast) {
    lib_walk(ast, {
        visit: 'Rule',
        enter: processRule
    });
};

;// CONCATENATED MODULE: ./node_modules/csso/lib/restructure/3-disjoinRuleset.js


function _3_disjoinRuleset_processRule(node, item, list) {
    const selectors = node.prelude.children;

    // generate new rule sets:
    // .a, .b { color: red; }
    // ->
    // .a { color: red; }
    // .b { color: red; }

    // while there are more than 1 simple selector split for rulesets
    while (selectors.head !== selectors.tail) {
        const newSelectors = new List();

        newSelectors.insert(selectors.remove(selectors.head));

        list.insert(list.createItem({
            type: 'Rule',
            loc: node.loc,
            prelude: {
                type: 'SelectorList',
                loc: node.prelude.loc,
                children: newSelectors
            },
            block: {
                type: 'Block',
                loc: node.block.loc,
                children: node.block.children.copy()
            },
            pseudoSignature: node.pseudoSignature
        }), item);
    }
}

function disjoinRule(ast) {
    lib_walk(ast, {
        visit: 'Rule',
        reverse: true,
        enter: _3_disjoinRuleset_processRule
    });
};

;// CONCATENATED MODULE: ./node_modules/csso/lib/restructure/4-restructShorthand.js


const REPLACE = 1;
const REMOVE = 2;
const TOP = 0;
const RIGHT = 1;
const BOTTOM = 2;
const LEFT = 3;
const SIDES = ['top', 'right', 'bottom', 'left'];
const SIDE = {
    'margin-top': 'top',
    'margin-right': 'right',
    'margin-bottom': 'bottom',
    'margin-left': 'left',

    'padding-top': 'top',
    'padding-right': 'right',
    'padding-bottom': 'bottom',
    'padding-left': 'left',

    'border-top-color': 'top',
    'border-right-color': 'right',
    'border-bottom-color': 'bottom',
    'border-left-color': 'left',
    'border-top-width': 'top',
    'border-right-width': 'right',
    'border-bottom-width': 'bottom',
    'border-left-width': 'left',
    'border-top-style': 'top',
    'border-right-style': 'right',
    'border-bottom-style': 'bottom',
    'border-left-style': 'left'
};
const MAIN_PROPERTY = {
    'margin': 'margin',
    'margin-top': 'margin',
    'margin-right': 'margin',
    'margin-bottom': 'margin',
    'margin-left': 'margin',

    'padding': 'padding',
    'padding-top': 'padding',
    'padding-right': 'padding',
    'padding-bottom': 'padding',
    'padding-left': 'padding',

    'border-color': 'border-color',
    'border-top-color': 'border-color',
    'border-right-color': 'border-color',
    'border-bottom-color': 'border-color',
    'border-left-color': 'border-color',
    'border-width': 'border-width',
    'border-top-width': 'border-width',
    'border-right-width': 'border-width',
    'border-bottom-width': 'border-width',
    'border-left-width': 'border-width',
    'border-style': 'border-style',
    'border-top-style': 'border-style',
    'border-right-style': 'border-style',
    'border-bottom-style': 'border-style',
    'border-left-style': 'border-style'
};

class TRBL {
    constructor(name) {
        this.name = name;
        this.loc = null;
        this.iehack = undefined;
        this.sides = {
            'top': null,
            'right': null,
            'bottom': null,
            'left': null
        };
    }

    getValueSequence(declaration, count) {
        const values = [];
        let iehack = '';
        const hasBadValues = declaration.value.type !== 'Value' || declaration.value.children.some(function(child) {
            let special = false;

            switch (child.type) {
                case 'Identifier':
                    switch (child.name) {
                        case '\\0':
                        case '\\9':
                            iehack = child.name;
                            return;

                        case 'inherit':
                        case 'initial':
                        case 'unset':
                        case 'revert':
                            special = child.name;
                            break;
                    }
                    break;

                case 'Dimension':
                    switch (child.unit) {
                        // is not supported until IE11
                        case 'rem':

                        // v* units is too buggy across browsers and better
                        // don't merge values with those units
                        case 'vw':
                        case 'vh':
                        case 'vmin':
                        case 'vmax':
                        case 'vm': // IE9 supporting "vm" instead of "vmin".
                            special = child.unit;
                            break;
                    }
                    break;

                case 'Hash': // color
                case 'Number':
                case 'Percentage':
                    break;

                case 'Function':
                    if (child.name === 'var') {
                        return true;
                    }

                    special = child.name;
                    break;

                default:
                    return true;  // bad value
            }

            values.push({
                node: child,
                special,
                important: declaration.important
            });
        });

        if (hasBadValues || values.length > count) {
            return false;
        }

        if (typeof this.iehack === 'string' && this.iehack !== iehack) {
            return false;
        }

        this.iehack = iehack; // move outside

        return values;
    }

    canOverride(side, value) {
        const currentValue = this.sides[side];

        return !currentValue || (value.important && !currentValue.important);
    }

    add(name, declaration) {
        function attemptToAdd() {
            const sides = this.sides;
            const side = SIDE[name];

            if (side) {
                if (side in sides === false) {
                    return false;
                }

                const values = this.getValueSequence(declaration, 1);

                if (!values || !values.length) {
                    return false;
                }

                // can mix only if specials are equal
                for (const key in sides) {
                    if (sides[key] !== null && sides[key].special !== values[0].special) {
                        return false;
                    }
                }

                if (!this.canOverride(side, values[0])) {
                    return true;
                }

                sides[side] = values[0];

                return true;
            } else if (name === this.name) {
                const values = this.getValueSequence(declaration, 4);

                if (!values || !values.length) {
                    return false;
                }

                switch (values.length) {
                    case 1:
                        values[RIGHT] = values[TOP];
                        values[BOTTOM] = values[TOP];
                        values[LEFT] = values[TOP];
                        break;

                    case 2:
                        values[BOTTOM] = values[TOP];
                        values[LEFT] = values[RIGHT];
                        break;

                    case 3:
                        values[LEFT] = values[RIGHT];
                        break;
                }

                // can mix only if specials are equal
                for (let i = 0; i < 4; i++) {
                    for (const key in sides) {
                        if (sides[key] !== null && sides[key].special !== values[i].special) {
                            return false;
                        }
                    }
                }

                for (let i = 0; i < 4; i++) {
                    if (this.canOverride(SIDES[i], values[i])) {
                        sides[SIDES[i]] = values[i];
                    }
                }

                return true;
            }
        }

        if (!attemptToAdd.call(this)) {
            return false;
        }

        // TODO: use it when we can refer to several points in source
        // if (this.loc) {
        //     this.loc = {
        //         primary: this.loc,
        //         merged: declaration.loc
        //     };
        // } else {
        //     this.loc = declaration.loc;
        // }
        if (!this.loc) {
            this.loc = declaration.loc;
        }

        return true;
    }

    isOkToMinimize() {
        const top = this.sides.top;
        const right = this.sides.right;
        const bottom = this.sides.bottom;
        const left = this.sides.left;

        if (top && right && bottom && left) {
            const important =
                top.important +
                right.important +
                bottom.important +
                left.important;

            return important === 0 || important === 4;
        }

        return false;
    }

    getValue() {
        const result = new List();
        const sides = this.sides;
        const values = [
            sides.top,
            sides.right,
            sides.bottom,
            sides.left
        ];
        const stringValues = [
            lib_generate(sides.top.node),
            lib_generate(sides.right.node),
            lib_generate(sides.bottom.node),
            lib_generate(sides.left.node)
        ];

        if (stringValues[LEFT] === stringValues[RIGHT]) {
            values.pop();
            if (stringValues[BOTTOM] === stringValues[TOP]) {
                values.pop();
                if (stringValues[RIGHT] === stringValues[TOP]) {
                    values.pop();
                }
            }
        }

        for (let i = 0; i < values.length; i++) {
            result.appendData(values[i].node);
        }

        if (this.iehack) {
            result.appendData({
                type: 'Identifier',
                loc: null,
                name: this.iehack
            });
        }

        return {
            type: 'Value',
            loc: null,
            children: result
        };
    }

    getDeclaration() {
        return {
            type: 'Declaration',
            loc: this.loc,
            important: this.sides.top.important,
            property: this.name,
            value: this.getValue()
        };
    }
}

function _4_restructShorthand_processRule(rule, shorts, shortDeclarations, lastShortSelector) {
    const declarations = rule.block.children;
    const selector = rule.prelude.children.first.id;

    rule.block.children.forEachRight(function(declaration, item) {
        const property = declaration.property;

        if (!MAIN_PROPERTY.hasOwnProperty(property)) {
            return;
        }

        const key = MAIN_PROPERTY[property];
        let shorthand;
        let operation;

        if (!lastShortSelector || selector === lastShortSelector) {
            if (key in shorts) {
                operation = REMOVE;
                shorthand = shorts[key];
            }
        }

        if (!shorthand || !shorthand.add(property, declaration)) {
            operation = REPLACE;
            shorthand = new TRBL(key);

            // if can't parse value ignore it and break shorthand children
            if (!shorthand.add(property, declaration)) {
                lastShortSelector = null;
                return;
            }
        }

        shorts[key] = shorthand;
        shortDeclarations.push({
            operation,
            block: declarations,
            item,
            shorthand
        });

        lastShortSelector = selector;
    });

    return lastShortSelector;
}

function processShorthands(shortDeclarations, markDeclaration) {
    shortDeclarations.forEach(function(item) {
        const shorthand = item.shorthand;

        if (!shorthand.isOkToMinimize()) {
            return;
        }

        if (item.operation === REPLACE) {
            item.item.data = markDeclaration(shorthand.getDeclaration());
        } else {
            item.block.remove(item.item);
        }
    });
}

function restructBlock(ast, indexer) {
    const stylesheetMap = {};
    const shortDeclarations = [];

    lib_walk(ast, {
        visit: 'Rule',
        reverse: true,
        enter(node) {
            const stylesheet = this.block || this.stylesheet;
            const ruleId = (node.pseudoSignature || '') + '|' + node.prelude.children.first.id;
            let ruleMap;
            let shorts;

            if (!stylesheetMap.hasOwnProperty(stylesheet.id)) {
                ruleMap = {
                    lastShortSelector: null
                };
                stylesheetMap[stylesheet.id] = ruleMap;
            } else {
                ruleMap = stylesheetMap[stylesheet.id];
            }

            if (ruleMap.hasOwnProperty(ruleId)) {
                shorts = ruleMap[ruleId];
            } else {
                shorts = {};
                ruleMap[ruleId] = shorts;
            }

            ruleMap.lastShortSelector = _4_restructShorthand_processRule.call(this, node, shorts, shortDeclarations, ruleMap.lastShortSelector);
        }
    });

    processShorthands(shortDeclarations, indexer.declaration);
};

;// CONCATENATED MODULE: ./node_modules/csso/lib/restructure/6-restructBlock.js


let fingerprintId = 1;
const dontRestructure = new Set([
    'src' // https://github.com/afelix/csso/issues/50
]);

const DONT_MIX_VALUE = {
    // https://developer.mozilla.org/en-US/docs/Web/CSS/display#Browser_compatibility
    'display': /table|ruby|flex|-(flex)?box$|grid|contents|run-in/i,
    // https://developer.mozilla.org/en/docs/Web/CSS/text-align
    'text-align': /^(start|end|match-parent|justify-all)$/i
};

const SAFE_VALUES = {
    cursor: [
        'auto', 'crosshair', 'default', 'move', 'text', 'wait', 'help',
        'n-resize', 'e-resize', 's-resize', 'w-resize',
        'ne-resize', 'nw-resize', 'se-resize', 'sw-resize',
        'pointer', 'progress', 'not-allowed', 'no-drop', 'vertical-text', 'all-scroll',
        'col-resize', 'row-resize'
    ],
    overflow: [
        'hidden', 'visible', 'scroll', 'auto'
    ],
    position: [
        'static', 'relative', 'absolute', 'fixed'
    ]
};

const NEEDLESS_TABLE = {
    'border-width': ['border'],
    'border-style': ['border'],
    'border-color': ['border'],
    'border-top': ['border'],
    'border-right': ['border'],
    'border-bottom': ['border'],
    'border-left': ['border'],
    'border-top-width': ['border-top', 'border-width', 'border'],
    'border-right-width': ['border-right', 'border-width', 'border'],
    'border-bottom-width': ['border-bottom', 'border-width', 'border'],
    'border-left-width': ['border-left', 'border-width', 'border'],
    'border-top-style': ['border-top', 'border-style', 'border'],
    'border-right-style': ['border-right', 'border-style', 'border'],
    'border-bottom-style': ['border-bottom', 'border-style', 'border'],
    'border-left-style': ['border-left', 'border-style', 'border'],
    'border-top-color': ['border-top', 'border-color', 'border'],
    'border-right-color': ['border-right', 'border-color', 'border'],
    'border-bottom-color': ['border-bottom', 'border-color', 'border'],
    'border-left-color': ['border-left', 'border-color', 'border'],
    'margin-top': ['margin'],
    'margin-right': ['margin'],
    'margin-bottom': ['margin'],
    'margin-left': ['margin'],
    'padding-top': ['padding'],
    'padding-right': ['padding'],
    'padding-bottom': ['padding'],
    'padding-left': ['padding'],
    'font-style': ['font'],
    'font-variant': ['font'],
    'font-weight': ['font'],
    'font-size': ['font'],
    'font-family': ['font'],
    'list-style-type': ['list-style'],
    'list-style-position': ['list-style'],
    'list-style-image': ['list-style']
};

function getPropertyFingerprint(propertyName, declaration, fingerprints) {
    const realName = names_property(propertyName).basename;

    if (realName === 'background') {
        return propertyName + ':' + lib_generate(declaration.value);
    }

    const declarationId = declaration.id;
    let fingerprint = fingerprints[declarationId];

    if (!fingerprint) {
        switch (declaration.value.type) {
            case 'Value':
                const special = {};
                let vendorId = '';
                let iehack = '';
                let raw = false;

                declaration.value.children.forEach(function walk(node) {
                    switch (node.type) {
                        case 'Value':
                        case 'Brackets':
                        case 'Parentheses':
                            node.children.forEach(walk);
                            break;

                        case 'Raw':
                            raw = true;
                            break;

                        case 'Identifier': {
                            const { name } = node;

                            if (!vendorId) {
                                vendorId = keyword(name).vendor;
                            }

                            if (/\\[09]/.test(name)) {
                                iehack = RegExp.lastMatch;
                            }

                            if (SAFE_VALUES.hasOwnProperty(realName)) {
                                if (SAFE_VALUES[realName].indexOf(name) === -1) {
                                    special[name] = true;
                                }
                            } else if (DONT_MIX_VALUE.hasOwnProperty(realName)) {
                                if (DONT_MIX_VALUE[realName].test(name)) {
                                    special[name] = true;
                                }
                            }

                            break;
                        }

                        case 'Function': {
                            let { name } = node;

                            if (!vendorId) {
                                vendorId = keyword(name).vendor;
                            }

                            if (name === 'rect') {
                                // there are 2 forms of rect:
                                //   rect(<top>, <right>, <bottom>, <left>) - standart
                                //   rect(<top> <right> <bottom> <left>)  backwards compatible syntax
                                // only the same form values can be merged
                                const hasComma = node.children.some((node) =>
                                    node.type === 'Operator' && node.value === ','
                                );

                                if (!hasComma) {
                                    name = 'rect-backward';
                                }
                            }

                            special[name + '()'] = true;

                            // check nested tokens too
                            node.children.forEach(walk);

                            break;
                        }

                        case 'Dimension': {
                            const { unit } = node;

                            if (/\\[09]/.test(unit)) {
                                iehack = RegExp.lastMatch;
                            }

                            switch (unit) {
                                // is not supported until IE11
                                case 'rem':

                                // v* units is too buggy across browsers and better
                                // don't merge values with those units
                                case 'vw':
                                case 'vh':
                                case 'vmin':
                                case 'vmax':
                                case 'vm': // IE9 supporting "vm" instead of "vmin".
                                    special[unit] = true;
                                    break;
                            }

                            break;
                        }
                    }
                });

                fingerprint = raw
                    ? '!' + fingerprintId++
                    : '!' + Object.keys(special).sort() + '|' + iehack + vendorId;
                break;

            case 'Raw':
                fingerprint = '!' + declaration.value.value;
                break;

            default:
                fingerprint = lib_generate(declaration.value);
        }

        fingerprints[declarationId] = fingerprint;
    }

    return propertyName + fingerprint;
}

function needless(props, declaration, fingerprints) {
    const property = names_property(declaration.property);

    if (NEEDLESS_TABLE.hasOwnProperty(property.basename)) {
        const table = NEEDLESS_TABLE[property.basename];

        for (const entry of table) {
            const ppre = getPropertyFingerprint(property.prefix + entry, declaration, fingerprints);
            const prev = props.hasOwnProperty(ppre) ? props[ppre] : null;

            if (prev && (!declaration.important || prev.item.data.important)) {
                return prev;
            }
        }
    }
}

function _6_restructBlock_processRule(rule, item, list, props, fingerprints) {
    const declarations = rule.block.children;

    declarations.forEachRight(function(declaration, declarationItem) {
        const { property } = declaration;
        const fingerprint = getPropertyFingerprint(property, declaration, fingerprints);
        const prev = props[fingerprint];

        if (prev && !dontRestructure.has(property)) {
            if (declaration.important && !prev.item.data.important) {
                props[fingerprint] = {
                    block: declarations,
                    item: declarationItem
                };

                prev.block.remove(prev.item);

                // TODO: use it when we can refer to several points in source
                // declaration.loc = {
                //     primary: declaration.loc,
                //     merged: prev.item.data.loc
                // };
            } else {
                declarations.remove(declarationItem);

                // TODO: use it when we can refer to several points in source
                // prev.item.data.loc = {
                //     primary: prev.item.data.loc,
                //     merged: declaration.loc
                // };
            }
        } else {
            const prev = needless(props, declaration, fingerprints);

            if (prev) {
                declarations.remove(declarationItem);

                // TODO: use it when we can refer to several points in source
                // prev.item.data.loc = {
                //     primary: prev.item.data.loc,
                //     merged: declaration.loc
                // };
            } else {
                declaration.fingerprint = fingerprint;

                props[fingerprint] = {
                    block: declarations,
                    item: declarationItem
                };
            }
        }
    });

    if (declarations.isEmpty) {
        list.remove(item);
    }
}

function _6_restructBlock_restructBlock(ast) {
    const stylesheetMap = {};
    const fingerprints = Object.create(null);

    lib_walk(ast, {
        visit: 'Rule',
        reverse: true,
        enter(node, item, list) {
            const stylesheet = this.block || this.stylesheet;
            const ruleId = (node.pseudoSignature || '') + '|' + node.prelude.children.first.id;
            let ruleMap;
            let props;

            if (!stylesheetMap.hasOwnProperty(stylesheet.id)) {
                ruleMap = {};
                stylesheetMap[stylesheet.id] = ruleMap;
            } else {
                ruleMap = stylesheetMap[stylesheet.id];
            }

            if (ruleMap.hasOwnProperty(ruleId)) {
                props = ruleMap[ruleId];
            } else {
                props = {};
                ruleMap[ruleId] = props;
            }

            _6_restructBlock_processRule.call(this, node, item, list, props, fingerprints);
        }
    });
};

;// CONCATENATED MODULE: ./node_modules/csso/lib/restructure/7-mergeRuleset.js



/*
    At this step all rules has single simple selector. We try to join by equal
    declaration blocks to first rule, e.g.

    .a { color: red }
    b { ... }
    .b { color: red }
    ->
    .a, .b { color: red }
    b { ... }
*/

function _7_mergeRuleset_processRule(node, item, list) {
    const selectors = node.prelude.children;
    const declarations = node.block.children;
    const nodeCompareMarker = selectors.first.compareMarker;
    const skippedCompareMarkers = {};

    list.nextUntil(item.next, function(next, nextItem) {
        // skip non-ruleset node if safe
        if (next.type !== 'Rule') {
            return unsafeToSkipNode.call(selectors, next);
        }

        if (node.pseudoSignature !== next.pseudoSignature) {
            return true;
        }

        const nextFirstSelector = next.prelude.children.head;
        const nextDeclarations = next.block.children;
        const nextCompareMarker = nextFirstSelector.data.compareMarker;

        // if next ruleset has same marked as one of skipped then stop joining
        if (nextCompareMarker in skippedCompareMarkers) {
            return true;
        }

        // try to join by selectors
        if (selectors.head === selectors.tail) {
            if (selectors.first.id === nextFirstSelector.data.id) {
                declarations.appendList(nextDeclarations);
                list.remove(nextItem);
                return;
            }
        }

        // try to join by properties
        if (isEqualDeclarations(declarations, nextDeclarations)) {
            const nextStr = nextFirstSelector.data.id;

            selectors.some((data, item) => {
                const curStr = data.id;

                if (nextStr < curStr) {
                    selectors.insert(nextFirstSelector, item);
                    return true;
                }

                if (!item.next) {
                    selectors.insert(nextFirstSelector);
                    return true;
                }
            });

            list.remove(nextItem);
            return;
        }

        // go to next ruleset if current one can be skipped (has no equal specificity nor element selector)
        if (nextCompareMarker === nodeCompareMarker) {
            return true;
        }

        skippedCompareMarkers[nextCompareMarker] = true;
    });
}

function mergeRule(ast) {
    lib_walk(ast, {
        visit: 'Rule',
        enter: _7_mergeRuleset_processRule
    });
};

;// CONCATENATED MODULE: ./node_modules/csso/lib/restructure/8-restructRuleset.js



function calcSelectorLength(list) {
    return list.reduce((res, data) => res + data.id.length + 1, 0) - 1;
}

function calcDeclarationsLength(tokens) {
    let length = 0;

    for (const token of tokens) {
        length += token.length;
    }

    return (
        length +          // declarations
        tokens.length - 1 // delimeters
    );
}

function _8_restructRuleset_processRule(node, item, list) {
    const avoidRulesMerge = this.block !== null ? this.block.avoidRulesMerge : false;
    const selectors = node.prelude.children;
    const block = node.block;
    const disallowDownMarkers = Object.create(null);
    let allowMergeUp = true;
    let allowMergeDown = true;

    list.prevUntil(item.prev, function(prev, prevItem) {
        const prevBlock = prev.block;
        const prevType = prev.type;

        if (prevType !== 'Rule') {
            const unsafe = unsafeToSkipNode.call(selectors, prev);

            if (!unsafe && prevType === 'Atrule' && prevBlock) {
                lib_walk(prevBlock, {
                    visit: 'Rule',
                    enter(node) {
                        node.prelude.children.forEach((data) => {
                            disallowDownMarkers[data.compareMarker] = true;
                        });
                    }
                });
            }

            return unsafe;
        }

        if (node.pseudoSignature !== prev.pseudoSignature) {
            return true;
        }

        const prevSelectors = prev.prelude.children;

        allowMergeDown = !prevSelectors.some((selector) =>
            selector.compareMarker in disallowDownMarkers
        );

        // try prev ruleset if simpleselectors has no equal specifity and element selector
        if (!allowMergeDown && !allowMergeUp) {
            return true;
        }

        // try to join by selectors
        if (allowMergeUp && isEqualSelectors(prevSelectors, selectors)) {
            prevBlock.children.appendList(block.children);
            list.remove(item);

            return true;
        }

        // try to join by properties
        const diff = compareDeclarations(block.children, prevBlock.children);

        // console.log(diff.eq, diff.ne1, diff.ne2);

        if (diff.eq.length) {
            if (!diff.ne1.length && !diff.ne2.length) {
                // equal blocks
                if (allowMergeDown) {
                    addSelectors(selectors, prevSelectors);
                    list.remove(prevItem);
                }

                return true;
            } else if (!avoidRulesMerge) { /* probably we don't need to prevent those merges for @keyframes
                                              TODO: need to be checked */

                if (diff.ne1.length && !diff.ne2.length) {
                    // prevBlock is subset block
                    const selectorLength = calcSelectorLength(selectors);
                    const blockLength = calcDeclarationsLength(diff.eq); // declarations length

                    if (allowMergeUp && selectorLength < blockLength) {
                        addSelectors(prevSelectors, selectors);
                        block.children.fromArray(diff.ne1);
                    }
                } else if (!diff.ne1.length && diff.ne2.length) {
                    // node is subset of prevBlock
                    const selectorLength = calcSelectorLength(prevSelectors);
                    const blockLength = calcDeclarationsLength(diff.eq); // declarations length

                    if (allowMergeDown && selectorLength < blockLength) {
                        addSelectors(selectors, prevSelectors);
                        prevBlock.children.fromArray(diff.ne2);
                    }
                } else {
                    // diff.ne1.length && diff.ne2.length
                    // extract equal block
                    const newSelector = {
                        type: 'SelectorList',
                        loc: null,
                        children: addSelectors(prevSelectors.copy(), selectors)
                    };
                    const newBlockLength = calcSelectorLength(newSelector.children) + 2; // selectors length + curly braces length
                    const blockLength = calcDeclarationsLength(diff.eq); // declarations length

                    // create new ruleset if declarations length greater than
                    // ruleset description overhead
                    if (blockLength >= newBlockLength) {
                        const newItem = list.createItem({
                            type: 'Rule',
                            loc: null,
                            prelude: newSelector,
                            block: {
                                type: 'Block',
                                loc: null,
                                children: new List().fromArray(diff.eq)
                            },
                            pseudoSignature: node.pseudoSignature
                        });

                        block.children.fromArray(diff.ne1);
                        prevBlock.children.fromArray(diff.ne2overrided);

                        if (allowMergeUp) {
                            list.insert(newItem, prevItem);
                        } else {
                            list.insert(newItem, item);
                        }

                        return true;
                    }
                }
            }
        }

        if (allowMergeUp) {
            // TODO: disallow up merge only if any property interception only (i.e. diff.ne2overrided.length > 0);
            // await property families to find property interception correctly
            allowMergeUp = !prevSelectors.some((prevSelector) =>
                selectors.some((selector) =>
                    selector.compareMarker === prevSelector.compareMarker
                )
            );
        }

        prevSelectors.forEach((data) => {
            disallowDownMarkers[data.compareMarker] = true;
        });
    });
}

function restructRule(ast) {
    lib_walk(ast, {
        visit: 'Rule',
        reverse: true,
        enter: _8_restructRuleset_processRule
    });
};

;// CONCATENATED MODULE: ./node_modules/csso/lib/restructure/index.js









/* harmony default export */ function restructure(ast, options) {
    // prepare ast for restructing
    const indexer = prepare(ast, options);
    options.logger('prepare', ast);

    rejoinAtrule(ast, options);
    options.logger('mergeAtrule', ast);

    initialMergeRule(ast);
    options.logger('initialMergeRuleset', ast);

    disjoinRule(ast);
    options.logger('disjoinRuleset', ast);

    restructBlock(ast, indexer);
    options.logger('restructShorthand', ast);

    _6_restructBlock_restructBlock(ast);
    options.logger('restructBlock', ast);

    mergeRule(ast);
    options.logger('mergeRuleset', ast);

    restructRule(ast);
    options.logger('restructRuleset', ast);
};

;// CONCATENATED MODULE: ./node_modules/csso/lib/compress.js






function readChunk(input, specialComments) {
    const children = new List();
    let nonSpaceTokenInBuffer = false;
    let protectedComment;

    input.nextUntil(input.head, (node, item, list) => {
        if (node.type === 'Comment') {
            if (!specialComments || node.value.charAt(0) !== '!') {
                list.remove(item);
                return;
            }

            if (nonSpaceTokenInBuffer || protectedComment) {
                return true;
            }

            list.remove(item);
            protectedComment = node;

            return;
        }

        if (node.type !== 'WhiteSpace') {
            nonSpaceTokenInBuffer = true;
        }

        children.insert(list.remove(item));
    });

    return {
        comment: protectedComment,
        stylesheet: {
            type: 'StyleSheet',
            loc: null,
            children
        }
    };
}

function compressChunk(ast, firstAtrulesAllowed, num, options) {
    options.logger(`Compress block #${num}`, null, true);

    let seed = 1;

    if (ast.type === 'StyleSheet') {
        ast.firstAtrulesAllowed = firstAtrulesAllowed;
        ast.id = seed++;
    }

    lib_walk(ast, {
        visit: 'Atrule',
        enter(node) {
            if (node.block !== null) {
                node.block.id = seed++;
            }
        }
    });
    options.logger('init', ast);

    // remove redundant
    clean(ast, options);
    options.logger('clean', ast);

    // replace nodes for shortened forms
    replace(ast, options);
    options.logger('replace', ast);

    // structure optimisations
    if (options.restructuring) {
        restructure(ast, options);
    }

    return ast;
}

function getCommentsOption(options) {
    let comments = 'comments' in options ? options.comments : 'exclamation';

    if (typeof comments === 'boolean') {
        comments = comments ? 'exclamation' : false;
    } else if (comments !== 'exclamation' && comments !== 'first-exclamation') {
        comments = false;
    }

    return comments;
}

function getRestructureOption(options) {
    if ('restructure' in options) {
        return options.restructure;
    }

    return 'restructuring' in options ? options.restructuring : true;
}

function wrapBlock(block) {
    return new List().appendData({
        type: 'Rule',
        loc: null,
        prelude: {
            type: 'SelectorList',
            loc: null,
            children: new List().appendData({
                type: 'Selector',
                loc: null,
                children: new List().appendData({
                    type: 'TypeSelector',
                    loc: null,
                    name: 'x'
                })
            })
        },
        block
    });
}

function compress(ast, options) {
    ast = ast || { type: 'StyleSheet', loc: null, children: new List() };
    options = options || {};

    const compressOptions = {
        logger: typeof options.logger === 'function' ? options.logger : function() {},
        restructuring: getRestructureOption(options),
        forceMediaMerge: Boolean(options.forceMediaMerge),
        usage: options.usage ? buildIndex(options.usage) : false
    };
    const output = new List();
    let specialComments = getCommentsOption(options);
    let firstAtrulesAllowed = true;
    let input;
    let chunk;
    let chunkNum = 1;
    let chunkChildren;

    if (options.clone) {
        ast = clone(ast);
    }

    if (ast.type === 'StyleSheet') {
        input = ast.children;
        ast.children = output;
    } else {
        input = wrapBlock(ast);
    }

    do {
        chunk = readChunk(input, Boolean(specialComments));
        compressChunk(chunk.stylesheet, firstAtrulesAllowed, chunkNum++, compressOptions);
        chunkChildren = chunk.stylesheet.children;

        if (chunk.comment) {
            // add \n before comment if there is another content in output
            if (!output.isEmpty) {
                output.insert(List.createItem({
                    type: 'Raw',
                    value: '\n'
                }));
            }

            output.insert(List.createItem(chunk.comment));

            // add \n after comment if chunk is not empty
            if (!chunkChildren.isEmpty) {
                output.insert(List.createItem({
                    type: 'Raw',
                    value: '\n'
                }));
            }
        }

        if (firstAtrulesAllowed && !chunkChildren.isEmpty) {
            const lastRule = chunkChildren.last;

            if (lastRule.type !== 'Atrule' ||
               (lastRule.name !== 'import' && lastRule.name !== 'charset')) {
                firstAtrulesAllowed = false;
            }
        }

        if (specialComments !== 'exclamation') {
            specialComments = false;
        }

        output.appendList(chunkChildren);
    } while (!input.isEmpty);

    return {
        ast
    };
};

;// CONCATENATED MODULE: ./node_modules/csso/lib/syntax.js




function encodeString(value) {
    const stringApostrophe = encode(value, true);
    const stringQuote = encode(value);

    return stringApostrophe.length < stringQuote.length
        ? stringApostrophe
        : stringQuote;
}

const {
    lexer: syntax_lexer,
    tokenize: syntax_tokenize,
    parse: syntax_parse,
    generate: syntax_generate,
    walk: syntax_walk,
    find: syntax_find,
    findLast: syntax_findLast,
    findAll: syntax_findAll,
    fromPlainObject: syntax_fromPlainObject,
    toPlainObject: syntax_toPlainObject
} = fork({
    node: {
        String: {
            generate(node) {
                this.token(types_String, encodeString(node.value));
            }
        },
        Url: {
            generate(node) {
                const encodedUrl = url_encode(node.value);
                const string = encodeString(node.value);

                this.token(Url,
                    encodedUrl.length <= string.length + 5 /* "url()".length */
                        ? encodedUrl
                        : 'url(' + string + ')'
                );
            }
        }
    }
});



;// CONCATENATED MODULE: ./node_modules/csso/lib/utils.js



;// CONCATENATED MODULE: ./node_modules/csso/lib/index.js




const { parse: csso_lib_parse, generate: csso_lib_generate, compress: lib_compress } = lib_syntax_namespaceObject;

function debugOutput(name, options, startTime, data) {
    if (options.debug) {
        console.error(`## ${name} done in %d ms\n`, Date.now() - startTime);
    }

    return data;
}

function createDefaultLogger(level) {
    let lastDebug;

    return function logger(title, ast) {
        let line = title;

        if (ast) {
            line = `[${((Date.now() - lastDebug) / 1000).toFixed(3)}s] ${line}`;
        }

        if (level > 1 && ast) {
            let css = csso_lib_generate(ast);

            // when level 2, limit css to 256 symbols
            if (level === 2 && css.length > 256) {
                css = css.substr(0, 256) + '...';
            }

            line += `\n  ${css}\n`;
        }

        console.error(line);
        lastDebug = Date.now();
    };
}

function buildCompressOptions(options) {
    options = { ...options };

    if (typeof options.logger !== 'function' && options.debug) {
        options.logger = createDefaultLogger(options.debug);
    }

    return options;
}

function runHandler(ast, options, handlers) {
    if (!Array.isArray(handlers)) {
        handlers = [handlers];
    }

    handlers.forEach(fn => fn(ast, options));
}

function minify(context, source, options) {
    options = options || {};

    const filename = options.filename || '<unknown>';
    let result;

    // parse
    const ast = debugOutput('parsing', options, Date.now(),
        csso_lib_parse(source, {
            context,
            filename,
            positions: Boolean(options.sourceMap)
        })
    );

    // before compress handlers
    if (options.beforeCompress) {
        debugOutput('beforeCompress', options, Date.now(),
            runHandler(ast, options, options.beforeCompress)
        );
    }

    // compress
    const compressResult = debugOutput('compress', options, Date.now(),
        lib_compress(ast, buildCompressOptions(options))
    );

    // after compress handlers
    if (options.afterCompress) {
        debugOutput('afterCompress', options, Date.now(),
            runHandler(compressResult, options, options.afterCompress)
        );
    }

    // generate
    if (options.sourceMap) {
        result = debugOutput('generate(sourceMap: true)', options, Date.now(), (() => {
            const tmp = csso_lib_generate(compressResult.ast, { sourceMap: true });

            tmp.map._file = filename; // since other tools can relay on file in source map transform chain
            tmp.map.setSourceContent(filename, source);

            return tmp;
        })());
    } else {
        result = debugOutput('generate', options, Date.now(), {
            css: csso_lib_generate(compressResult.ast),
            map: null
        });
    }

    return result;
}

function minifyStylesheet(source, options) {
    return minify('stylesheet', source, options);
}

function minifyBlock(source, options) {
    return minify('declarationList', source, options);
}



;// CONCATENATED MODULE: external ["wp","blockSerializationDefaultParser"]
const external_wp_blockSerializationDefaultParser_namespaceObject = window["wp"]["blockSerializationDefaultParser"];
;// CONCATENATED MODULE: ./src/blocks/utils/css/save-frontend-css.js










/* harmony default export */ const save_frontend_css = (/*#__PURE__*/_asyncToGenerator( /*#__PURE__*/external_regeneratorRuntime_default().mark(function _callee() {
  var _css$allDevice, _css$desktop, _css$tablet, _css$mobile;

  var widgets,
      blocks,
      data,
      res,
      _select$getBlocks,
      css,
      hasBlocks,
      parsedCSS,
      options,
      _select,
      getCurrentPostId,
      id,
      args,
      _args = arguments;

  return external_regeneratorRuntime_default().wrap(function _callee$(_context) {
    while (1) {
      switch (_context.prev = _context.next) {
        case 0:
          widgets = _args.length > 0 && _args[0] !== undefined ? _args[0] : false;
          blocks = null;

          if (!('customize' === window.pagenow && widgets)) {
            _context.next = 17;
            break;
          }

          _context.prev = 3;
          data = new FormData();
          data.append('action', 'blockart_get_widget_blocks');
          data.append('security', _BLOCKART_.nonce);
          _context.next = 9;
          return external_wp_apiFetch_default()({
            method: 'POST',
            url: _BLOCKART_.ajaxUrl,
            body: data
          });

        case 9:
          res = _context.sent;

          if (res.data.blocks) {
            blocks = (0,external_wp_blockSerializationDefaultParser_namespaceObject.parse)(res.data.blocks);
          }

          _context.next = 15;
          break;

        case 13:
          _context.prev = 13;
          _context.t0 = _context["catch"](3);

        case 15:
          _context.next = 19;
          break;

        case 17:
          blocks = (_select$getBlocks = (0,external_wp_data_namespaceObject.select)('core/block-editor').getBlocks()) !== null && _select$getBlocks !== void 0 ? _select$getBlocks : [];

          if (widgets && 'widgets' === window.pagenow) {
            /**
             * Every widget area is a block in widgets screen but not in customize screen.
             *
             * So we need to get the inner blocks (actual blocks) from the widget area block.
             */
            blocks = blocks.reduce(function (acc, curr) {
              var widgetBlocks = (0,external_wp_data_namespaceObject.select)('core/block-editor').getBlocks(curr.clientId);
              acc = [].concat(_toConsumableArray(acc), _toConsumableArray(widgetBlocks));
              return acc;
            }, []);
          }

        case 19:
          if (!(null === blocks || isEmpty(blocks))) {
            _context.next = 21;
            break;
          }

          return _context.abrupt("return", new Promise(function (resolve) {
            return resolve('');
          }));

        case 21:
          css = generate_frontend_css(blocks);
          hasBlocks = has_blockart_blocks(blocks);
          parsedCSS = ((_css$allDevice = css.allDevice) !== null && _css$allDevice !== void 0 ? _css$allDevice : []).join('');
          parsedCSS += ((_css$desktop = css.desktop) !== null && _css$desktop !== void 0 ? _css$desktop : []).join('');

          if (css !== null && css !== void 0 && (_css$tablet = css.tablet) !== null && _css$tablet !== void 0 && _css$tablet.length) {
            parsedCSS += "@media (max-width: 62em) { ".concat(css.tablet.join(''), " }");
          }

          if (css !== null && css !== void 0 && (_css$mobile = css.mobile) !== null && _css$mobile !== void 0 && _css$mobile.length) {
            parsedCSS += "@media (max-width: 48em) { ".concat(css.mobile.join(''), " }");
          }

          if (!isEmpty(parsedCSS)) {
            parsedCSS = minifyStylesheet(parsedCSS, {
              restructure: true
            }).css;
          }

          options = {
            path: 'wp/v2/settings',
            method: 'PUT',
            body: JSON.stringify({
              _blockart_widget_css: parsedCSS
            })
          };

          if (!widgets) {
            _select = (0,external_wp_data_namespaceObject.select)('core/editor'), getCurrentPostId = _select.getCurrentPostId;
            id = getCurrentPostId();
            args = new FormData();
            options.method = 'POST';
            options.url = _BLOCKART_.ajaxUrl;
            delete options.path;
            args.append('post_id', id);
            args.append('has_blocks', hasBlocks);
            args.append('security', _BLOCKART_.nonce);
            args.append('action', 'blockart_save_block_css');
            args.append('css', parsedCSS);
            options.body = args;
          }

          return _context.abrupt("return", new Promise(function (resolve, reject) {
            external_wp_apiFetch_default()(options)["catch"](reject)["finally"](function () {
              return resolve();
            });
          }));

        case 31:
        case "end":
          return _context.stop();
      }
    }
  }, _callee, null, [[3, 13]]);
})));
;// CONCATENATED MODULE: ./src/blocks/utils/css/generate-frontend-css.js
function generate_frontend_css_createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = generate_frontend_css_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function generate_frontend_css_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return generate_frontend_css_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return generate_frontend_css_arrayLikeToArray(o, minLen); }

function generate_frontend_css_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }



var generate_frontend_css_DEVICES = ['allDevice', 'desktop', 'tablet', 'mobile'];

var generateFrontendCSS = function generateFrontendCSS(blocks) {
  var css = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {
    allDevice: [],
    desktop: [],
    tablet: [],
    mobile: []
  };
  blocks.forEach(function (block) {
    var _ref, _block$attributes, _ref2, _block$name;

    var attributes = (_ref = (_block$attributes = block === null || block === void 0 ? void 0 : block.attributes) !== null && _block$attributes !== void 0 ? _block$attributes : block === null || block === void 0 ? void 0 : block.attrs) !== null && _ref !== void 0 ? _ref : {};
    var name = (_ref2 = (_block$name = block === null || block === void 0 ? void 0 : block.name) !== null && _block$name !== void 0 ? _block$name : block === null || block === void 0 ? void 0 : block.blockName) !== null && _ref2 !== void 0 ? _ref2 : '';
    var blockName = name.split('/');

    if (blockName[0] === 'blockart' && attributes.clientId) {
      var blockCSS = generate_block_css({
        settings: attributes,
        blockName: 'button-inner' === blockName[1] ? 'button' : 'button' === blockName[1] ? 'buttons' : blockName[1],
        blockID: attributes.clientId,
        context: 'save'
      });

      var _iterator = generate_frontend_css_createForOfIteratorHelper(generate_frontend_css_DEVICES),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var device = _step.value;

          if (blockCSS !== null && blockCSS !== void 0 && blockCSS[device]) {
            css[device] = css[device].concat(blockCSS[device]);
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }

    if ('core/block' === name) {
      if (attributes !== null && attributes !== void 0 && attributes.ref) {
        var _select, _select$getEditedEnti;

        var reusableBlocks = ((_select = (0,external_wp_data_namespaceObject.select)('core')) === null || _select === void 0 ? void 0 : (_select$getEditedEnti = _select.getEditedEntityRecord('postType', 'wp_block', attributes === null || attributes === void 0 ? void 0 : attributes.ref)) === null || _select$getEditedEnti === void 0 ? void 0 : _select$getEditedEnti.blocks) || [];

        if ((reusableBlocks === null || reusableBlocks === void 0 ? void 0 : reusableBlocks.length) > 0) {
          css = generateFrontendCSS(reusableBlocks, css);
        }
      }
    }

    if (block.innerBlocks && block.innerBlocks.length > 0) {
      css = generateFrontendCSS(block.innerBlocks, css);
    }
  });
  return css;
};

/* harmony default export */ const generate_frontend_css = (generateFrontendCSS);
;// CONCATENATED MODULE: ./src/blocks/utils/css/index.js



;// CONCATENATED MODULE: ./src/blocks/utils/index.js


;// CONCATENATED MODULE: ./src/blocks/components/icon/index.js


var _excluded = ["type", "name", "className", "size"];

function icon_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function icon_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? icon_ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : icon_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }






var controlIcons = ['text-align-left', 'text-align-right', 'orientation-horizontal', 'orientation-vertical', 'text-align-center', 'text-align-justify', 'align-top', 'align-middle', 'align-bottom', 'align-space-between', 'align-center', 'align-left', 'align-right', 'chevron-down', 'chevron-up', 'question-mark', 'remove-o', 'toggle-off', 'toggle-on', 'un-link', 'chevron-up-circle', 'chevron-down-circle', 'cog', 'color', 'desktop', 'gradient', 'image', 'link', 'lock', 'mobile', 'tablet', 'play', 'reset', 'star', 'upload', 'video', 'pencil', 'trash', 'filled', 'outline', 'plain', 'paste', 'copy', 'link-o'];
var frontendIcons = ['arrow-down', 'arrow-left', 'arrow-right', 'arrow-up', 'bars-o', 'cart-o', 'chevron-down', 'chevron-left', 'chevron-right', 'chevron-up', 'envelope-o', 'eye-o', 'instagram-o', 'map-marker-o', 'phone-o', 'paper-plane-o', 'quote-left', 'quote-right', 'recorder-o', 'remove-o', 'search-minus', 'search-o', 'send-o', 'thumbs-up-o', 'time-o', 'user-o', 'youtube-play', 'bar', 'behance', 'blogger', 'check', 'close', 'codeopen', 'cog', 'delicious', 'devianart', 'dribble', 'facebook', 'linkedin', 'medium', 'minus', 'pencil', 'pinterest', 'plus', 'quora', 'reddit', 'reply', 'rss', 'tumblr', 'twitch', 'twitter', 'vimeo', 'wordpress', 'yelp'];
var blockIcons = ['icon-list', 'social-icons', 'info-box', 'button', 'carousel', 'counter', 'divider', 'faq', 'form', 'map', 'heading', 'icon', 'image', 'paragraph', 'rating', 'section', 'spacing', 'teams', 'testimonial', 'video', 'column', 'buttons'];
/* harmony default export */ const components_icon = (function (_ref) {
  var type = _ref.type,
      name = _ref.name,
      _ref$className = _ref.className,
      className = _ref$className === void 0 ? '' : _ref$className,
      _ref$size = _ref.size,
      size = _ref$size === void 0 ? 24 : _ref$size,
      otherProps = _objectWithoutProperties(_ref, _excluded);

  if (!name || !type || ![].concat(frontendIcons, blockIcons, controlIcons).includes(name)) {
    return null;
  }

  var icon = name.split('-').map(function (n, idx) {
    return 0 === idx ? n : ucFirst(n);
  }).join('');

  if (!icons_namespaceObject[icon]) {
    return null;
  }

  var appliedProps = icon_objectSpread(icon_objectSpread({
    width: size,
    height: size
  }, icons_namespaceObject[icon].props), {}, {
    className: classnames_default()('blockart-icon', className)
  }, otherProps);

  return (0,external_wp_element_namespaceObject.createElement)(external_wp_components_namespaceObject.SVG, appliedProps);
});
;// CONCATENATED MODULE: ./src/blocks/hooks/use-click-outside.js

/**
 * useClickOutside custom hook.
 *
 * @callback callback
 * @param {Object} elRef Element reference.
 * @param {callback} callback Function callback.
 * @param {Object|null} extraElRef Element reference.
 */

/* harmony default export */ const use_click_outside = (function (elRef, callback) {
  var extraElRef = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
  var callbackRef = (0,external_wp_element_namespaceObject.useRef)();
  callbackRef.current = callback;
  (0,external_wp_element_namespaceObject.useEffect)(function () {
    var handleClickOutside = function handleClickOutside(e) {
      if (!document.body.contains(elRef.current) || !elRef.current || elRef.current.contains(e.target) || !callbackRef.current || null !== extraElRef && extraElRef.current.contains(e.target)) {
        return;
      }

      callbackRef.current(e);
    };

    document.addEventListener('click', handleClickOutside, true);
    return function () {
      document.removeEventListener('click', handleClickOutside, true);
    };
  }, [callbackRef, elRef]);
});
;// CONCATENATED MODULE: ./src/blocks/hooks/use-local-storage.js


/* harmony default export */ const use_local_storage = (function (keyName, defaultValue) {
  var _useState = (0,external_wp_element_namespaceObject.useState)(function () {
    try {
      var value = window.localStorage.getItem(keyName);

      if (value) {
        return JSON.parse(value);
      }

      window.localStorage.setItem(keyName, JSON.stringify(defaultValue));
      return defaultValue;
    } catch (err) {
      return defaultValue;
    }
  }),
      _useState2 = slicedToArray_slicedToArray(_useState, 2),
      storedValue = _useState2[0],
      setStoredValue = _useState2[1];

  var setValue = function setValue(newValue) {
    try {
      window.localStorage.setItem(keyName, JSON.stringify(newValue));
    } catch (err) {}

    setStoredValue(newValue);
    window.dispatchEvent(new Event(keyName));
  };

  return [storedValue, setValue];
});
;// CONCATENATED MODULE: ./src/blocks/hooks/use-session-storage.js


/* harmony default export */ const use_session_storage = (function (keyName, defaultValue) {
  var _useState = (0,external_wp_element_namespaceObject.useState)(function () {
    try {
      var value = window.sessionStorage.getItem(keyName);

      if (value) {
        return JSON.parse(value);
      }

      window.sessionStorage.setItem(keyName, JSON.stringify(defaultValue));
      return defaultValue;
    } catch (err) {
      return defaultValue;
    }
  }),
      _useState2 = slicedToArray_slicedToArray(_useState, 2),
      storedValue = _useState2[0],
      setStoredValue = _useState2[1];

  var setValue = function setValue(newValue) {
    try {
      window.sessionStorage.setItem(keyName, JSON.stringify(newValue));
    } catch (err) {}

    setStoredValue(newValue);
    window.dispatchEvent(new Event(keyName));
  };

  return [storedValue, setValue];
});
;// CONCATENATED MODULE: ./src/blocks/hooks/use-portal.js


/* harmony default export */ const use_portal = (function (element) {
  var _useState = useState({
    render: function render() {
      return null;
    },
    remove: function remove() {
      return null;
    }
  }),
      _useState2 = _slicedToArray(_useState, 2),
      portal = _useState2[0],
      setPortal = _useState2[1];

  var makePortal = useCallback(function (el) {
    var Portal = function Portal(_ref) {
      var children = _ref.children;
      return createPortal(children, el);
    };

    var remove = function remove() {
      return unmountComponentAtNode(el);
    };

    return {
      render: Portal,
      remove: remove
    };
  }, []);
  useEffect(function () {
    if (element) portal.remove();
    var newPortal = makePortal(element);
    setPortal(newPortal);
    return function () {
      newPortal.remove(element);
    };
  }, [element]);
  return portal.render;
});
;// CONCATENATED MODULE: ./src/blocks/hooks/use-block-style.js


/* harmony default export */ const use_block_style = (function (_ref) {
  var clientId = _ref.clientId,
      blockName = _ref.blockName,
      deviceType = _ref.deviceType,
      attributes = _ref.attributes;
  return (0,external_wp_element_namespaceObject.useMemo)(function () {
    var _wp;

    var css = generate_block_css({
      settings: attributes,
      blockName: blockName,
      blockID: clientId,
      deviceType: deviceType
    });

    if ('customize' === window.pagenow && (_wp = wp) !== null && _wp !== void 0 && _wp.customize) {
      var injectStyle = function injectStyle() {
        var doc = wp.customize.previewer.targetWindow().document;

        if (doc) {
          var style = Object.assign(document.createElement('style'), {
            id: "blockart-".concat(blockName, "-").concat(clientId, "-css"),
            innerHTML: css
          });
          var styleEl = doc.getElementById("blockart-".concat(blockName, "-").concat(clientId, "-css"));

          if (styleEl) {
            styleEl.remove();
          }

          doc.head.appendChild(style);
        }
      };

      injectStyle(); // For instant live preview.

      wp.customize.previewer.bind('ready', injectStyle); // If preview iframe is refreshed.
    }

    return function () {
      if (!clientId || !css) return null;
      return /*#__PURE__*/React.createElement("style", null, css);
    };
  }, [clientId, blockName, deviceType, attributes]);
});
;// CONCATENATED MODULE: ./src/blocks/hooks/index.js





;// CONCATENATED MODULE: ./src/blocks/hoc/with-copy-paste-styles.js






function with_copy_paste_styles_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function with_copy_paste_styles_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? with_copy_paste_styles_ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : with_copy_paste_styles_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }










var IGNORED_ATTRIBUTES_FOR_COPY_PASTE_STYLES = ['clientId', 'className', 'cssID', 'text', 'link', 'icon', 'hasModal', 'modalOnly', 'columns', 'childRow', 'markup', 'blockCSS', 'image', 'alt1', 'alt2', 'colWidth'];
/* harmony default export */ const with_copy_paste_styles = ((0,external_wp_compose_namespaceObject.createHigherOrderComponent)(function (Component) {
  return function (props) {
    var forceUpdate = (0,external_wp_element_namespaceObject.useState)()[1].bind(null, {});

    var _useLocalStorage = use_local_storage('_blockart_copied_styles', []),
        _useLocalStorage2 = slicedToArray_slicedToArray(_useLocalStorage, 2),
        copiedStyles = _useLocalStorage2[0],
        setCopiedStyles = _useLocalStorage2[1];

    copiedStyles = new Map(copiedStyles);
    (0,external_wp_element_namespaceObject.useEffect)(function () {
      var _dispatch = (0,external_wp_data_namespaceObject.dispatch)('core/keyboard-shortcuts'),
          registerShortcut = _dispatch.registerShortcut,
          unregisterShortcut = _dispatch.unregisterShortcut;

      registerShortcut({
        name: 'blockart/copy-styles',
        category: 'block',
        description: (0,external_wp_i18n_namespaceObject.__)('Copy block styles', 'blockart'),
        keyCombination: {
          modifier: 'ctrl',
          character: 'c'
        }
      });
      registerShortcut({
        name: 'blockart/paste-styles',
        category: 'block',
        description: (0,external_wp_i18n_namespaceObject.__)('Paste block styles', 'blockart'),
        keyCombination: {
          modifier: 'primaryAlt',
          character: 'v'
        }
      });
      var button = copiedStyles.get('blockart/button');

      if (button !== null && button !== void 0 && button.style) {
        copiedStyles["delete"]('blockart/button');
        copiedStyles.set('blockart/button-inner', button);
        setCopiedStyles(_toConsumableArray(copiedStyles.entries()));
      }

      return function () {
        unregisterShortcut('blockart/copy-styles');
        unregisterShortcut('blockart/paste-styles');
      };
    }, []);

    var _useSelect = (0,external_wp_data_namespaceObject.useSelect)(function (selector) {
      var _selector = selector('core/keyboard-shortcuts'),
          getAllShortcutKeyCombinations = _selector.getAllShortcutKeyCombinations,
          getAllShortcutRawKeyCombinations = _selector.getAllShortcutRawKeyCombinations;

      var _selector2 = selector('core/block-editor'),
          getSelectedBlockClientId = _selector2.getSelectedBlockClientId,
          getBlockAttributes = _selector2.getBlockAttributes,
          getBlockName = _selector2.getBlockName;

      return {
        allShortcutKeys: getAllShortcutKeyCombinations || getAllShortcutRawKeyCombinations,
        clientId: getSelectedBlockClientId(),
        getAttributes: getBlockAttributes,
        blockName: getSelectedBlockClientId() && getBlockName(getSelectedBlockClientId())
      };
    }, []),
        allShortcutKeys = _useSelect.allShortcutKeys,
        clientId = _useSelect.clientId,
        getAttributes = _useSelect.getAttributes,
        blockName = _useSelect.blockName;

    var copyStyles = function copyStyles() {
      var _getAttributes;

      var styles = {};
      var attributes = (_getAttributes = getAttributes(clientId)) !== null && _getAttributes !== void 0 ? _getAttributes : {};

      for (var _i = 0, _Object$keys = Object.keys(attributes); _i < _Object$keys.length; _i++) {
        var attribute = _Object$keys[_i];

        if (!IGNORED_ATTRIBUTES_FOR_COPY_PASTE_STYLES.includes(attribute)) {
          styles[attribute] = attributes[attribute];
        }
      }

      copiedStyles.set(blockName, styles);
      setCopiedStyles(_toConsumableArray(copiedStyles.entries()));
      forceUpdate();
    };

    var pasteStyles = function pasteStyles() {
      var _dispatch2 = (0,external_wp_data_namespaceObject.dispatch)('core/block-editor'),
          updateBlockAttributes = _dispatch2.updateBlockAttributes;

      var styles = copiedStyles.get(blockName);

      if (styles) {
        updateBlockAttributes(clientId, with_copy_paste_styles_objectSpread({}, styles));
      }
    };

    var isMatch = function isMatch(name, event) {
      return allShortcutKeys(name).some(function (_ref) {
        var modifier, character;

        if ('object' === typeof_typeof(_ref)) {
          modifier = _ref === null || _ref === void 0 ? void 0 : _ref.modifier;
          character = _ref === null || _ref === void 0 ? void 0 : _ref.character;
        } else if ('string' === typeof _ref) {
          if ('ctrl+c' === _ref) {
            modifier = 'ctrl';
            character = 'c';
          } else if ('ctrl+alt+v' === _ref) {
            modifier = 'primaryAlt';
            character = 'v';
          }
        }

        if (modifier && character) {
          return external_wp_keycodes_namespaceObject.isKeyboardEvent[modifier](event, character);
        }

        return false;
      });
    };

    (0,external_wp_keyboardShortcuts_namespaceObject.useShortcut)('blockart/copy-styles', (0,external_wp_element_namespaceObject.useCallback)(function (event) {
      if (blockName !== null && blockName !== void 0 && blockName.includes('blockart') && isMatch('blockart/copy-styles', event)) {
        copyStyles(getAttributes(clientId));
      }
    }, [copyStyles, clientId, blockName]), {
      bindGlobal: true,
      eventName: 'keydown'
    });
    (0,external_wp_keyboardShortcuts_namespaceObject.useShortcut)('blockart/paste-styles', (0,external_wp_element_namespaceObject.useCallback)(function (event) {
      if (blockName !== null && blockName !== void 0 && blockName.includes('blockart') && isMatch('blockart/paste-styles', event)) {
        pasteStyles();
      }
    }, [pasteStyles, clientId, blockName]), {
      bindGlobal: true,
      eventName: 'keydown'
    });
    var CopyPasteStylesBlockControl = (0,external_wp_element_namespaceObject.useMemo)(function () {
      return function () {
        return /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.ToolbarGroup, {
          isCollapsed: true,
          icon: /*#__PURE__*/React.createElement(components_icon, {
            type: "controlIcon",
            name: "copy"
          }),
          label: (0,external_wp_i18n_namespaceObject.__)('Copy/Paste Styles', 'blockart'),
          popoverProps: {
            position: 'bottom right'
          },
          controls: [{
            title: /*#__PURE__*/React.createElement("span", null, (0,external_wp_i18n_namespaceObject.__)('Copy Styles Ctrl+C', 'blockart')),
            icon: /*#__PURE__*/React.createElement(components_icon, {
              type: "controlIcon",
              name: "copy"
            }),
            onClick: copyStyles
          }, {
            title: /*#__PURE__*/React.createElement("span", null, (0,external_wp_i18n_namespaceObject.__)('Paste Styles Ctrl+Alt+V', 'blockart')),
            icon: /*#__PURE__*/React.createElement(components_icon, {
              type: "controlIcon",
              name: "paste"
            }),
            onClick: pasteStyles,
            isDisabled: !copiedStyles.get(blockName)
          }]
        });
      };
    }, [copyStyles, pasteStyles, blockName, clientId]);
    return /*#__PURE__*/React.createElement(Component, _extends({}, props, {
      copyPasteStylesBlockControl: CopyPasteStylesBlockControl
    }));
  };
}, 'withCopyPasteStyles'));
;// CONCATENATED MODULE: ./src/blocks/hoc/with-device-type.js











/* harmony default export */ const with_device_type = ((0,external_wp_compose_namespaceObject.createHigherOrderComponent)(function (Component) {
  return function (props) {
    var _useSessionStorage = use_session_storage('_blockart_device', 'desktop'),
        _useSessionStorage2 = slicedToArray_slicedToArray(_useSessionStorage, 2),
        device = _useSessionStorage2[0],
        setDevice = _useSessionStorage2[1];

    var store = 'site-editor' === window.pagenow ? 'core/edit-site' : 'core/edit-post';

    var setDeviceType = function setDeviceType(deviceType) {
      var _dispatch, _wp, _wp$customize;

      (_dispatch = (0,external_wp_data_namespaceObject.dispatch)(store)) === null || _dispatch === void 0 ? void 0 : _dispatch.__experimentalSetPreviewDeviceType(ucFirst(deviceType));
      (_wp = wp) === null || _wp === void 0 ? void 0 : (_wp$customize = _wp.customize) === null || _wp$customize === void 0 ? void 0 : _wp$customize.previewedDevice(deviceType);
      setDevice(deviceType);
    };

    var deviceType = (0,external_wp_data_namespaceObject.useSelect)(function (select) {
      var _select$__experimenta, _select, _select$__experimenta2;

      return (_select$__experimenta = (_select = select(store)) === null || _select === void 0 ? void 0 : (_select$__experimenta2 = _select.__experimentalGetPreviewDeviceType()) === null || _select$__experimenta2 === void 0 ? void 0 : _select$__experimenta2.toLowerCase()) !== null && _select$__experimenta !== void 0 ? _select$__experimenta : device;
    }, []);
    (0,external_wp_element_namespaceObject.useEffect)(function () {
      var reset = function reset() {
        return setDevice('desktop');
      };

      window.addEventListener('load', reset);
      return function () {
        window.removeEventListener('load', reset);
      };
    }, []);
    var DeviceSelector = (0,external_wp_element_namespaceObject.useMemo)(function () {
      return function () {
        return /*#__PURE__*/React.createElement("div", {
          className: "blockart-device-selector"
        }, /*#__PURE__*/React.createElement("div", {
          className: "blockart-devices",
          role: "group"
        }, Object.entries(DEVICES).map(function (_ref, idx) {
          var _ref2 = slicedToArray_slicedToArray(_ref, 2),
              deviceKey = _ref2[0],
              deviceValue = _ref2[1];

          return /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Tooltip, {
            key: deviceKey + idx,
            text: deviceValue,
            position: "top",
            delay: 300
          }, /*#__PURE__*/React.createElement("button", {
            className: classnames_default()('blockart-device', {
              active: deviceKey === deviceType
            }),
            onClick: function onClick() {
              return setDeviceType(deviceKey);
            }
          }, /*#__PURE__*/React.createElement(components_icon, {
            type: "controlIcon",
            name: deviceKey,
            size: 20
          })));
        })));
      };
    }, [deviceType]);
    return /*#__PURE__*/React.createElement(Component, _extends({}, props, {
      deviceType: deviceType,
      setDeviceType: setDeviceType,
      deviceSelector: DeviceSelector
    }));
  };
}, 'withDeviceType'));
;// CONCATENATED MODULE: ./src/blocks/hoc/with-library-data.js






function with_library_data_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function with_library_data_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? with_library_data_ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : with_library_data_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }





/* harmony default export */ const with_library_data = ((0,external_wp_compose_namespaceObject.createHigherOrderComponent)(function (Component) {
  return function (props) {
    var _useLocalStorage = use_local_storage('_blockart_library_data', []),
        _useLocalStorage2 = slicedToArray_slicedToArray(_useLocalStorage, 2),
        libraryData = _useLocalStorage2[0],
        setLibraryData = _useLocalStorage2[1];

    libraryData = new Map(libraryData);

    var initLibraryData = function initLibraryData() {
      var refresh = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;
      var timestamp = new Date().getTime();
      var expires = libraryData.get('expires');
      var args = new FormData();
      args.append('action', 'blockart_get_library_data');
      args.append('security', _BLOCKART_.nonce);
      args.append('refresh', refresh);

      if ('success' !== libraryData.get('status') || refresh || expires && timestamp >= expires) {
        libraryData.set('status', 'fetching');
        libraryData.set('expires', timestamp + 1209600000);
        external_wp_apiFetch_default()({
          url: _BLOCKART_.ajaxUrl,
          method: 'POST',
          credentials: 'same-origin',
          body: args
        }).then(function (res) {
          if (res.success) {
            var d = JSON.parse(res.data);

            if (!d || 'object' !== typeof_typeof(d)) {
              libraryData.set('status', 'failed');
              return;
            }

            var sections = d.sections,
                templates = d.templates;
            libraryData.set('sections', sections);
            libraryData.set('starter-packs', Object.values(templates));
            libraryData.set('templates', Object.values(templates).reduce(function (acc, curr) {
              acc = [].concat(_toConsumableArray(acc), _toConsumableArray(curr.children.map(function (c) {
                return with_library_data_objectSpread(with_library_data_objectSpread({}, c), {}, {
                  post_title: curr.post_title + ' ' + c.post_title
                });
              })));
              return acc;
            }, []).sort(function (a, b) {
              return a.ID - b.ID;
            }));
            libraryData.set('status', 'success');
          } else {
            libraryData.set('status', 'failed');
          }
        })["catch"](function () {
          libraryData.set('status', 'failed');
        })["finally"](function () {
          setLibraryData(_toConsumableArray(libraryData.entries()));
        });
      }
    };

    (0,external_wp_element_namespaceObject.useEffect)(function () {
      initLibraryData();
    }, []);
    return /*#__PURE__*/React.createElement(Component, _extends({}, props, {
      libraryData: libraryData,
      initLibraryData: initLibraryData
    }));
  };
}, 'withLibraryData'));
;// CONCATENATED MODULE: ./src/blocks/hoc/index.js




;// CONCATENATED MODULE: ./src/blocks/components/advance-select/index.js







/* harmony default export */ const advance_select = ((0,external_wp_compose_namespaceObject.compose)([external_wp_compose_namespaceObject.withInstanceId, with_device_type])(function (_ref) {
  var id = _ref.instanceId,
      _ref$value = _ref.value,
      value = _ref$value === void 0 ? {} : _ref$value,
      _ref$onChange = _ref.onChange,
      onChange = _ref$onChange === void 0 ? function () {} : _ref$onChange,
      _ref$responsive = _ref.responsive,
      responsive = _ref$responsive === void 0 ? false : _ref$responsive,
      label = _ref.label,
      options = _ref.options,
      _ref$inline = _ref.inline,
      inline = _ref$inline === void 0 ? false : _ref$inline,
      deviceType = _ref.deviceType,
      DeviceSelector = _ref.deviceSelector;
  return /*#__PURE__*/React.createElement("div", {
    className: classnames_default()('blockart-control', 'blockart-advance-select', {
      'blockart-responsive': responsive
    }, {
      'blockart-inline': !responsive && inline
    })
  }, /*#__PURE__*/React.createElement("div", {
    className: "blockart-control-head blockart-advance-select-head"
  }, label && /*#__PURE__*/React.createElement("label", {
    htmlFor: "blockart-advance-select-".concat(id),
    className: "blockart-control-label blockart-advance-select-label"
  }, label), responsive && /*#__PURE__*/React.createElement(DeviceSelector, null)), /*#__PURE__*/React.createElement("div", {
    className: "blockart-control-body blockart-advance-select-body"
  }, /*#__PURE__*/React.createElement("div", {
    className: "blockart-advance-select-items",
    role: "group"
  }, responsive ? ['desktop', 'tablet', 'mobile'].map(function (device) {
    return deviceType === device && options.map(function (option) {
      return /*#__PURE__*/React.createElement("div", {
        key: option.value,
        className: "blockart-advance-select-item"
      }, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Tooltip, {
        text: option.label,
        position: "top",
        delay: 300
      }, /*#__PURE__*/React.createElement("button", {
        id: 'blockart-button-' + option.value,
        className: classnames_default()('blockart-button', {
          'is-active': value[device] === option.value
        }),
        onClick: function onClick() {
          onChange(Object.assign({}, value, _defineProperty({}, device, option.value === value[device] ? undefined : option.value)));
        }
      }, /*#__PURE__*/React.createElement(components_icon, {
        type: "controlIcon",
        name: option.icon
      }))));
    });
  }) : options.map(function (option) {
    return /*#__PURE__*/React.createElement("div", {
      key: option.value,
      className: "blockart-advance-select-item"
    }, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Tooltip, {
      content: option.label,
      position: "top"
    }, /*#__PURE__*/React.createElement("button", {
      id: 'blockart-button-' + option.value,
      className: classnames_default()('blockart-button', 'blockart-advance-select-item', {
        'is-active': value === option.value
      }),
      onClick: function onClick() {
        return onChange(value === option.value ? undefined : option.value);
      }
    }, /*#__PURE__*/React.createElement(components_icon, {
      type: "controlIcon",
      name: option.icon
    }))));
  }))));
}));
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/objectSpread2.js


function objectSpread2_ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);
    enumerableOnly && (symbols = symbols.filter(function (sym) {
      return Object.getOwnPropertyDescriptor(object, sym).enumerable;
    })), keys.push.apply(keys, symbols);
  }

  return keys;
}

function _objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = null != arguments[i] ? arguments[i] : {};
    i % 2 ? objectSpread2_ownKeys(Object(source), !0).forEach(function (key) {
      _defineProperty(target, key, source[key]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : objectSpread2_ownKeys(Object(source)).forEach(function (key) {
      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
    });
  }

  return target;
}
;// CONCATENATED MODULE: external "React"
const external_React_namespaceObject = window["React"];
var external_React_default = /*#__PURE__*/__webpack_require__.n(external_React_namespaceObject);
;// CONCATENATED MODULE: ./node_modules/rc-util/es/hooks/useEvent.js

function useEvent(callback) {
  var fnRef = external_React_namespaceObject.useRef();
  fnRef.current = callback;
  var memoFn = external_React_namespaceObject.useCallback(function () {
    var _fnRef$current;

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    return (_fnRef$current = fnRef.current) === null || _fnRef$current === void 0 ? void 0 : _fnRef$current.call.apply(_fnRef$current, [fnRef].concat(args));
  }, []);
  return memoFn;
}
;// CONCATENATED MODULE: ./node_modules/rc-util/es/Dom/canUseDom.js
function canUseDom() {
  return !!(typeof window !== 'undefined' && window.document && window.document.createElement);
}
;// CONCATENATED MODULE: ./node_modules/rc-util/es/hooks/useLayoutEffect.js


/**
 * Wrap `React.useLayoutEffect` which will not throw warning message in test env
 */

var useLayoutEffect =  true && canUseDom() ? external_React_namespaceObject.useLayoutEffect : external_React_namespaceObject.useEffect;
/* harmony default export */ const hooks_useLayoutEffect = (useLayoutEffect);
var useLayoutUpdateEffect = function useLayoutUpdateEffect(callback, deps) {
  var firstMountRef = external_React_namespaceObject.useRef(true);
  useLayoutEffect(function () {
    if (!firstMountRef.current) {
      return callback();
    }
  }, deps); // We tell react that first mount has passed

  useLayoutEffect(function () {
    firstMountRef.current = false;
    return function () {
      firstMountRef.current = true;
    };
  }, []);
};
;// CONCATENATED MODULE: ./node_modules/rc-util/es/hooks/useState.js


/**
 * Same as React.useState but `setState` accept `ignoreDestroy` param to not to setState after destroyed.
 * We do not make this auto is to avoid real memory leak.
 * Developer should confirm it's safe to ignore themselves.
 */

function useSafeState(defaultValue) {
  var destroyRef = external_React_namespaceObject.useRef(false);

  var _React$useState = external_React_namespaceObject.useState(defaultValue),
      _React$useState2 = slicedToArray_slicedToArray(_React$useState, 2),
      value = _React$useState2[0],
      setValue = _React$useState2[1];

  external_React_namespaceObject.useEffect(function () {
    destroyRef.current = false;
    return function () {
      destroyRef.current = true;
    };
  }, []);

  function safeSetState(updater, ignoreDestroy) {
    if (ignoreDestroy && destroyRef.current) {
      return;
    }

    setValue(updater);
  }

  return [value, safeSetState];
}
;// CONCATENATED MODULE: ./node_modules/rc-util/es/hooks/useMergedState.js





var Source;

(function (Source) {
  Source[Source["INNER"] = 0] = "INNER";
  Source[Source["PROP"] = 1] = "PROP";
})(Source || (Source = {}));
/** We only think `undefined` is empty */


function hasValue(value) {
  return value !== undefined;
}
/**
 * Similar to `useState` but will use props value if provided.
 * Note that internal use rc-util `useState` hook.
 */


function useMergedState(defaultStateValue, option) {
  var _ref = option || {},
      defaultValue = _ref.defaultValue,
      value = _ref.value,
      onChange = _ref.onChange,
      postState = _ref.postState; // ======================= Init =======================


  var _useState = useSafeState(function () {
    var finalValue = undefined;
    var source;

    if (hasValue(value)) {
      finalValue = value;
      source = Source.PROP;
    } else if (hasValue(defaultValue)) {
      finalValue = typeof defaultValue === 'function' ? defaultValue() : defaultValue;
      source = Source.PROP;
    } else {
      finalValue = typeof defaultStateValue === 'function' ? defaultStateValue() : defaultStateValue;
      source = Source.INNER;
    }

    return [finalValue, source, finalValue];
  }),
      _useState2 = slicedToArray_slicedToArray(_useState, 2),
      mergedValue = _useState2[0],
      setMergedValue = _useState2[1];

  var chosenValue = hasValue(value) ? value : mergedValue[0];
  var postMergedValue = postState ? postState(chosenValue) : chosenValue; // ======================= Sync =======================

  useLayoutUpdateEffect(function () {
    setMergedValue(function (_ref2) {
      var _ref3 = slicedToArray_slicedToArray(_ref2, 1),
          prevValue = _ref3[0];

      return [value, Source.PROP, prevValue];
    });
  }, [value]); // ====================== Update ======================

  var changeEventPrevRef = external_React_namespaceObject.useRef();
  var triggerChange = useEvent(function (updater, ignoreDestroy) {
    setMergedValue(function (prev) {
      var _prev = slicedToArray_slicedToArray(prev, 3),
          prevValue = _prev[0],
          prevSource = _prev[1],
          prevPrevValue = _prev[2];

      var nextValue = typeof updater === 'function' ? updater(prevValue) : updater; // Do nothing if value not change

      if (nextValue === prevValue) {
        return prev;
      } // Use prev prev value if is in a batch update to avoid missing data


      var overridePrevValue = prevSource === Source.INNER && changeEventPrevRef.current !== prevPrevValue ? prevPrevValue : prevValue;
      return [nextValue, Source.INNER, overridePrevValue];
    }, ignoreDestroy);
  }); // ====================== Change ======================

  var onChangeFn = useEvent(onChange);
  hooks_useLayoutEffect(function () {
    var _mergedValue = slicedToArray_slicedToArray(mergedValue, 3),
        current = _mergedValue[0],
        source = _mergedValue[1],
        prev = _mergedValue[2];

    if (current !== prev && source === Source.INNER) {
      onChangeFn(current, prev);
      changeEventPrevRef.current = prev;
    }
  }, [mergedValue]);
  return [postMergedValue, triggerChange];
}
;// CONCATENATED MODULE: ./node_modules/rc-util/es/warning.js
/* eslint-disable no-console */
var warned = {};
function warning_warning(valid, message) {
  // Support uglify
  if (false) {}
}
function note(valid, message) {
  // Support uglify
  if (false) {}
}
function resetWarned() {
  warned = {};
}
function call(method, valid, message) {
  if (!valid && !warned[message]) {
    method(false, message);
    warned[message] = true;
  }
}
function warningOnce(valid, message) {
  call(warning_warning, valid, message);
}
function warning_noteOnce(valid, message) {
  call(note, valid, message);
}
/* harmony default export */ const es_warning = (warningOnce);
/* eslint-enable */
;// CONCATENATED MODULE: ./node_modules/rc-util/es/KeyCode.js
/**
 * @ignore
 * some key-codes definition and utils from closure-library
 * @author yiminghe@gmail.com
 */
var KeyCode = {
  /**
   * MAC_ENTER
   */
  MAC_ENTER: 3,

  /**
   * BACKSPACE
   */
  BACKSPACE: 8,

  /**
   * TAB
   */
  TAB: 9,

  /**
   * NUMLOCK on FF/Safari Mac
   */
  NUM_CENTER: 12,

  /**
   * ENTER
   */
  ENTER: 13,

  /**
   * SHIFT
   */
  SHIFT: 16,

  /**
   * CTRL
   */
  CTRL: 17,

  /**
   * ALT
   */
  ALT: 18,

  /**
   * PAUSE
   */
  PAUSE: 19,

  /**
   * CAPS_LOCK
   */
  CAPS_LOCK: 20,

  /**
   * ESC
   */
  ESC: 27,

  /**
   * SPACE
   */
  SPACE: 32,

  /**
   * PAGE_UP
   */
  PAGE_UP: 33,

  /**
   * PAGE_DOWN
   */
  PAGE_DOWN: 34,

  /**
   * END
   */
  END: 35,

  /**
   * HOME
   */
  HOME: 36,

  /**
   * LEFT
   */
  LEFT: 37,

  /**
   * UP
   */
  UP: 38,

  /**
   * RIGHT
   */
  RIGHT: 39,

  /**
   * DOWN
   */
  DOWN: 40,

  /**
   * PRINT_SCREEN
   */
  PRINT_SCREEN: 44,

  /**
   * INSERT
   */
  INSERT: 45,

  /**
   * DELETE
   */
  DELETE: 46,

  /**
   * ZERO
   */
  ZERO: 48,

  /**
   * ONE
   */
  ONE: 49,

  /**
   * TWO
   */
  TWO: 50,

  /**
   * THREE
   */
  THREE: 51,

  /**
   * FOUR
   */
  FOUR: 52,

  /**
   * FIVE
   */
  FIVE: 53,

  /**
   * SIX
   */
  SIX: 54,

  /**
   * SEVEN
   */
  SEVEN: 55,

  /**
   * EIGHT
   */
  EIGHT: 56,

  /**
   * NINE
   */
  NINE: 57,

  /**
   * QUESTION_MARK
   */
  QUESTION_MARK: 63,

  /**
   * A
   */
  A: 65,

  /**
   * B
   */
  B: 66,

  /**
   * C
   */
  C: 67,

  /**
   * D
   */
  D: 68,

  /**
   * E
   */
  E: 69,

  /**
   * F
   */
  F: 70,

  /**
   * G
   */
  G: 71,

  /**
   * H
   */
  H: 72,

  /**
   * I
   */
  I: 73,

  /**
   * J
   */
  J: 74,

  /**
   * K
   */
  K: 75,

  /**
   * L
   */
  L: 76,

  /**
   * M
   */
  M: 77,

  /**
   * N
   */
  N: 78,

  /**
   * O
   */
  O: 79,

  /**
   * P
   */
  P: 80,

  /**
   * Q
   */
  Q: 81,

  /**
   * R
   */
  R: 82,

  /**
   * S
   */
  S: 83,

  /**
   * T
   */
  T: 84,

  /**
   * U
   */
  U: 85,

  /**
   * V
   */
  V: 86,

  /**
   * W
   */
  W: 87,

  /**
   * X
   */
  X: 88,

  /**
   * Y
   */
  Y: 89,

  /**
   * Z
   */
  Z: 90,

  /**
   * META
   */
  META: 91,

  /**
   * WIN_KEY_RIGHT
   */
  WIN_KEY_RIGHT: 92,

  /**
   * CONTEXT_MENU
   */
  CONTEXT_MENU: 93,

  /**
   * NUM_ZERO
   */
  NUM_ZERO: 96,

  /**
   * NUM_ONE
   */
  NUM_ONE: 97,

  /**
   * NUM_TWO
   */
  NUM_TWO: 98,

  /**
   * NUM_THREE
   */
  NUM_THREE: 99,

  /**
   * NUM_FOUR
   */
  NUM_FOUR: 100,

  /**
   * NUM_FIVE
   */
  NUM_FIVE: 101,

  /**
   * NUM_SIX
   */
  NUM_SIX: 102,

  /**
   * NUM_SEVEN
   */
  NUM_SEVEN: 103,

  /**
   * NUM_EIGHT
   */
  NUM_EIGHT: 104,

  /**
   * NUM_NINE
   */
  NUM_NINE: 105,

  /**
   * NUM_MULTIPLY
   */
  NUM_MULTIPLY: 106,

  /**
   * NUM_PLUS
   */
  NUM_PLUS: 107,

  /**
   * NUM_MINUS
   */
  NUM_MINUS: 109,

  /**
   * NUM_PERIOD
   */
  NUM_PERIOD: 110,

  /**
   * NUM_DIVISION
   */
  NUM_DIVISION: 111,

  /**
   * F1
   */
  F1: 112,

  /**
   * F2
   */
  F2: 113,

  /**
   * F3
   */
  F3: 114,

  /**
   * F4
   */
  F4: 115,

  /**
   * F5
   */
  F5: 116,

  /**
   * F6
   */
  F6: 117,

  /**
   * F7
   */
  F7: 118,

  /**
   * F8
   */
  F8: 119,

  /**
   * F9
   */
  F9: 120,

  /**
   * F10
   */
  F10: 121,

  /**
   * F11
   */
  F11: 122,

  /**
   * F12
   */
  F12: 123,

  /**
   * NUMLOCK
   */
  NUMLOCK: 144,

  /**
   * SEMICOLON
   */
  SEMICOLON: 186,

  /**
   * DASH
   */
  DASH: 189,

  /**
   * EQUALS
   */
  EQUALS: 187,

  /**
   * COMMA
   */
  COMMA: 188,

  /**
   * PERIOD
   */
  PERIOD: 190,

  /**
   * SLASH
   */
  SLASH: 191,

  /**
   * APOSTROPHE
   */
  APOSTROPHE: 192,

  /**
   * SINGLE_QUOTE
   */
  SINGLE_QUOTE: 222,

  /**
   * OPEN_SQUARE_BRACKET
   */
  OPEN_SQUARE_BRACKET: 219,

  /**
   * BACKSLASH
   */
  BACKSLASH: 220,

  /**
   * CLOSE_SQUARE_BRACKET
   */
  CLOSE_SQUARE_BRACKET: 221,

  /**
   * WIN_KEY
   */
  WIN_KEY: 224,

  /**
   * MAC_FF_META
   */
  MAC_FF_META: 224,

  /**
   * WIN_IME
   */
  WIN_IME: 229,
  // ======================== Function ========================

  /**
   * whether text and modified key is entered at the same time.
   */
  isTextModifyingKeyEvent: function isTextModifyingKeyEvent(e) {
    var keyCode = e.keyCode;

    if (e.altKey && !e.ctrlKey || e.metaKey || // Function keys don't generate text
    keyCode >= KeyCode.F1 && keyCode <= KeyCode.F12) {
      return false;
    } // The following keys are quite harmless, even in combination with
    // CTRL, ALT or SHIFT.


    switch (keyCode) {
      case KeyCode.ALT:
      case KeyCode.CAPS_LOCK:
      case KeyCode.CONTEXT_MENU:
      case KeyCode.CTRL:
      case KeyCode.DOWN:
      case KeyCode.END:
      case KeyCode.ESC:
      case KeyCode.HOME:
      case KeyCode.INSERT:
      case KeyCode.LEFT:
      case KeyCode.MAC_FF_META:
      case KeyCode.META:
      case KeyCode.NUMLOCK:
      case KeyCode.NUM_CENTER:
      case KeyCode.PAGE_DOWN:
      case KeyCode.PAGE_UP:
      case KeyCode.PAUSE:
      case KeyCode.PRINT_SCREEN:
      case KeyCode.RIGHT:
      case KeyCode.SHIFT:
      case KeyCode.UP:
      case KeyCode.WIN_KEY:
      case KeyCode.WIN_KEY_RIGHT:
        return false;

      default:
        return true;
    }
  },

  /**
   * whether character is entered.
   */
  isCharacterKey: function isCharacterKey(keyCode) {
    if (keyCode >= KeyCode.ZERO && keyCode <= KeyCode.NINE) {
      return true;
    }

    if (keyCode >= KeyCode.NUM_ZERO && keyCode <= KeyCode.NUM_MULTIPLY) {
      return true;
    }

    if (keyCode >= KeyCode.A && keyCode <= KeyCode.Z) {
      return true;
    } // Safari sends zero key code for non-latin characters.


    if (window.navigator.userAgent.indexOf('WebKit') !== -1 && keyCode === 0) {
      return true;
    }

    switch (keyCode) {
      case KeyCode.SPACE:
      case KeyCode.QUESTION_MARK:
      case KeyCode.NUM_PLUS:
      case KeyCode.NUM_MINUS:
      case KeyCode.NUM_PERIOD:
      case KeyCode.NUM_DIVISION:
      case KeyCode.SEMICOLON:
      case KeyCode.DASH:
      case KeyCode.EQUALS:
      case KeyCode.COMMA:
      case KeyCode.PERIOD:
      case KeyCode.SLASH:
      case KeyCode.APOSTROPHE:
      case KeyCode.SINGLE_QUOTE:
      case KeyCode.OPEN_SQUARE_BRACKET:
      case KeyCode.BACKSLASH:
      case KeyCode.CLOSE_SQUARE_BRACKET:
        return true;

      default:
        return false;
    }
  }
};
/* harmony default export */ const es_KeyCode = (KeyCode);
;// CONCATENATED MODULE: ./node_modules/rc-util/es/isMobile.js
/* harmony default export */ const isMobile = (function () {
  if (typeof navigator === 'undefined' || typeof window === 'undefined') {
    return false;
  }

  var agent = navigator.userAgent || navigator.vendor || window.opera;

  if (/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino|android|ipad|playbook|silk/i.test(agent) || /1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw-(n|u)|c55\/|capi|ccwa|cdm-|cell|chtm|cldc|cmd-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc-s|devi|dica|dmob|do(c|p)o|ds(12|-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(-|_)|g1 u|g560|gene|gf-5|g-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd-(m|p|t)|hei-|hi(pt|ta)|hp( i|ip)|hs-c|ht(c(-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i-(20|go|ma)|i230|iac( |-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|-[a-w])|libw|lynx|m1-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|-([1-8]|c))|phil|pire|pl(ay|uc)|pn-2|po(ck|rt|se)|prox|psio|pt-g|qa-a|qc(07|12|21|32|60|-[2-7]|i-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h-|oo|p-)|sdk\/|se(c(-|0|1)|47|mc|nd|ri)|sgh-|shar|sie(-|m)|sk-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h-|v-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl-|tdg-|tel(i|m)|tim-|t-mo|to(pl|sh)|ts(70|m-|m3|m5)|tx-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas-|your|zeto|zte-/i.test(agent === null || agent === void 0 ? void 0 : agent.substr(0, 4))) {
    return true;
  }

  return false;
});
// EXTERNAL MODULE: ./node_modules/react-is/index.js
var react_is = __webpack_require__(9864);
;// CONCATENATED MODULE: ./node_modules/rc-util/es/hooks/useMemo.js

function useMemo(getValue, condition, shouldUpdate) {
  var cacheRef = external_React_namespaceObject.useRef({});

  if (!('value' in cacheRef.current) || shouldUpdate(cacheRef.current.condition, condition)) {
    cacheRef.current.value = getValue();
    cacheRef.current.condition = condition;
  }

  return cacheRef.current.value;
}
;// CONCATENATED MODULE: ./node_modules/rc-util/es/ref.js



function fillRef(ref, node) {
  if (typeof ref === 'function') {
    ref(node);
  } else if (typeof_typeof(ref) === 'object' && ref && 'current' in ref) {
    ref.current = node;
  }
}
/**
 * Merge refs into one ref function to support ref passing.
 */

function composeRef() {
  for (var _len = arguments.length, refs = new Array(_len), _key = 0; _key < _len; _key++) {
    refs[_key] = arguments[_key];
  }

  var refList = refs.filter(function (ref) {
    return ref;
  });

  if (refList.length <= 1) {
    return refList[0];
  }

  return function (node) {
    refs.forEach(function (ref) {
      fillRef(ref, node);
    });
  };
}
function useComposeRef() {
  for (var _len2 = arguments.length, refs = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {
    refs[_key2] = arguments[_key2];
  }

  return useMemo(function () {
    return composeRef.apply(void 0, refs);
  }, refs, function (prev, next) {
    return prev.length === next.length && prev.every(function (ref, i) {
      return ref === next[i];
    });
  });
}
function supportRef(nodeOrComponent) {
  var _type$prototype, _nodeOrComponent$prot;

  var type = (0,react_is.isMemo)(nodeOrComponent) ? nodeOrComponent.type.type : nodeOrComponent.type; // Function component node

  if (typeof type === 'function' && !((_type$prototype = type.prototype) === null || _type$prototype === void 0 ? void 0 : _type$prototype.render)) {
    return false;
  } // Class component


  if (typeof nodeOrComponent === 'function' && !((_nodeOrComponent$prot = nodeOrComponent.prototype) === null || _nodeOrComponent$prot === void 0 ? void 0 : _nodeOrComponent$prot.render)) {
    return false;
  }

  return true;
}
/* eslint-enable */
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/toArray.js




function _toArray(arr) {
  return _arrayWithHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableRest();
}
;// CONCATENATED MODULE: ./node_modules/rc-select/es/utils/valueUtil.js





function getKey(data, index) {
  var key = data.key;
  var value;

  if ('value' in data) {
    value = data.value;
  }

  if (key !== null && key !== undefined) {
    return key;
  }

  if (value !== undefined) {
    return value;
  }

  return "rc-index-key-".concat(index);
}

function fillFieldNames(fieldNames, childrenAsData) {
  var _ref = fieldNames || {},
      label = _ref.label,
      value = _ref.value,
      options = _ref.options;

  return {
    label: label || (childrenAsData ? 'children' : 'label'),
    value: value || 'value',
    options: options || 'options'
  };
}
/**
 * Flat options into flatten list.
 * We use `optionOnly` here is aim to avoid user use nested option group.
 * Here is simply set `key` to the index if not provided.
 */

function flattenOptions(options) {
  var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},
      fieldNames = _ref2.fieldNames,
      childrenAsData = _ref2.childrenAsData;

  var flattenList = [];

  var _fillFieldNames = fillFieldNames(fieldNames, false),
      fieldLabel = _fillFieldNames.label,
      fieldValue = _fillFieldNames.value,
      fieldOptions = _fillFieldNames.options;

  function dig(list, isGroupOption) {
    list.forEach(function (data) {
      var label = data[fieldLabel];

      if (isGroupOption || !(fieldOptions in data)) {
        var value = data[fieldValue]; // Option

        flattenList.push({
          key: getKey(data, flattenList.length),
          groupOption: isGroupOption,
          data: data,
          label: label,
          value: value
        });
      } else {
        var grpLabel = label;

        if (grpLabel === undefined && childrenAsData) {
          grpLabel = data.label;
        } // Option Group


        flattenList.push({
          key: getKey(data, flattenList.length),
          group: true,
          data: data,
          label: grpLabel
        });
        dig(data[fieldOptions], true);
      }
    });
  }

  dig(options, false);
  return flattenList;
}
/**
 * Inject `props` into `option` for legacy usage
 */

function injectPropsWithOption(option) {
  var newOption = _objectSpread2({}, option);

  if (!('props' in newOption)) {
    Object.defineProperty(newOption, 'props', {
      get: function get() {
        es_warning(false, 'Return type is option instead of Option instance. Please read value directly instead of reading from `props`.');
        return newOption;
      }
    });
  }

  return newOption;
}
function getSeparatedContent(text, tokens) {
  if (!tokens || !tokens.length) {
    return null;
  }

  var match = false;

  function separate(str, _ref3) {
    var _ref4 = _toArray(_ref3),
        token = _ref4[0],
        restTokens = _ref4.slice(1);

    if (!token) {
      return [str];
    }

    var list = str.split(token);
    match = match || list.length > 1;
    return list.reduce(function (prevList, unitStr) {
      return [].concat(_toConsumableArray(prevList), _toConsumableArray(separate(unitStr, restTokens)));
    }, []).filter(function (unit) {
      return unit;
    });
  }

  var list = separate(text, tokens);
  return match ? list : null;
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/classCallCheck.js
function _classCallCheck(instance, Constructor) {
  if (!(instance instanceof Constructor)) {
    throw new TypeError("Cannot call a class as a function");
  }
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/createClass.js
function _defineProperties(target, props) {
  for (var i = 0; i < props.length; i++) {
    var descriptor = props[i];
    descriptor.enumerable = descriptor.enumerable || false;
    descriptor.configurable = true;
    if ("value" in descriptor) descriptor.writable = true;
    Object.defineProperty(target, descriptor.key, descriptor);
  }
}

function _createClass(Constructor, protoProps, staticProps) {
  if (protoProps) _defineProperties(Constructor.prototype, protoProps);
  if (staticProps) _defineProperties(Constructor, staticProps);
  Object.defineProperty(Constructor, "prototype", {
    writable: false
  });
  return Constructor;
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js
function _assertThisInitialized(self) {
  if (self === void 0) {
    throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
  }

  return self;
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/setPrototypeOf.js
function _setPrototypeOf(o, p) {
  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
    o.__proto__ = p;
    return o;
  };
  return _setPrototypeOf(o, p);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/inherits.js

function _inherits(subClass, superClass) {
  if (typeof superClass !== "function" && superClass !== null) {
    throw new TypeError("Super expression must either be null or a function");
  }

  subClass.prototype = Object.create(superClass && superClass.prototype, {
    constructor: {
      value: subClass,
      writable: true,
      configurable: true
    }
  });
  Object.defineProperty(subClass, "prototype", {
    writable: false
  });
  if (superClass) _setPrototypeOf(subClass, superClass);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js
function _getPrototypeOf(o) {
  _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
    return o.__proto__ || Object.getPrototypeOf(o);
  };
  return _getPrototypeOf(o);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/isNativeReflectConstruct.js
function _isNativeReflectConstruct() {
  if (typeof Reflect === "undefined" || !Reflect.construct) return false;
  if (Reflect.construct.sham) return false;
  if (typeof Proxy === "function") return true;

  try {
    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));
    return true;
  } catch (e) {
    return false;
  }
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn.js


function _possibleConstructorReturn(self, call) {
  if (call && (typeof_typeof(call) === "object" || typeof call === "function")) {
    return call;
  } else if (call !== void 0) {
    throw new TypeError("Derived constructors may only return object or undefined");
  }

  return _assertThisInitialized(self);
}
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/createSuper.js



function _createSuper(Derived) {
  var hasNativeReflectConstruct = _isNativeReflectConstruct();
  return function _createSuperInternal() {
    var Super = _getPrototypeOf(Derived),
        result;

    if (hasNativeReflectConstruct) {
      var NewTarget = _getPrototypeOf(this).constructor;
      result = Reflect.construct(Super, arguments, NewTarget);
    } else {
      result = Super.apply(this, arguments);
    }

    return _possibleConstructorReturn(this, result);
  };
}
;// CONCATENATED MODULE: external "ReactDOM"
const external_ReactDOM_namespaceObject = window["ReactDOM"];
var external_ReactDOM_default = /*#__PURE__*/__webpack_require__.n(external_ReactDOM_namespaceObject);
;// CONCATENATED MODULE: ./node_modules/rc-util/es/raf.js
var raf = function raf(callback) {
  return +setTimeout(callback, 16);
};

var caf = function caf(num) {
  return clearTimeout(num);
};

if (typeof window !== 'undefined' && 'requestAnimationFrame' in window) {
  raf = function raf(callback) {
    return window.requestAnimationFrame(callback);
  };

  caf = function caf(handle) {
    return window.cancelAnimationFrame(handle);
  };
}

var rafUUID = 0;
var rafIds = new Map();

function cleanup(id) {
  rafIds.delete(id);
}

function wrapperRaf(callback) {
  var times = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
  rafUUID += 1;
  var id = rafUUID;

  function callRef(leftTimes) {
    if (leftTimes === 0) {
      // Clean up
      cleanup(id); // Trigger

      callback();
    } else {
      // Next raf
      var realId = raf(function () {
        callRef(leftTimes - 1);
      }); // Bind real raf id

      rafIds.set(id, realId);
    }
  }

  callRef(times);
  return id;
}

wrapperRaf.cancel = function (id) {
  var realId = rafIds.get(id);
  cleanup(realId);
  return caf(realId);
};
;// CONCATENATED MODULE: ./node_modules/rc-util/es/Dom/contains.js
function contains(root, n) {
  if (!root) {
    return false;
  }

  return root.contains(n);
}
;// CONCATENATED MODULE: ./node_modules/rc-util/es/Dom/findDOMNode.js

/**
 * Return if a node is a DOM node. Else will return by `findDOMNode`
 */

function findDOMNode(node) {
  if (node instanceof HTMLElement) {
    return node;
  }

  return external_ReactDOM_default().findDOMNode(node);
}
;// CONCATENATED MODULE: ./node_modules/rc-util/es/Dom/addEventListener.js

function addEventListenerWrap(target, eventType, cb, option) {
  /* eslint camelcase: 2 */
  var callback = (external_ReactDOM_default()).unstable_batchedUpdates ? function run(e) {
    external_ReactDOM_default().unstable_batchedUpdates(cb, e);
  } : cb;

  if (target.addEventListener) {
    target.addEventListener(eventType, callback, option);
  }

  return {
    remove: function remove() {
      if (target.removeEventListener) {
        target.removeEventListener(eventType, callback, option);
      }
    }
  };
}
;// CONCATENATED MODULE: ./node_modules/rc-util/es/Portal.js



var Portal = /*#__PURE__*/(0,external_React_namespaceObject.forwardRef)(function (props, ref) {
  var didUpdate = props.didUpdate,
      getContainer = props.getContainer,
      children = props.children;
  var parentRef = (0,external_React_namespaceObject.useRef)();
  var containerRef = (0,external_React_namespaceObject.useRef)(); // Ref return nothing, only for wrapper check exist

  (0,external_React_namespaceObject.useImperativeHandle)(ref, function () {
    return {};
  }); // Create container in client side with sync to avoid useEffect not get ref

  var initRef = (0,external_React_namespaceObject.useRef)(false);

  if (!initRef.current && canUseDom()) {
    containerRef.current = getContainer();
    parentRef.current = containerRef.current.parentNode;
    initRef.current = true;
  } // [Legacy] Used by `rc-trigger`


  (0,external_React_namespaceObject.useEffect)(function () {
    didUpdate === null || didUpdate === void 0 ? void 0 : didUpdate(props);
  });
  (0,external_React_namespaceObject.useEffect)(function () {
    // Restore container to original place
    // React 18 StrictMode will unmount first and mount back for effect test:
    // https://reactjs.org/blog/2022/03/29/react-v18.html#new-strict-mode-behaviors
    if (containerRef.current.parentNode === null && parentRef.current !== null) {
      parentRef.current.appendChild(containerRef.current);
    }

    return function () {
      var _containerRef$current, _containerRef$current2;

      // [Legacy] This should not be handle by Portal but parent PortalWrapper instead.
      // Since some component use `Portal` directly, we have to keep the logic here.
      (_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : (_containerRef$current2 = _containerRef$current.parentNode) === null || _containerRef$current2 === void 0 ? void 0 : _containerRef$current2.removeChild(containerRef.current);
    };
  }, []);
  return containerRef.current ? /*#__PURE__*/external_ReactDOM_default().createPortal(children, containerRef.current) : null;
});
/* harmony default export */ const es_Portal = (Portal);
;// CONCATENATED MODULE: ./node_modules/rc-trigger/es/utils/alignUtil.js


function isPointsEq(a1, a2, isAlignPoint) {
  if (isAlignPoint) {
    return a1[0] === a2[0];
  }

  return a1[0] === a2[0] && a1[1] === a2[1];
}

function getAlignFromPlacement(builtinPlacements, placementStr, align) {
  var baseAlign = builtinPlacements[placementStr] || {};
  return _objectSpread2(_objectSpread2({}, baseAlign), align);
}
function getAlignPopupClassName(builtinPlacements, prefixCls, align, isAlignPoint) {
  var points = align.points;
  var placements = Object.keys(builtinPlacements);

  for (var i = 0; i < placements.length; i += 1) {
    var placement = placements[i];

    if (isPointsEq(builtinPlacements[placement].points, points, isAlignPoint)) {
      return "".concat(prefixCls, "-placement-").concat(placement);
    }
  }

  return '';
}
;// CONCATENATED MODULE: ./node_modules/rc-motion/es/util/motion.js

 // ================= Transition =================
// Event wrapper. Copy from react source code

function makePrefixMap(styleProp, eventName) {
  var prefixes = {};
  prefixes[styleProp.toLowerCase()] = eventName.toLowerCase();
  prefixes["Webkit".concat(styleProp)] = "webkit".concat(eventName);
  prefixes["Moz".concat(styleProp)] = "moz".concat(eventName);
  prefixes["ms".concat(styleProp)] = "MS".concat(eventName);
  prefixes["O".concat(styleProp)] = "o".concat(eventName.toLowerCase());
  return prefixes;
}

function getVendorPrefixes(domSupport, win) {
  var prefixes = {
    animationend: makePrefixMap('Animation', 'AnimationEnd'),
    transitionend: makePrefixMap('Transition', 'TransitionEnd')
  };

  if (domSupport) {
    if (!('AnimationEvent' in win)) {
      delete prefixes.animationend.animation;
    }

    if (!('TransitionEvent' in win)) {
      delete prefixes.transitionend.transition;
    }
  }

  return prefixes;
}
var vendorPrefixes = getVendorPrefixes(canUseDom(), typeof window !== 'undefined' ? window : {});
var style = {};

if (canUseDom()) {
  var _document$createEleme = document.createElement('div');

  style = _document$createEleme.style;
}

var prefixedEventNames = {};
function getVendorPrefixedEventName(eventName) {
  if (prefixedEventNames[eventName]) {
    return prefixedEventNames[eventName];
  }

  var prefixMap = vendorPrefixes[eventName];

  if (prefixMap) {
    var stylePropList = Object.keys(prefixMap);
    var len = stylePropList.length;

    for (var i = 0; i < len; i += 1) {
      var styleProp = stylePropList[i];

      if (Object.prototype.hasOwnProperty.call(prefixMap, styleProp) && styleProp in style) {
        prefixedEventNames[eventName] = prefixMap[styleProp];
        return prefixedEventNames[eventName];
      }
    }
  }

  return '';
}
var internalAnimationEndName = getVendorPrefixedEventName('animationend');
var internalTransitionEndName = getVendorPrefixedEventName('transitionend');
var supportTransition = !!(internalAnimationEndName && internalTransitionEndName);
var animationEndName = internalAnimationEndName || 'animationend';
var transitionEndName = internalTransitionEndName || 'transitionend';
function getTransitionName(transitionName, transitionType) {
  if (!transitionName) return null;

  if (typeof_typeof(transitionName) === 'object') {
    var type = transitionType.replace(/-\w/g, function (match) {
      return match[1].toUpperCase();
    });
    return transitionName[type];
  }

  return "".concat(transitionName, "-").concat(transitionType);
}
;// CONCATENATED MODULE: ./node_modules/rc-motion/es/interface.js
var STATUS_NONE = 'none';
var STATUS_APPEAR = 'appear';
var STATUS_ENTER = 'enter';
var STATUS_LEAVE = 'leave';
var STEP_NONE = 'none';
var STEP_PREPARE = 'prepare';
var STEP_START = 'start';
var STEP_ACTIVE = 'active';
var STEP_ACTIVATED = 'end';
;// CONCATENATED MODULE: ./node_modules/rc-motion/es/hooks/useNextFrame.js


/* harmony default export */ const useNextFrame = (function () {
  var nextFrameRef = external_React_namespaceObject.useRef(null);

  function cancelNextFrame() {
    wrapperRaf.cancel(nextFrameRef.current);
  }

  function nextFrame(callback) {
    var delay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 2;
    cancelNextFrame();
    var nextFrameId = wrapperRaf(function () {
      if (delay <= 1) {
        callback({
          isCanceled: function isCanceled() {
            return nextFrameId !== nextFrameRef.current;
          }
        });
      } else {
        nextFrame(callback, delay - 1);
      }
    });
    nextFrameRef.current = nextFrameId;
  }

  external_React_namespaceObject.useEffect(function () {
    return function () {
      cancelNextFrame();
    };
  }, []);
  return [nextFrame, cancelNextFrame];
});
;// CONCATENATED MODULE: ./node_modules/rc-motion/es/hooks/useIsomorphicLayoutEffect.js

 // It's safe to use `useLayoutEffect` but the warning is annoying

var useIsomorphicLayoutEffect = canUseDom() ? external_React_namespaceObject.useLayoutEffect : external_React_namespaceObject.useEffect;
/* harmony default export */ const hooks_useIsomorphicLayoutEffect = (useIsomorphicLayoutEffect);
;// CONCATENATED MODULE: ./node_modules/rc-motion/es/hooks/useStepQueue.js






var STEP_QUEUE = [STEP_PREPARE, STEP_START, STEP_ACTIVE, STEP_ACTIVATED];
/** Skip current step */

var SkipStep = false;
/** Current step should be update in */

var DoStep = true;
function isActive(step) {
  return step === STEP_ACTIVE || step === STEP_ACTIVATED;
}
/* harmony default export */ const useStepQueue = (function (status, callback) {
  var _useState = useSafeState(STEP_NONE),
      _useState2 = slicedToArray_slicedToArray(_useState, 2),
      step = _useState2[0],
      setStep = _useState2[1];

  var _useNextFrame = useNextFrame(),
      _useNextFrame2 = slicedToArray_slicedToArray(_useNextFrame, 2),
      nextFrame = _useNextFrame2[0],
      cancelNextFrame = _useNextFrame2[1];

  function startQueue() {
    setStep(STEP_PREPARE, true);
  }

  hooks_useIsomorphicLayoutEffect(function () {
    if (step !== STEP_NONE && step !== STEP_ACTIVATED) {
      var index = STEP_QUEUE.indexOf(step);
      var nextStep = STEP_QUEUE[index + 1];
      var result = callback(step);

      if (result === SkipStep) {
        // Skip when no needed
        setStep(nextStep, true);
      } else {
        // Do as frame for step update
        nextFrame(function (info) {
          function doNext() {
            // Skip since current queue is ood
            if (info.isCanceled()) return;
            setStep(nextStep, true);
          }

          if (result === true) {
            doNext();
          } else {
            // Only promise should be async
            Promise.resolve(result).then(doNext);
          }
        });
      }
    }
  }, [status, step]);
  external_React_namespaceObject.useEffect(function () {
    return function () {
      cancelNextFrame();
    };
  }, []);
  return [startQueue, step];
});
;// CONCATENATED MODULE: ./node_modules/rc-motion/es/hooks/useDomMotionEvents.js



/* harmony default export */ const useDomMotionEvents = (function (callback) {
  var cacheElementRef = (0,external_React_namespaceObject.useRef)(); // Cache callback

  var callbackRef = (0,external_React_namespaceObject.useRef)(callback);
  callbackRef.current = callback; // Internal motion event handler

  var onInternalMotionEnd = external_React_namespaceObject.useCallback(function (event) {
    callbackRef.current(event);
  }, []); // Remove events

  function removeMotionEvents(element) {
    if (element) {
      element.removeEventListener(transitionEndName, onInternalMotionEnd);
      element.removeEventListener(animationEndName, onInternalMotionEnd);
    }
  } // Patch events


  function patchMotionEvents(element) {
    if (cacheElementRef.current && cacheElementRef.current !== element) {
      removeMotionEvents(cacheElementRef.current);
    }

    if (element && element !== cacheElementRef.current) {
      element.addEventListener(transitionEndName, onInternalMotionEnd);
      element.addEventListener(animationEndName, onInternalMotionEnd); // Save as cache in case dom removed trigger by `motionDeadline`

      cacheElementRef.current = element;
    }
  } // Clean up when removed


  external_React_namespaceObject.useEffect(function () {
    return function () {
      removeMotionEvents(cacheElementRef.current);
    };
  }, []);
  return [patchMotionEvents, removeMotionEvents];
});
;// CONCATENATED MODULE: ./node_modules/rc-motion/es/hooks/useStatus.js










function useStatus(supportMotion, visible, getElement, _ref) {
  var _ref$motionEnter = _ref.motionEnter,
      motionEnter = _ref$motionEnter === void 0 ? true : _ref$motionEnter,
      _ref$motionAppear = _ref.motionAppear,
      motionAppear = _ref$motionAppear === void 0 ? true : _ref$motionAppear,
      _ref$motionLeave = _ref.motionLeave,
      motionLeave = _ref$motionLeave === void 0 ? true : _ref$motionLeave,
      motionDeadline = _ref.motionDeadline,
      motionLeaveImmediately = _ref.motionLeaveImmediately,
      onAppearPrepare = _ref.onAppearPrepare,
      onEnterPrepare = _ref.onEnterPrepare,
      onLeavePrepare = _ref.onLeavePrepare,
      onAppearStart = _ref.onAppearStart,
      onEnterStart = _ref.onEnterStart,
      onLeaveStart = _ref.onLeaveStart,
      onAppearActive = _ref.onAppearActive,
      onEnterActive = _ref.onEnterActive,
      onLeaveActive = _ref.onLeaveActive,
      onAppearEnd = _ref.onAppearEnd,
      onEnterEnd = _ref.onEnterEnd,
      onLeaveEnd = _ref.onLeaveEnd,
      onVisibleChanged = _ref.onVisibleChanged;

  // Used for outer render usage to avoid `visible: false & status: none` to render nothing
  var _useState = useSafeState(),
      _useState2 = slicedToArray_slicedToArray(_useState, 2),
      asyncVisible = _useState2[0],
      setAsyncVisible = _useState2[1];

  var _useState3 = useSafeState(STATUS_NONE),
      _useState4 = slicedToArray_slicedToArray(_useState3, 2),
      status = _useState4[0],
      setStatus = _useState4[1];

  var _useState5 = useSafeState(null),
      _useState6 = slicedToArray_slicedToArray(_useState5, 2),
      style = _useState6[0],
      setStyle = _useState6[1];

  var mountedRef = (0,external_React_namespaceObject.useRef)(false);
  var deadlineRef = (0,external_React_namespaceObject.useRef)(null); // =========================== Dom Node ===========================

  function getDomElement() {
    return getElement();
  } // ========================== Motion End ==========================


  var activeRef = (0,external_React_namespaceObject.useRef)(false);

  function onInternalMotionEnd(event) {
    var element = getDomElement();

    if (event && !event.deadline && event.target !== element) {
      // event exists
      // not initiated by deadline
      // transitionEnd not fired by inner elements
      return;
    }

    var currentActive = activeRef.current;
    var canEnd;

    if (status === STATUS_APPEAR && currentActive) {
      canEnd = onAppearEnd === null || onAppearEnd === void 0 ? void 0 : onAppearEnd(element, event);
    } else if (status === STATUS_ENTER && currentActive) {
      canEnd = onEnterEnd === null || onEnterEnd === void 0 ? void 0 : onEnterEnd(element, event);
    } else if (status === STATUS_LEAVE && currentActive) {
      canEnd = onLeaveEnd === null || onLeaveEnd === void 0 ? void 0 : onLeaveEnd(element, event);
    } // Only update status when `canEnd` and not destroyed


    if (status !== STATUS_NONE && currentActive && canEnd !== false) {
      setStatus(STATUS_NONE, true);
      setStyle(null, true);
    }
  }

  var _useDomMotionEvents = useDomMotionEvents(onInternalMotionEnd),
      _useDomMotionEvents2 = slicedToArray_slicedToArray(_useDomMotionEvents, 1),
      patchMotionEvents = _useDomMotionEvents2[0]; // ============================= Step =============================


  var eventHandlers = external_React_namespaceObject.useMemo(function () {
    var _ref2, _ref3, _ref4;

    switch (status) {
      case STATUS_APPEAR:
        return _ref2 = {}, _defineProperty(_ref2, STEP_PREPARE, onAppearPrepare), _defineProperty(_ref2, STEP_START, onAppearStart), _defineProperty(_ref2, STEP_ACTIVE, onAppearActive), _ref2;

      case STATUS_ENTER:
        return _ref3 = {}, _defineProperty(_ref3, STEP_PREPARE, onEnterPrepare), _defineProperty(_ref3, STEP_START, onEnterStart), _defineProperty(_ref3, STEP_ACTIVE, onEnterActive), _ref3;

      case STATUS_LEAVE:
        return _ref4 = {}, _defineProperty(_ref4, STEP_PREPARE, onLeavePrepare), _defineProperty(_ref4, STEP_START, onLeaveStart), _defineProperty(_ref4, STEP_ACTIVE, onLeaveActive), _ref4;

      default:
        return {};
    }
  }, [status]);

  var _useStepQueue = useStepQueue(status, function (newStep) {
    // Only prepare step can be skip
    if (newStep === STEP_PREPARE) {
      var onPrepare = eventHandlers[STEP_PREPARE];

      if (!onPrepare) {
        return SkipStep;
      }

      return onPrepare(getDomElement());
    } // Rest step is sync update


    // Rest step is sync update
    if (step in eventHandlers) {
      var _eventHandlers$step;

      setStyle(((_eventHandlers$step = eventHandlers[step]) === null || _eventHandlers$step === void 0 ? void 0 : _eventHandlers$step.call(eventHandlers, getDomElement(), null)) || null);
    }

    if (step === STEP_ACTIVE) {
      // Patch events when motion needed
      patchMotionEvents(getDomElement());

      if (motionDeadline > 0) {
        clearTimeout(deadlineRef.current);
        deadlineRef.current = setTimeout(function () {
          onInternalMotionEnd({
            deadline: true
          });
        }, motionDeadline);
      }
    }

    return DoStep;
  }),
      _useStepQueue2 = slicedToArray_slicedToArray(_useStepQueue, 2),
      startStep = _useStepQueue2[0],
      step = _useStepQueue2[1];

  var active = isActive(step);
  activeRef.current = active; // ============================ Status ============================
  // Update with new status

  hooks_useIsomorphicLayoutEffect(function () {
    setAsyncVisible(visible);
    var isMounted = mountedRef.current;
    mountedRef.current = true;

    if (!supportMotion) {
      return;
    }

    var nextStatus; // Appear

    if (!isMounted && visible && motionAppear) {
      nextStatus = STATUS_APPEAR;
    } // Enter


    if (isMounted && visible && motionEnter) {
      nextStatus = STATUS_ENTER;
    } // Leave


    if (isMounted && !visible && motionLeave || !isMounted && motionLeaveImmediately && !visible && motionLeave) {
      nextStatus = STATUS_LEAVE;
    } // Update to next status


    if (nextStatus) {
      setStatus(nextStatus);
      startStep();
    }
  }, [visible]); // ============================ Effect ============================
  // Reset when motion changed

  (0,external_React_namespaceObject.useEffect)(function () {
    if ( // Cancel appear
    status === STATUS_APPEAR && !motionAppear || // Cancel enter
    status === STATUS_ENTER && !motionEnter || // Cancel leave
    status === STATUS_LEAVE && !motionLeave) {
      setStatus(STATUS_NONE);
    }
  }, [motionAppear, motionEnter, motionLeave]);
  (0,external_React_namespaceObject.useEffect)(function () {
    return function () {
      mountedRef.current = false;
      clearTimeout(deadlineRef.current);
    };
  }, []); // Trigger `onVisibleChanged`

  var firstMountChangeRef = external_React_namespaceObject.useRef(false);
  (0,external_React_namespaceObject.useEffect)(function () {
    // [visible & motion not end] => [!visible & motion end] still need trigger onVisibleChanged
    if (asyncVisible) {
      firstMountChangeRef.current = true;
    }

    if (asyncVisible !== undefined && status === STATUS_NONE) {
      // Skip first render is invisible since it's nothing changed
      if (firstMountChangeRef.current || asyncVisible) {
        onVisibleChanged === null || onVisibleChanged === void 0 ? void 0 : onVisibleChanged(asyncVisible);
      }

      firstMountChangeRef.current = true;
    }
  }, [asyncVisible, status]); // ============================ Styles ============================

  var mergedStyle = style;

  if (eventHandlers[STEP_PREPARE] && step === STEP_START) {
    mergedStyle = _objectSpread2({
      transition: 'none'
    }, mergedStyle);
  }

  return [status, step, mergedStyle, asyncVisible !== null && asyncVisible !== void 0 ? asyncVisible : visible];
}
;// CONCATENATED MODULE: ./node_modules/rc-motion/es/DomWrapper.js






var DomWrapper = /*#__PURE__*/function (_React$Component) {
  _inherits(DomWrapper, _React$Component);

  var _super = _createSuper(DomWrapper);

  function DomWrapper() {
    _classCallCheck(this, DomWrapper);

    return _super.apply(this, arguments);
  }

  _createClass(DomWrapper, [{
    key: "render",
    value: function render() {
      return this.props.children;
    }
  }]);

  return DomWrapper;
}(external_React_namespaceObject.Component);

/* harmony default export */ const es_DomWrapper = (DomWrapper);
;// CONCATENATED MODULE: ./node_modules/rc-motion/es/CSSMotion.js





/* eslint-disable react/default-props-match-prop-types, react/no-multi-comp, react/prop-types */










/**
 * `transitionSupport` is used for none transition test case.
 * Default we use browser transition event support check.
 */

function genCSSMotion(config) {
  var transitionSupport = config;

  if (typeof_typeof(config) === 'object') {
    transitionSupport = config.transitionSupport;
  }

  function isSupportTransition(props) {
    return !!(props.motionName && transitionSupport);
  }

  var CSSMotion = /*#__PURE__*/external_React_namespaceObject.forwardRef(function (props, ref) {
    var _props$visible = props.visible,
        visible = _props$visible === void 0 ? true : _props$visible,
        _props$removeOnLeave = props.removeOnLeave,
        removeOnLeave = _props$removeOnLeave === void 0 ? true : _props$removeOnLeave,
        forceRender = props.forceRender,
        children = props.children,
        motionName = props.motionName,
        leavedClassName = props.leavedClassName,
        eventProps = props.eventProps;
    var supportMotion = isSupportTransition(props); // Ref to the react node, it may be a HTMLElement

    var nodeRef = (0,external_React_namespaceObject.useRef)(); // Ref to the dom wrapper in case ref can not pass to HTMLElement

    var wrapperNodeRef = (0,external_React_namespaceObject.useRef)();

    function getDomElement() {
      try {
        // Here we're avoiding call for findDOMNode since it's deprecated
        // in strict mode. We're calling it only when node ref is not
        // an instance of DOM HTMLElement. Otherwise use
        // findDOMNode as a final resort
        return nodeRef.current instanceof HTMLElement ? nodeRef.current : findDOMNode(wrapperNodeRef.current);
      } catch (e) {
        // Only happen when `motionDeadline` trigger but element removed.
        return null;
      }
    }

    var _useStatus = useStatus(supportMotion, visible, getDomElement, props),
        _useStatus2 = slicedToArray_slicedToArray(_useStatus, 4),
        status = _useStatus2[0],
        statusStep = _useStatus2[1],
        statusStyle = _useStatus2[2],
        mergedVisible = _useStatus2[3]; // Record whether content has rendered
    // Will return null for un-rendered even when `removeOnLeave={false}`


    var renderedRef = external_React_namespaceObject.useRef(mergedVisible);

    if (mergedVisible) {
      renderedRef.current = true;
    } // ====================== Refs ======================


    var setNodeRef = external_React_namespaceObject.useCallback(function (node) {
      nodeRef.current = node;
      fillRef(ref, node);
    }, [ref]); // ===================== Render =====================

    var motionChildren;

    var mergedProps = _objectSpread2(_objectSpread2({}, eventProps), {}, {
      visible: visible
    });

    if (!children) {
      // No children
      motionChildren = null;
    } else if (status === STATUS_NONE || !isSupportTransition(props)) {
      // Stable children
      if (mergedVisible) {
        motionChildren = children(_objectSpread2({}, mergedProps), setNodeRef);
      } else if (!removeOnLeave && renderedRef.current) {
        motionChildren = children(_objectSpread2(_objectSpread2({}, mergedProps), {}, {
          className: leavedClassName
        }), setNodeRef);
      } else if (forceRender) {
        motionChildren = children(_objectSpread2(_objectSpread2({}, mergedProps), {}, {
          style: {
            display: 'none'
          }
        }), setNodeRef);
      } else {
        motionChildren = null;
      }
    } else {
      var _classNames;

      // In motion
      var statusSuffix;

      if (statusStep === STEP_PREPARE) {
        statusSuffix = 'prepare';
      } else if (isActive(statusStep)) {
        statusSuffix = 'active';
      } else if (statusStep === STEP_START) {
        statusSuffix = 'start';
      }

      motionChildren = children(_objectSpread2(_objectSpread2({}, mergedProps), {}, {
        className: classnames_default()(getTransitionName(motionName, status), (_classNames = {}, _defineProperty(_classNames, getTransitionName(motionName, "".concat(status, "-").concat(statusSuffix)), statusSuffix), _defineProperty(_classNames, motionName, typeof motionName === 'string'), _classNames)),
        style: statusStyle
      }), setNodeRef);
    } // Auto inject ref if child node not have `ref` props


    if ( /*#__PURE__*/external_React_namespaceObject.isValidElement(motionChildren) && supportRef(motionChildren)) {
      var _motionChildren = motionChildren,
          originNodeRef = _motionChildren.ref;

      if (!originNodeRef) {
        motionChildren = /*#__PURE__*/external_React_namespaceObject.cloneElement(motionChildren, {
          ref: setNodeRef
        });
      }
    }

    return /*#__PURE__*/external_React_namespaceObject.createElement(es_DomWrapper, {
      ref: wrapperNodeRef
    }, motionChildren);
  });
  CSSMotion.displayName = 'CSSMotion';
  return CSSMotion;
}
/* harmony default export */ const es_CSSMotion = (genCSSMotion(supportTransition));
;// CONCATENATED MODULE: ./node_modules/rc-motion/es/util/diff.js


var STATUS_ADD = 'add';
var STATUS_KEEP = 'keep';
var STATUS_REMOVE = 'remove';
var STATUS_REMOVED = 'removed';
function wrapKeyToObject(key) {
  var keyObj;

  if (key && typeof_typeof(key) === 'object' && 'key' in key) {
    keyObj = key;
  } else {
    keyObj = {
      key: key
    };
  }

  return _objectSpread2(_objectSpread2({}, keyObj), {}, {
    key: String(keyObj.key)
  });
}
function parseKeys() {
  var keys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  return keys.map(wrapKeyToObject);
}
function diffKeys() {
  var prevKeys = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];
  var currentKeys = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];
  var list = [];
  var currentIndex = 0;
  var currentLen = currentKeys.length;
  var prevKeyObjects = parseKeys(prevKeys);
  var currentKeyObjects = parseKeys(currentKeys); // Check prev keys to insert or keep

  prevKeyObjects.forEach(function (keyObj) {
    var hit = false;

    for (var i = currentIndex; i < currentLen; i += 1) {
      var currentKeyObj = currentKeyObjects[i];

      if (currentKeyObj.key === keyObj.key) {
        // New added keys should add before current key
        if (currentIndex < i) {
          list = list.concat(currentKeyObjects.slice(currentIndex, i).map(function (obj) {
            return _objectSpread2(_objectSpread2({}, obj), {}, {
              status: STATUS_ADD
            });
          }));
          currentIndex = i;
        }

        list.push(_objectSpread2(_objectSpread2({}, currentKeyObj), {}, {
          status: STATUS_KEEP
        }));
        currentIndex += 1;
        hit = true;
        break;
      }
    } // If not hit, it means key is removed


    if (!hit) {
      list.push(_objectSpread2(_objectSpread2({}, keyObj), {}, {
        status: STATUS_REMOVE
      }));
    }
  }); // Add rest to the list

  if (currentIndex < currentLen) {
    list = list.concat(currentKeyObjects.slice(currentIndex).map(function (obj) {
      return _objectSpread2(_objectSpread2({}, obj), {}, {
        status: STATUS_ADD
      });
    }));
  }
  /**
   * Merge same key when it remove and add again:
   *    [1 - add, 2 - keep, 1 - remove] -> [1 - keep, 2 - keep]
   */


  var keys = {};
  list.forEach(function (_ref) {
    var key = _ref.key;
    keys[key] = (keys[key] || 0) + 1;
  });
  var duplicatedKeys = Object.keys(keys).filter(function (key) {
    return keys[key] > 1;
  });
  duplicatedKeys.forEach(function (matchKey) {
    // Remove `STATUS_REMOVE` node.
    list = list.filter(function (_ref2) {
      var key = _ref2.key,
          status = _ref2.status;
      return key !== matchKey || status !== STATUS_REMOVE;
    }); // Update `STATUS_ADD` to `STATUS_KEEP`

    list.forEach(function (node) {
      if (node.key === matchKey) {
        // eslint-disable-next-line no-param-reassign
        node.status = STATUS_KEEP;
      }
    });
  });
  return list;
}
;// CONCATENATED MODULE: ./node_modules/rc-motion/es/CSSMotionList.js







var CSSMotionList_excluded = ["component", "children", "onVisibleChanged", "onAllRemoved"],
    _excluded2 = ["status"];

/* eslint react/prop-types: 0 */




var MOTION_PROP_NAMES = ['eventProps', 'visible', 'children', 'motionName', 'motionAppear', 'motionEnter', 'motionLeave', 'motionLeaveImmediately', 'motionDeadline', 'removeOnLeave', 'leavedClassName', 'onAppearStart', 'onAppearActive', 'onAppearEnd', 'onEnterStart', 'onEnterActive', 'onEnterEnd', 'onLeaveStart', 'onLeaveActive', 'onLeaveEnd'];
/**
 * Generate a CSSMotionList component with config
 * @param transitionSupport No need since CSSMotionList no longer depends on transition support
 * @param CSSMotion CSSMotion component
 */

function genCSSMotionList(transitionSupport) {
  var CSSMotion = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : es_CSSMotion;

  var CSSMotionList = /*#__PURE__*/function (_React$Component) {
    _inherits(CSSMotionList, _React$Component);

    var _super = _createSuper(CSSMotionList);

    function CSSMotionList() {
      var _this;

      _classCallCheck(this, CSSMotionList);

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      _this = _super.call.apply(_super, [this].concat(args));
      _this.state = {
        keyEntities: []
      };

      _this.removeKey = function (removeKey) {
        var keyEntities = _this.state.keyEntities;
        var nextKeyEntities = keyEntities.map(function (entity) {
          if (entity.key !== removeKey) return entity;
          return _objectSpread2(_objectSpread2({}, entity), {}, {
            status: STATUS_REMOVED
          });
        });

        _this.setState({
          keyEntities: nextKeyEntities
        });

        return nextKeyEntities.filter(function (_ref) {
          var status = _ref.status;
          return status !== STATUS_REMOVED;
        }).length;
      };

      return _this;
    }

    _createClass(CSSMotionList, [{
      key: "render",
      value: function render() {
        var _this2 = this;

        var keyEntities = this.state.keyEntities;

        var _this$props = this.props,
            component = _this$props.component,
            children = _this$props.children,
            _onVisibleChanged = _this$props.onVisibleChanged,
            onAllRemoved = _this$props.onAllRemoved,
            restProps = _objectWithoutProperties(_this$props, CSSMotionList_excluded);

        var Component = component || external_React_namespaceObject.Fragment;
        var motionProps = {};
        MOTION_PROP_NAMES.forEach(function (prop) {
          motionProps[prop] = restProps[prop];
          delete restProps[prop];
        });
        delete restProps.keys;
        return /*#__PURE__*/external_React_namespaceObject.createElement(Component, restProps, keyEntities.map(function (_ref2) {
          var status = _ref2.status,
              eventProps = _objectWithoutProperties(_ref2, _excluded2);

          var visible = status === STATUS_ADD || status === STATUS_KEEP;
          return /*#__PURE__*/external_React_namespaceObject.createElement(CSSMotion, _extends({}, motionProps, {
            key: eventProps.key,
            visible: visible,
            eventProps: eventProps,
            onVisibleChanged: function onVisibleChanged(changedVisible) {
              _onVisibleChanged === null || _onVisibleChanged === void 0 ? void 0 : _onVisibleChanged(changedVisible, {
                key: eventProps.key
              });

              if (!changedVisible) {
                var restKeysCount = _this2.removeKey(eventProps.key);

                if (restKeysCount === 0 && onAllRemoved) {
                  onAllRemoved();
                }
              }
            }
          }), children);
        }));
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(_ref3, _ref4) {
        var keys = _ref3.keys;
        var keyEntities = _ref4.keyEntities;
        var parsedKeyObjects = parseKeys(keys);
        var mixedKeyEntities = diffKeys(keyEntities, parsedKeyObjects);
        return {
          keyEntities: mixedKeyEntities.filter(function (entity) {
            var prevEntity = keyEntities.find(function (_ref5) {
              var key = _ref5.key;
              return entity.key === key;
            }); // Remove if already mark as removed

            if (prevEntity && prevEntity.status === STATUS_REMOVED && entity.status === STATUS_REMOVE) {
              return false;
            }

            return true;
          })
        };
      } // ZombieJ: Return the count of rest keys. It's safe to refactor if need more info.

    }]);

    return CSSMotionList;
  }(external_React_namespaceObject.Component);

  CSSMotionList.defaultProps = {
    component: 'div'
  };
  return CSSMotionList;
}
/* harmony default export */ const CSSMotionList = (genCSSMotionList(supportTransition));
;// CONCATENATED MODULE: ./node_modules/rc-motion/es/index.js



/* harmony default export */ const es = (es_CSSMotion);
;// CONCATENATED MODULE: ./node_modules/rc-trigger/es/utils/legacyUtil.js
function getMotion(_ref) {
  var prefixCls = _ref.prefixCls,
      motion = _ref.motion,
      animation = _ref.animation,
      transitionName = _ref.transitionName;

  if (motion) {
    return motion;
  }

  if (animation) {
    return {
      motionName: "".concat(prefixCls, "-").concat(animation)
    };
  }

  if (transitionName) {
    return {
      motionName: transitionName
    };
  }

  return null;
}
;// CONCATENATED MODULE: ./node_modules/rc-trigger/es/Popup/Mask.js






function Mask(props) {
  var prefixCls = props.prefixCls,
      visible = props.visible,
      zIndex = props.zIndex,
      mask = props.mask,
      maskMotion = props.maskMotion,
      maskAnimation = props.maskAnimation,
      maskTransitionName = props.maskTransitionName;

  if (!mask) {
    return null;
  }

  var motion = {};

  if (maskMotion || maskTransitionName || maskAnimation) {
    motion = _objectSpread2({
      motionAppear: true
    }, getMotion({
      motion: maskMotion,
      prefixCls: prefixCls,
      transitionName: maskTransitionName,
      animation: maskAnimation
    }));
  }

  return /*#__PURE__*/external_React_namespaceObject.createElement(es, _extends({}, motion, {
    visible: visible,
    removeOnLeave: true
  }), function (_ref) {
    var className = _ref.className;
    return /*#__PURE__*/external_React_namespaceObject.createElement("div", {
      style: {
        zIndex: zIndex
      },
      className: classnames_default()("".concat(prefixCls, "-mask"), className)
    });
  });
}
;// CONCATENATED MODULE: ./node_modules/rc-util/es/Dom/isVisible.js
/* harmony default export */ const isVisible = (function (element) {
  if (!element) {
    return false;
  }

  if (element.offsetParent) {
    return true;
  }

  if (element.getBBox) {
    var box = element.getBBox();

    if (box.width || box.height) {
      return true;
    }
  }

  if (element.getBoundingClientRect) {
    var _box = element.getBoundingClientRect();

    if (_box.width || _box.height) {
      return true;
    }
  }

  return false;
});
;// CONCATENATED MODULE: ./node_modules/dom-align/dist-web/index.js
function dist_web_ownKeys(object, enumerableOnly) {
  var keys = Object.keys(object);

  if (Object.getOwnPropertySymbols) {
    var symbols = Object.getOwnPropertySymbols(object);

    if (enumerableOnly) {
      symbols = symbols.filter(function (sym) {
        return Object.getOwnPropertyDescriptor(object, sym).enumerable;
      });
    }

    keys.push.apply(keys, symbols);
  }

  return keys;
}

function dist_web_objectSpread2(target) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i] != null ? arguments[i] : {};

    if (i % 2) {
      dist_web_ownKeys(Object(source), true).forEach(function (key) {
        dist_web_defineProperty(target, key, source[key]);
      });
    } else if (Object.getOwnPropertyDescriptors) {
      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));
    } else {
      dist_web_ownKeys(Object(source)).forEach(function (key) {
        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
      });
    }
  }

  return target;
}

function dist_web_typeof(obj) {
  "@babel/helpers - typeof";

  if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
    dist_web_typeof = function (obj) {
      return typeof obj;
    };
  } else {
    dist_web_typeof = function (obj) {
      return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    };
  }

  return dist_web_typeof(obj);
}

function dist_web_defineProperty(obj, key, value) {
  if (key in obj) {
    Object.defineProperty(obj, key, {
      value: value,
      enumerable: true,
      configurable: true,
      writable: true
    });
  } else {
    obj[key] = value;
  }

  return obj;
}

var dist_web_vendorPrefix;
var jsCssMap = {
  Webkit: '-webkit-',
  Moz: '-moz-',
  // IE did it wrong again ...
  ms: '-ms-',
  O: '-o-'
};

function dist_web_getVendorPrefix() {
  if (dist_web_vendorPrefix !== undefined) {
    return dist_web_vendorPrefix;
  }

  dist_web_vendorPrefix = '';
  var style = document.createElement('p').style;
  var testProp = 'Transform';

  for (var key in jsCssMap) {
    if (key + testProp in style) {
      dist_web_vendorPrefix = key;
    }
  }

  return dist_web_vendorPrefix;
}

function dist_web_getTransitionName() {
  return dist_web_getVendorPrefix() ? "".concat(dist_web_getVendorPrefix(), "TransitionProperty") : 'transitionProperty';
}

function getTransformName() {
  return dist_web_getVendorPrefix() ? "".concat(dist_web_getVendorPrefix(), "Transform") : 'transform';
}
function setTransitionProperty(node, value) {
  var name = dist_web_getTransitionName();

  if (name) {
    node.style[name] = value;

    if (name !== 'transitionProperty') {
      node.style.transitionProperty = value;
    }
  }
}

function setTransform(node, value) {
  var name = getTransformName();

  if (name) {
    node.style[name] = value;

    if (name !== 'transform') {
      node.style.transform = value;
    }
  }
}

function getTransitionProperty(node) {
  return node.style.transitionProperty || node.style[dist_web_getTransitionName()];
}
function getTransformXY(node) {
  var style = window.getComputedStyle(node, null);
  var transform = style.getPropertyValue('transform') || style.getPropertyValue(getTransformName());

  if (transform && transform !== 'none') {
    var matrix = transform.replace(/[^0-9\-.,]/g, '').split(',');
    return {
      x: parseFloat(matrix[12] || matrix[4], 0),
      y: parseFloat(matrix[13] || matrix[5], 0)
    };
  }

  return {
    x: 0,
    y: 0
  };
}
var matrix2d = /matrix\((.*)\)/;
var matrix3d = /matrix3d\((.*)\)/;
function setTransformXY(node, xy) {
  var style = window.getComputedStyle(node, null);
  var transform = style.getPropertyValue('transform') || style.getPropertyValue(getTransformName());

  if (transform && transform !== 'none') {
    var arr;
    var match2d = transform.match(matrix2d);

    if (match2d) {
      match2d = match2d[1];
      arr = match2d.split(',').map(function (item) {
        return parseFloat(item, 10);
      });
      arr[4] = xy.x;
      arr[5] = xy.y;
      setTransform(node, "matrix(".concat(arr.join(','), ")"));
    } else {
      var match3d = transform.match(matrix3d)[1];
      arr = match3d.split(',').map(function (item) {
        return parseFloat(item, 10);
      });
      arr[12] = xy.x;
      arr[13] = xy.y;
      setTransform(node, "matrix3d(".concat(arr.join(','), ")"));
    }
  } else {
    setTransform(node, "translateX(".concat(xy.x, "px) translateY(").concat(xy.y, "px) translateZ(0)"));
  }
}

var RE_NUM = /[\-+]?(?:\d*\.|)\d+(?:[eE][\-+]?\d+|)/.source;
var getComputedStyleX; // https://stackoverflow.com/a/3485654/3040605

function forceRelayout(elem) {
  var originalStyle = elem.style.display;
  elem.style.display = 'none';
  elem.offsetHeight; // eslint-disable-line

  elem.style.display = originalStyle;
}

function css(el, name, v) {
  var value = v;

  if (dist_web_typeof(name) === 'object') {
    for (var i in name) {
      if (name.hasOwnProperty(i)) {
        css(el, i, name[i]);
      }
    }

    return undefined;
  }

  if (typeof value !== 'undefined') {
    if (typeof value === 'number') {
      value = "".concat(value, "px");
    }

    el.style[name] = value;
    return undefined;
  }

  return getComputedStyleX(el, name);
}

function getClientPosition(elem) {
  var box;
  var x;
  var y;
  var doc = elem.ownerDocument;
  var body = doc.body;
  var docElem = doc && doc.documentElement; //  GBS A-Grade Browsers  getBoundingClientRect 

  box = elem.getBoundingClientRect(); // jQuery  docElem.clientLeft/clientTop
  //  html  body /
  // ie6  html  margin  html  margin

  x = Math.floor(box.left);
  y = Math.floor(box.top); // In IE, most of the time, 2 extra pixels are added to the top and left
  // due to the implicit 2-pixel inset border.  In IE6/7 quirks mode and
  // IE6 standards mode, this border can be overridden by setting the
  // document element's border to zero -- thus, we cannot rely on the
  // offset always being 2 pixels.
  // In quirks mode, the offset can be determined by querying the body's
  // clientLeft/clientTop, but in standards mode, it is found by querying
  // the document element's clientLeft/clientTop.  Since we already called
  // getClientBoundingRect we have already forced a reflow, so it is not
  // too expensive just to query them all.
  // ie  absolute 
  //  documentElement ,quirks  body
  //  body  html   ie < 9 html  2px 
  //  ie body html  ,ie  html,body 
  //  ie  docElem.clientTop  border-top
  // ie7 html  2
  //  firefox/chrome/ie9  docElem.clientTop  border-top  0

  x -= docElem.clientLeft || body.clientLeft || 0;
  y -= docElem.clientTop || body.clientTop || 0;
  return {
    left: x,
    top: y
  };
}

function getScroll(w, top) {
  var ret = w["page".concat(top ? 'Y' : 'X', "Offset")];
  var method = "scroll".concat(top ? 'Top' : 'Left');

  if (typeof ret !== 'number') {
    var d = w.document; // ie6,7,8 standard mode

    ret = d.documentElement[method];

    if (typeof ret !== 'number') {
      // quirks mode
      ret = d.body[method];
    }
  }

  return ret;
}

function getScrollLeft(w) {
  return getScroll(w);
}

function getScrollTop(w) {
  return getScroll(w, true);
}

function getOffset(el) {
  var pos = getClientPosition(el);
  var doc = el.ownerDocument;
  var w = doc.defaultView || doc.parentWindow;
  pos.left += getScrollLeft(w);
  pos.top += getScrollTop(w);
  return pos;
}
/**
 * A crude way of determining if an object is a window
 * @member util
 */


function isWindow(obj) {
  // must use == for ie8

  /* eslint eqeqeq:0 */
  return obj !== null && obj !== undefined && obj == obj.window;
}

function getDocument(node) {
  if (isWindow(node)) {
    return node.document;
  }

  if (node.nodeType === 9) {
    return node;
  }

  return node.ownerDocument;
}

function _getComputedStyle(elem, name, cs) {
  var computedStyle = cs;
  var val = '';
  var d = getDocument(elem);
  computedStyle = computedStyle || d.defaultView.getComputedStyle(elem, null); // https://github.com/kissyteam/kissy/issues/61

  if (computedStyle) {
    val = computedStyle.getPropertyValue(name) || computedStyle[name];
  }

  return val;
}

var _RE_NUM_NO_PX = new RegExp("^(".concat(RE_NUM, ")(?!px)[a-z%]+$"), 'i');

var RE_POS = /^(top|right|bottom|left)$/;
var CURRENT_STYLE = 'currentStyle';
var RUNTIME_STYLE = 'runtimeStyle';
var dist_web_LEFT = 'left';
var PX = 'px';

function _getComputedStyleIE(elem, name) {
  // currentStyle maybe null
  // http://msdn.microsoft.com/en-us/library/ms535231.aspx
  var ret = elem[CURRENT_STYLE] && elem[CURRENT_STYLE][name]; //  width/height  pixelLeft  width/height 
  // ! CUSTOM_STYLE.height,CUSTOM_STYLE.width ,cssHook @2011-08-19
  //  ie  offset 
  // borderWidth  borderWidth 
  // From the awesome hack by Dean Edwards
  // http://erik.eae.net/archives/2007/07/27/18.54.15/#comment-102291
  // If we're not dealing with a regular pixel number
  // but a number that has a weird ending, we need to convert it to pixels
  // exclude left right for relativity

  if (_RE_NUM_NO_PX.test(ret) && !RE_POS.test(name)) {
    // Remember the original values
    var style = elem.style;
    var left = style[dist_web_LEFT];
    var rsLeft = elem[RUNTIME_STYLE][dist_web_LEFT]; // prevent flashing of content

    elem[RUNTIME_STYLE][dist_web_LEFT] = elem[CURRENT_STYLE][dist_web_LEFT]; // Put in the new values to get a computed value out

    style[dist_web_LEFT] = name === 'fontSize' ? '1em' : ret || 0;
    ret = style.pixelLeft + PX; // Revert the changed values

    style[dist_web_LEFT] = left;
    elem[RUNTIME_STYLE][dist_web_LEFT] = rsLeft;
  }

  return ret === '' ? 'auto' : ret;
}

if (typeof window !== 'undefined') {
  getComputedStyleX = window.getComputedStyle ? _getComputedStyle : _getComputedStyleIE;
}

function getOffsetDirection(dir, option) {
  if (dir === 'left') {
    return option.useCssRight ? 'right' : dir;
  }

  return option.useCssBottom ? 'bottom' : dir;
}

function oppositeOffsetDirection(dir) {
  if (dir === 'left') {
    return 'right';
  } else if (dir === 'right') {
    return 'left';
  } else if (dir === 'top') {
    return 'bottom';
  } else if (dir === 'bottom') {
    return 'top';
  }
} //  elem  elem.ownerDocument 


function setLeftTop(elem, offset, option) {
  // set position first, in-case top/left are set even on static elem
  if (css(elem, 'position') === 'static') {
    elem.style.position = 'relative';
  }

  var presetH = -999;
  var presetV = -999;
  var horizontalProperty = getOffsetDirection('left', option);
  var verticalProperty = getOffsetDirection('top', option);
  var oppositeHorizontalProperty = oppositeOffsetDirection(horizontalProperty);
  var oppositeVerticalProperty = oppositeOffsetDirection(verticalProperty);

  if (horizontalProperty !== 'left') {
    presetH = 999;
  }

  if (verticalProperty !== 'top') {
    presetV = 999;
  }

  var originalTransition = '';
  var originalOffset = getOffset(elem);

  if ('left' in offset || 'top' in offset) {
    originalTransition = getTransitionProperty(elem) || '';
    setTransitionProperty(elem, 'none');
  }

  if ('left' in offset) {
    elem.style[oppositeHorizontalProperty] = '';
    elem.style[horizontalProperty] = "".concat(presetH, "px");
  }

  if ('top' in offset) {
    elem.style[oppositeVerticalProperty] = '';
    elem.style[verticalProperty] = "".concat(presetV, "px");
  } // force relayout


  forceRelayout(elem);
  var old = getOffset(elem);
  var originalStyle = {};

  for (var key in offset) {
    if (offset.hasOwnProperty(key)) {
      var dir = getOffsetDirection(key, option);
      var preset = key === 'left' ? presetH : presetV;
      var off = originalOffset[key] - old[key];

      if (dir === key) {
        originalStyle[dir] = preset + off;
      } else {
        originalStyle[dir] = preset - off;
      }
    }
  }

  css(elem, originalStyle); // force relayout

  forceRelayout(elem);

  if ('left' in offset || 'top' in offset) {
    setTransitionProperty(elem, originalTransition);
  }

  var ret = {};

  for (var _key in offset) {
    if (offset.hasOwnProperty(_key)) {
      var _dir = getOffsetDirection(_key, option);

      var _off = offset[_key] - originalOffset[_key];

      if (_key === _dir) {
        ret[_dir] = originalStyle[_dir] + _off;
      } else {
        ret[_dir] = originalStyle[_dir] - _off;
      }
    }
  }

  css(elem, ret);
}

function setTransform$1(elem, offset) {
  var originalOffset = getOffset(elem);
  var originalXY = getTransformXY(elem);
  var resultXY = {
    x: originalXY.x,
    y: originalXY.y
  };

  if ('left' in offset) {
    resultXY.x = originalXY.x + offset.left - originalOffset.left;
  }

  if ('top' in offset) {
    resultXY.y = originalXY.y + offset.top - originalOffset.top;
  }

  setTransformXY(elem, resultXY);
}

function setOffset(elem, offset, option) {
  if (option.ignoreShake) {
    var oriOffset = getOffset(elem);
    var oLeft = oriOffset.left.toFixed(0);
    var oTop = oriOffset.top.toFixed(0);
    var tLeft = offset.left.toFixed(0);
    var tTop = offset.top.toFixed(0);

    if (oLeft === tLeft && oTop === tTop) {
      return;
    }
  }

  if (option.useCssRight || option.useCssBottom) {
    setLeftTop(elem, offset, option);
  } else if (option.useCssTransform && getTransformName() in document.body.style) {
    setTransform$1(elem, offset);
  } else {
    setLeftTop(elem, offset, option);
  }
}

function each(arr, fn) {
  for (var i = 0; i < arr.length; i++) {
    fn(arr[i]);
  }
}

function isBorderBoxFn(elem) {
  return getComputedStyleX(elem, 'boxSizing') === 'border-box';
}

var BOX_MODELS = ['margin', 'border', 'padding'];
var CONTENT_INDEX = -1;
var PADDING_INDEX = 2;
var BORDER_INDEX = 1;
var MARGIN_INDEX = 0;

function swap(elem, options, callback) {
  var old = {};
  var style = elem.style;
  var name; // Remember the old values, and insert the new ones

  for (name in options) {
    if (options.hasOwnProperty(name)) {
      old[name] = style[name];
      style[name] = options[name];
    }
  }

  callback.call(elem); // Revert the old values

  for (name in options) {
    if (options.hasOwnProperty(name)) {
      style[name] = old[name];
    }
  }
}

function getPBMWidth(elem, props, which) {
  var value = 0;
  var prop;
  var j;
  var i;

  for (j = 0; j < props.length; j++) {
    prop = props[j];

    if (prop) {
      for (i = 0; i < which.length; i++) {
        var cssProp = void 0;

        if (prop === 'border') {
          cssProp = "".concat(prop).concat(which[i], "Width");
        } else {
          cssProp = prop + which[i];
        }

        value += parseFloat(getComputedStyleX(elem, cssProp)) || 0;
      }
    }
  }

  return value;
}

var domUtils = {
  getParent: function getParent(element) {
    var parent = element;

    do {
      if (parent.nodeType === 11 && parent.host) {
        parent = parent.host;
      } else {
        parent = parent.parentNode;
      }
    } while (parent && parent.nodeType !== 1 && parent.nodeType !== 9);

    return parent;
  }
};
each(['Width', 'Height'], function (name) {
  domUtils["doc".concat(name)] = function (refWin) {
    var d = refWin.document;
    return Math.max( // firefox chrome documentElement.scrollHeight< body.scrollHeight
    // ie standard mode : documentElement.scrollHeight> body.scrollHeight
    d.documentElement["scroll".concat(name)], // quirks : documentElement.scrollHeight 
    d.body["scroll".concat(name)], domUtils["viewport".concat(name)](d));
  };

  domUtils["viewport".concat(name)] = function (win) {
    // pc browser includes scrollbar in window.innerWidth
    var prop = "client".concat(name);
    var doc = win.document;
    var body = doc.body;
    var documentElement = doc.documentElement;
    var documentElementProp = documentElement[prop]; //  documentElement
    // backcompat  body

    return doc.compatMode === 'CSS1Compat' && documentElementProp || body && body[prop] || documentElementProp;
  };
});
/*
 
 @param elem
 @param name
 @param {String} [extra]  'padding' : (css width) + padding
 'border' : (css width) + padding + border
 'margin' : (css width) + padding + border + margin
 */

function getWH(elem, name, ex) {
  var extra = ex;

  if (isWindow(elem)) {
    return name === 'width' ? domUtils.viewportWidth(elem) : domUtils.viewportHeight(elem);
  } else if (elem.nodeType === 9) {
    return name === 'width' ? domUtils.docWidth(elem) : domUtils.docHeight(elem);
  }

  var which = name === 'width' ? ['Left', 'Right'] : ['Top', 'Bottom'];
  var borderBoxValue = name === 'width' ? Math.floor(elem.getBoundingClientRect().width) : Math.floor(elem.getBoundingClientRect().height);
  var isBorderBox = isBorderBoxFn(elem);
  var cssBoxValue = 0;

  if (borderBoxValue === null || borderBoxValue === undefined || borderBoxValue <= 0) {
    borderBoxValue = undefined; // Fall back to computed then un computed css if necessary

    cssBoxValue = getComputedStyleX(elem, name);

    if (cssBoxValue === null || cssBoxValue === undefined || Number(cssBoxValue) < 0) {
      cssBoxValue = elem.style[name] || 0;
    } // Normalize '', auto, and prepare for extra


    cssBoxValue = parseFloat(cssBoxValue) || 0;
  }

  if (extra === undefined) {
    extra = isBorderBox ? BORDER_INDEX : CONTENT_INDEX;
  }

  var borderBoxValueOrIsBorderBox = borderBoxValue !== undefined || isBorderBox;
  var val = borderBoxValue || cssBoxValue;

  if (extra === CONTENT_INDEX) {
    if (borderBoxValueOrIsBorderBox) {
      return val - getPBMWidth(elem, ['border', 'padding'], which);
    }

    return cssBoxValue;
  } else if (borderBoxValueOrIsBorderBox) {
    if (extra === BORDER_INDEX) {
      return val;
    }

    return val + (extra === PADDING_INDEX ? -getPBMWidth(elem, ['border'], which) : getPBMWidth(elem, ['margin'], which));
  }

  return cssBoxValue + getPBMWidth(elem, BOX_MODELS.slice(extra), which);
}

var cssShow = {
  position: 'absolute',
  visibility: 'hidden',
  display: 'block'
}; // fix #119 : https://github.com/kissyteam/kissy/issues/119

function getWHIgnoreDisplay() {
  for (var _len = arguments.length, args = new Array(_len), _key2 = 0; _key2 < _len; _key2++) {
    args[_key2] = arguments[_key2];
  }

  var val;
  var elem = args[0]; // in case elem is window
  // elem.offsetWidth === undefined

  if (elem.offsetWidth !== 0) {
    val = getWH.apply(undefined, args);
  } else {
    swap(elem, cssShow, function () {
      val = getWH.apply(undefined, args);
    });
  }

  return val;
}

each(['width', 'height'], function (name) {
  var first = name.charAt(0).toUpperCase() + name.slice(1);

  domUtils["outer".concat(first)] = function (el, includeMargin) {
    return el && getWHIgnoreDisplay(el, name, includeMargin ? MARGIN_INDEX : BORDER_INDEX);
  };

  var which = name === 'width' ? ['Left', 'Right'] : ['Top', 'Bottom'];

  domUtils[name] = function (elem, v) {
    var val = v;

    if (val !== undefined) {
      if (elem) {
        var isBorderBox = isBorderBoxFn(elem);

        if (isBorderBox) {
          val += getPBMWidth(elem, ['padding', 'border'], which);
        }

        return css(elem, name, val);
      }

      return undefined;
    }

    return elem && getWHIgnoreDisplay(elem, name, CONTENT_INDEX);
  };
});

function dist_web_mix(to, from) {
  for (var i in from) {
    if (from.hasOwnProperty(i)) {
      to[i] = from[i];
    }
  }

  return to;
}

var utils = {
  getWindow: function getWindow(node) {
    if (node && node.document && node.setTimeout) {
      return node;
    }

    var doc = node.ownerDocument || node;
    return doc.defaultView || doc.parentWindow;
  },
  getDocument: getDocument,
  offset: function offset(el, value, option) {
    if (typeof value !== 'undefined') {
      setOffset(el, value, option || {});
    } else {
      return getOffset(el);
    }
  },
  isWindow: isWindow,
  each: each,
  css: css,
  clone: function clone(obj) {
    var i;
    var ret = {};

    for (i in obj) {
      if (obj.hasOwnProperty(i)) {
        ret[i] = obj[i];
      }
    }

    var overflow = obj.overflow;

    if (overflow) {
      for (i in obj) {
        if (obj.hasOwnProperty(i)) {
          ret.overflow[i] = obj.overflow[i];
        }
      }
    }

    return ret;
  },
  mix: dist_web_mix,
  getWindowScrollLeft: function getWindowScrollLeft(w) {
    return getScrollLeft(w);
  },
  getWindowScrollTop: function getWindowScrollTop(w) {
    return getScrollTop(w);
  },
  merge: function merge() {
    var ret = {};

    for (var i = 0; i < arguments.length; i++) {
      utils.mix(ret, i < 0 || arguments.length <= i ? undefined : arguments[i]);
    }

    return ret;
  },
  viewportWidth: 0,
  viewportHeight: 0
};
dist_web_mix(utils, domUtils);

/**
 * 
 */

var getParent = utils.getParent;

function getOffsetParent(element) {
  if (utils.isWindow(element) || element.nodeType === 9) {
    return null;
  } // ie 

  /*
   <div style="width: 50px;height: 100px;overflow: hidden">
   <div style="width: 50px;height: 100px;position: relative;" id="d6">
    6  100px  50px<br/>
   </div>
   </div>
   */
  // element.offsetParent does the right thing in ie7 and below. Return parent with layout!
  //  In other browsers it only includes elements with position absolute, relative or
  // fixed, not elements with overflow set to auto or scroll.
  //        if (UA.ie && ieMode < 8) {
  //            return element.offsetParent;
  //        }
  //  offsetParent 


  var doc = utils.getDocument(element);
  var body = doc.body;
  var parent;
  var positionStyle = utils.css(element, 'position');
  var skipStatic = positionStyle === 'fixed' || positionStyle === 'absolute';

  if (!skipStatic) {
    return element.nodeName.toLowerCase() === 'html' ? null : getParent(element);
  }

  for (parent = getParent(element); parent && parent !== body && parent.nodeType !== 9; parent = getParent(parent)) {
    positionStyle = utils.css(parent, 'position');

    if (positionStyle !== 'static') {
      return parent;
    }
  }

  return null;
}

var getParent$1 = utils.getParent;
function isAncestorFixed(element) {
  if (utils.isWindow(element) || element.nodeType === 9) {
    return false;
  }

  var doc = utils.getDocument(element);
  var body = doc.body;
  var parent = null;

  for (parent = getParent$1(element); //  document.documentElement 
  parent && parent !== body && parent !== doc; parent = getParent$1(parent)) {
    var positionStyle = utils.css(parent, 'position');

    if (positionStyle === 'fixed') {
      return true;
    }
  }

  return false;
}

/**
 * 
 */

function getVisibleRectForElement(element, alwaysByViewport) {
  var visibleRect = {
    left: 0,
    right: Infinity,
    top: 0,
    bottom: Infinity
  };
  var el = getOffsetParent(element);
  var doc = utils.getDocument(element);
  var win = doc.defaultView || doc.parentWindow;
  var body = doc.body;
  var documentElement = doc.documentElement; // Determine the size of the visible rect by climbing the dom accounting for
  // all scrollable containers.

  while (el) {
    // clientWidth is zero for inline block elements in ie.
    if ((navigator.userAgent.indexOf('MSIE') === -1 || el.clientWidth !== 0) && // body may have overflow set on it, yet we still get the entire
    // viewport. In some browsers, el.offsetParent may be
    // document.documentElement, so check for that too.
    el !== body && el !== documentElement && utils.css(el, 'overflow') !== 'visible') {
      var pos = utils.offset(el); // add border

      pos.left += el.clientLeft;
      pos.top += el.clientTop;
      visibleRect.top = Math.max(visibleRect.top, pos.top);
      visibleRect.right = Math.min(visibleRect.right, // consider area without scrollBar
      pos.left + el.clientWidth);
      visibleRect.bottom = Math.min(visibleRect.bottom, pos.top + el.clientHeight);
      visibleRect.left = Math.max(visibleRect.left, pos.left);
    } else if (el === body || el === documentElement) {
      break;
    }

    el = getOffsetParent(el);
  } // Set element position to fixed
  // make sure absolute element itself don't affect it's visible area
  // https://github.com/ant-design/ant-design/issues/7601


  var originalPosition = null;

  if (!utils.isWindow(element) && element.nodeType !== 9) {
    originalPosition = element.style.position;
    var position = utils.css(element, 'position');

    if (position === 'absolute') {
      element.style.position = 'fixed';
    }
  }

  var scrollX = utils.getWindowScrollLeft(win);
  var scrollY = utils.getWindowScrollTop(win);
  var viewportWidth = utils.viewportWidth(win);
  var viewportHeight = utils.viewportHeight(win);
  var documentWidth = documentElement.scrollWidth;
  var documentHeight = documentElement.scrollHeight; // scrollXXX on html is sync with body which means overflow: hidden on body gets wrong scrollXXX.
  // We should cut this ourself.

  var bodyStyle = window.getComputedStyle(body);

  if (bodyStyle.overflowX === 'hidden') {
    documentWidth = win.innerWidth;
  }

  if (bodyStyle.overflowY === 'hidden') {
    documentHeight = win.innerHeight;
  } // Reset element position after calculate the visible area


  if (element.style) {
    element.style.position = originalPosition;
  }

  if (alwaysByViewport || isAncestorFixed(element)) {
    // Clip by viewport's size.
    visibleRect.left = Math.max(visibleRect.left, scrollX);
    visibleRect.top = Math.max(visibleRect.top, scrollY);
    visibleRect.right = Math.min(visibleRect.right, scrollX + viewportWidth);
    visibleRect.bottom = Math.min(visibleRect.bottom, scrollY + viewportHeight);
  } else {
    // Clip by document's size.
    var maxVisibleWidth = Math.max(documentWidth, scrollX + viewportWidth);
    visibleRect.right = Math.min(visibleRect.right, maxVisibleWidth);
    var maxVisibleHeight = Math.max(documentHeight, scrollY + viewportHeight);
    visibleRect.bottom = Math.min(visibleRect.bottom, maxVisibleHeight);
  }

  return visibleRect.top >= 0 && visibleRect.left >= 0 && visibleRect.bottom > visibleRect.top && visibleRect.right > visibleRect.left ? visibleRect : null;
}

function adjustForViewport(elFuturePos, elRegion, visibleRect, overflow) {
  var pos = utils.clone(elFuturePos);
  var size = {
    width: elRegion.width,
    height: elRegion.height
  };

  if (overflow.adjustX && pos.left < visibleRect.left) {
    pos.left = visibleRect.left;
  } // Left edge inside and right edge outside viewport, try to resize it.


  if (overflow.resizeWidth && pos.left >= visibleRect.left && pos.left + size.width > visibleRect.right) {
    size.width -= pos.left + size.width - visibleRect.right;
  } // Right edge outside viewport, try to move it.


  if (overflow.adjustX && pos.left + size.width > visibleRect.right) {
    // 
    pos.left = Math.max(visibleRect.right - size.width, visibleRect.left);
  } // Top edge outside viewport, try to move it.


  if (overflow.adjustY && pos.top < visibleRect.top) {
    pos.top = visibleRect.top;
  } // Top edge inside and bottom edge outside viewport, try to resize it.


  if (overflow.resizeHeight && pos.top >= visibleRect.top && pos.top + size.height > visibleRect.bottom) {
    size.height -= pos.top + size.height - visibleRect.bottom;
  } // Bottom edge outside viewport, try to move it.


  if (overflow.adjustY && pos.top + size.height > visibleRect.bottom) {
    // 
    pos.top = Math.max(visibleRect.bottom - size.height, visibleRect.top);
  }

  return utils.mix(pos, size);
}

function getRegion(node) {
  var offset;
  var w;
  var h;

  if (!utils.isWindow(node) && node.nodeType !== 9) {
    offset = utils.offset(node);
    w = utils.outerWidth(node);
    h = utils.outerHeight(node);
  } else {
    var win = utils.getWindow(node);
    offset = {
      left: utils.getWindowScrollLeft(win),
      top: utils.getWindowScrollTop(win)
    };
    w = utils.viewportWidth(win);
    h = utils.viewportHeight(win);
  }

  offset.width = w;
  offset.height = h;
  return offset;
}

/**
 *  node  align  
 */
function getAlignOffset(region, align) {
  var V = align.charAt(0);
  var H = align.charAt(1);
  var w = region.width;
  var h = region.height;
  var x = region.left;
  var y = region.top;

  if (V === 'c') {
    y += h / 2;
  } else if (V === 'b') {
    y += h;
  }

  if (H === 'c') {
    x += w / 2;
  } else if (H === 'r') {
    x += w;
  }

  return {
    left: x,
    top: y
  };
}

function getElFuturePos(elRegion, refNodeRegion, points, offset, targetOffset) {
  var p1 = getAlignOffset(refNodeRegion, points[1]);
  var p2 = getAlignOffset(elRegion, points[0]);
  var diff = [p2.left - p1.left, p2.top - p1.top];
  return {
    left: Math.round(elRegion.left - diff[0] + offset[0] - targetOffset[0]),
    top: Math.round(elRegion.top - diff[1] + offset[1] - targetOffset[1])
  };
}

/**
 * align dom node flexibly
 * @author yiminghe@gmail.com
 */

function isFailX(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.left < visibleRect.left || elFuturePos.left + elRegion.width > visibleRect.right;
}

function isFailY(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.top < visibleRect.top || elFuturePos.top + elRegion.height > visibleRect.bottom;
}

function isCompleteFailX(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.left > visibleRect.right || elFuturePos.left + elRegion.width < visibleRect.left;
}

function isCompleteFailY(elFuturePos, elRegion, visibleRect) {
  return elFuturePos.top > visibleRect.bottom || elFuturePos.top + elRegion.height < visibleRect.top;
}

function flip(points, reg, map) {
  var ret = [];
  utils.each(points, function (p) {
    ret.push(p.replace(reg, function (m) {
      return map[m];
    }));
  });
  return ret;
}

function flipOffset(offset, index) {
  offset[index] = -offset[index];
  return offset;
}

function convertOffset(str, offsetLen) {
  var n;

  if (/%$/.test(str)) {
    n = parseInt(str.substring(0, str.length - 1), 10) / 100 * offsetLen;
  } else {
    n = parseInt(str, 10);
  }

  return n || 0;
}

function normalizeOffset(offset, el) {
  offset[0] = convertOffset(offset[0], el.width);
  offset[1] = convertOffset(offset[1], el.height);
}
/**
 * @param el
 * @param tgtRegion : { left, top, width, height }
 * @param align
 */


function doAlign(el, tgtRegion, align, isTgtRegionVisible) {
  var points = align.points;
  var offset = align.offset || [0, 0];
  var targetOffset = align.targetOffset || [0, 0];
  var overflow = align.overflow;
  var source = align.source || el;
  offset = [].concat(offset);
  targetOffset = [].concat(targetOffset);
  overflow = overflow || {};
  var newOverflowCfg = {};
  var fail = 0;
  var alwaysByViewport = !!(overflow && overflow.alwaysByViewport); // 

  var visibleRect = getVisibleRectForElement(source, alwaysByViewport); // , left/top/width/height

  var elRegion = getRegion(source); //  offset 

  normalizeOffset(offset, elRegion);
  normalizeOffset(targetOffset, tgtRegion); // 

  var elFuturePos = getElFuturePos(elRegion, tgtRegion, points, offset, targetOffset); // 

  var newElRegion = utils.merge(elRegion, elFuturePos); // 

  if (visibleRect && (overflow.adjustX || overflow.adjustY) && isTgtRegionVisible) {
    if (overflow.adjustX) {
      // 
      if (isFailX(elFuturePos, elRegion, visibleRect)) {
        // 
        var newPoints = flip(points, /[lr]/gi, {
          l: 'r',
          r: 'l'
        }); // 

        var newOffset = flipOffset(offset, 0);
        var newTargetOffset = flipOffset(targetOffset, 0);
        var newElFuturePos = getElFuturePos(elRegion, tgtRegion, newPoints, newOffset, newTargetOffset);

        if (!isCompleteFailX(newElFuturePos, elRegion, visibleRect)) {
          fail = 1;
          points = newPoints;
          offset = newOffset;
          targetOffset = newTargetOffset;
        }
      }
    }

    if (overflow.adjustY) {
      // 
      if (isFailY(elFuturePos, elRegion, visibleRect)) {
        // 
        var _newPoints = flip(points, /[tb]/gi, {
          t: 'b',
          b: 't'
        }); // 


        var _newOffset = flipOffset(offset, 1);

        var _newTargetOffset = flipOffset(targetOffset, 1);

        var _newElFuturePos = getElFuturePos(elRegion, tgtRegion, _newPoints, _newOffset, _newTargetOffset);

        if (!isCompleteFailY(_newElFuturePos, elRegion, visibleRect)) {
          fail = 1;
          points = _newPoints;
          offset = _newOffset;
          targetOffset = _newTargetOffset;
        }
      }
    } // 


    if (fail) {
      elFuturePos = getElFuturePos(elRegion, tgtRegion, points, offset, targetOffset);
      utils.mix(newElRegion, elFuturePos);
    }

    var isStillFailX = isFailX(elFuturePos, elRegion, visibleRect);
    var isStillFailY = isFailY(elFuturePos, elRegion, visibleRect); // 
    // 1. 

    if (isStillFailX || isStillFailY) {
      var _newPoints2 = points; // 

      if (isStillFailX) {
        _newPoints2 = flip(points, /[lr]/gi, {
          l: 'r',
          r: 'l'
        });
      }

      if (isStillFailY) {
        _newPoints2 = flip(points, /[tb]/gi, {
          t: 'b',
          b: 't'
        });
      }

      points = _newPoints2;
      offset = align.offset || [0, 0];
      targetOffset = align.targetOffset || [0, 0];
    } // 2. 


    newOverflowCfg.adjustX = overflow.adjustX && isStillFailX;
    newOverflowCfg.adjustY = overflow.adjustY && isStillFailY; // 

    if (newOverflowCfg.adjustX || newOverflowCfg.adjustY) {
      newElRegion = adjustForViewport(elFuturePos, elRegion, visibleRect, newOverflowCfg);
    }
  } // need judge to in case set fixed with in css on height auto element


  if (newElRegion.width !== elRegion.width) {
    utils.css(source, 'width', utils.width(source) + newElRegion.width - elRegion.width);
  }

  if (newElRegion.height !== elRegion.height) {
    utils.css(source, 'height', utils.height(source) + newElRegion.height - elRegion.height);
  } // https://github.com/kissyteam/kissy/issues/190
  //  left/top 
  //  <div 'relative'><el absolute></div>


  utils.offset(source, {
    left: newElRegion.left,
    top: newElRegion.top
  }, {
    useCssRight: align.useCssRight,
    useCssBottom: align.useCssBottom,
    useCssTransform: align.useCssTransform,
    ignoreShake: align.ignoreShake
  });
  return {
    points: points,
    offset: offset,
    targetOffset: targetOffset,
    overflow: newOverflowCfg
  };
}
/**
 *  2012-04-26 yiminghe@gmail.com
 *   - 
 *   -  resizeXX
 *
 *  2011-07-13 yiminghe@gmail.com note:
 *   - 
 **/

function isOutOfVisibleRect(target, alwaysByViewport) {
  var visibleRect = getVisibleRectForElement(target, alwaysByViewport);
  var targetRegion = getRegion(target);
  return !visibleRect || targetRegion.left + targetRegion.width <= visibleRect.left || targetRegion.top + targetRegion.height <= visibleRect.top || targetRegion.left >= visibleRect.right || targetRegion.top >= visibleRect.bottom;
}

function alignElement(el, refNode, align) {
  var target = align.target || refNode;
  var refNodeRegion = getRegion(target);
  var isTargetNotOutOfVisible = !isOutOfVisibleRect(target, align.overflow && align.overflow.alwaysByViewport);
  return doAlign(el, refNodeRegion, align, isTargetNotOutOfVisible);
}

alignElement.__getOffsetParent = getOffsetParent;
alignElement.__getVisibleRectForElement = getVisibleRectForElement;

/**
 * `tgtPoint`: { pageX, pageY } or { clientX, clientY }.
 * If client position provided, will internal convert to page position.
 */

function alignPoint(el, tgtPoint, align) {
  var pageX;
  var pageY;
  var doc = utils.getDocument(el);
  var win = doc.defaultView || doc.parentWindow;
  var scrollX = utils.getWindowScrollLeft(win);
  var scrollY = utils.getWindowScrollTop(win);
  var viewportWidth = utils.viewportWidth(win);
  var viewportHeight = utils.viewportHeight(win);

  if ('pageX' in tgtPoint) {
    pageX = tgtPoint.pageX;
  } else {
    pageX = scrollX + tgtPoint.clientX;
  }

  if ('pageY' in tgtPoint) {
    pageY = tgtPoint.pageY;
  } else {
    pageY = scrollY + tgtPoint.clientY;
  }

  var tgtRegion = {
    left: pageX,
    top: pageY,
    width: 0,
    height: 0
  };
  var pointInView = pageX >= 0 && pageX <= scrollX + viewportWidth && pageY >= 0 && pageY <= scrollY + viewportHeight; // Provide default target point

  var points = [align.points[0], 'cc'];
  return doAlign(el, tgtRegion, dist_web_objectSpread2(dist_web_objectSpread2({}, align), {}, {
    points: points
  }), pointInView);
}

/* harmony default export */ const dist_web = ((/* unused pure expression or super */ null && (alignElement)));

//# sourceMappingURL=index.js.map

// EXTERNAL MODULE: ./node_modules/lodash/isEqual.js
var isEqual = __webpack_require__(8446);
var isEqual_default = /*#__PURE__*/__webpack_require__.n(isEqual);
;// CONCATENATED MODULE: ./node_modules/resize-observer-polyfill/dist/ResizeObserver.es.js
/**
 * A collection of shims that provide minimal functionality of the ES6 collections.
 *
 * These implementations are not meant to be used outside of the ResizeObserver
 * modules as they cover only a limited range of use cases.
 */
/* eslint-disable require-jsdoc, valid-jsdoc */
var MapShim = (function () {
    if (typeof Map !== 'undefined') {
        return Map;
    }
    /**
     * Returns index in provided array that matches the specified key.
     *
     * @param {Array<Array>} arr
     * @param {*} key
     * @returns {number}
     */
    function getIndex(arr, key) {
        var result = -1;
        arr.some(function (entry, index) {
            if (entry[0] === key) {
                result = index;
                return true;
            }
            return false;
        });
        return result;
    }
    return /** @class */ (function () {
        function class_1() {
            this.__entries__ = [];
        }
        Object.defineProperty(class_1.prototype, "size", {
            /**
             * @returns {boolean}
             */
            get: function () {
                return this.__entries__.length;
            },
            enumerable: true,
            configurable: true
        });
        /**
         * @param {*} key
         * @returns {*}
         */
        class_1.prototype.get = function (key) {
            var index = getIndex(this.__entries__, key);
            var entry = this.__entries__[index];
            return entry && entry[1];
        };
        /**
         * @param {*} key
         * @param {*} value
         * @returns {void}
         */
        class_1.prototype.set = function (key, value) {
            var index = getIndex(this.__entries__, key);
            if (~index) {
                this.__entries__[index][1] = value;
            }
            else {
                this.__entries__.push([key, value]);
            }
        };
        /**
         * @param {*} key
         * @returns {void}
         */
        class_1.prototype.delete = function (key) {
            var entries = this.__entries__;
            var index = getIndex(entries, key);
            if (~index) {
                entries.splice(index, 1);
            }
        };
        /**
         * @param {*} key
         * @returns {void}
         */
        class_1.prototype.has = function (key) {
            return !!~getIndex(this.__entries__, key);
        };
        /**
         * @returns {void}
         */
        class_1.prototype.clear = function () {
            this.__entries__.splice(0);
        };
        /**
         * @param {Function} callback
         * @param {*} [ctx=null]
         * @returns {void}
         */
        class_1.prototype.forEach = function (callback, ctx) {
            if (ctx === void 0) { ctx = null; }
            for (var _i = 0, _a = this.__entries__; _i < _a.length; _i++) {
                var entry = _a[_i];
                callback.call(ctx, entry[1], entry[0]);
            }
        };
        return class_1;
    }());
})();

/**
 * Detects whether window and document objects are available in current environment.
 */
var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined' && window.document === document;

// Returns global object of a current environment.
var global$1 = (function () {
    if (typeof __webpack_require__.g !== 'undefined' && __webpack_require__.g.Math === Math) {
        return __webpack_require__.g;
    }
    if (typeof self !== 'undefined' && self.Math === Math) {
        return self;
    }
    if (typeof window !== 'undefined' && window.Math === Math) {
        return window;
    }
    // eslint-disable-next-line no-new-func
    return Function('return this')();
})();

/**
 * A shim for the requestAnimationFrame which falls back to the setTimeout if
 * first one is not supported.
 *
 * @returns {number} Requests' identifier.
 */
var requestAnimationFrame$1 = (function () {
    if (typeof requestAnimationFrame === 'function') {
        // It's required to use a bounded function because IE sometimes throws
        // an "Invalid calling object" error if rAF is invoked without the global
        // object on the left hand side.
        return requestAnimationFrame.bind(global$1);
    }
    return function (callback) { return setTimeout(function () { return callback(Date.now()); }, 1000 / 60); };
})();

// Defines minimum timeout before adding a trailing call.
var trailingTimeout = 2;
/**
 * Creates a wrapper function which ensures that provided callback will be
 * invoked only once during the specified delay period.
 *
 * @param {Function} callback - Function to be invoked after the delay period.
 * @param {number} delay - Delay after which to invoke callback.
 * @returns {Function}
 */
function throttle (callback, delay) {
    var leadingCall = false, trailingCall = false, lastCallTime = 0;
    /**
     * Invokes the original callback function and schedules new invocation if
     * the "proxy" was called during current request.
     *
     * @returns {void}
     */
    function resolvePending() {
        if (leadingCall) {
            leadingCall = false;
            callback();
        }
        if (trailingCall) {
            proxy();
        }
    }
    /**
     * Callback invoked after the specified delay. It will further postpone
     * invocation of the original function delegating it to the
     * requestAnimationFrame.
     *
     * @returns {void}
     */
    function timeoutCallback() {
        requestAnimationFrame$1(resolvePending);
    }
    /**
     * Schedules invocation of the original function.
     *
     * @returns {void}
     */
    function proxy() {
        var timeStamp = Date.now();
        if (leadingCall) {
            // Reject immediately following calls.
            if (timeStamp - lastCallTime < trailingTimeout) {
                return;
            }
            // Schedule new call to be in invoked when the pending one is resolved.
            // This is important for "transitions" which never actually start
            // immediately so there is a chance that we might miss one if change
            // happens amids the pending invocation.
            trailingCall = true;
        }
        else {
            leadingCall = true;
            trailingCall = false;
            setTimeout(timeoutCallback, delay);
        }
        lastCallTime = timeStamp;
    }
    return proxy;
}

// Minimum delay before invoking the update of observers.
var REFRESH_DELAY = 20;
// A list of substrings of CSS properties used to find transition events that
// might affect dimensions of observed elements.
var transitionKeys = ['top', 'right', 'bottom', 'left', 'width', 'height', 'size', 'weight'];
// Check if MutationObserver is available.
var mutationObserverSupported = typeof MutationObserver !== 'undefined';
/**
 * Singleton controller class which handles updates of ResizeObserver instances.
 */
var ResizeObserverController = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserverController.
     *
     * @private
     */
    function ResizeObserverController() {
        /**
         * Indicates whether DOM listeners have been added.
         *
         * @private {boolean}
         */
        this.connected_ = false;
        /**
         * Tells that controller has subscribed for Mutation Events.
         *
         * @private {boolean}
         */
        this.mutationEventsAdded_ = false;
        /**
         * Keeps reference to the instance of MutationObserver.
         *
         * @private {MutationObserver}
         */
        this.mutationsObserver_ = null;
        /**
         * A list of connected observers.
         *
         * @private {Array<ResizeObserverSPI>}
         */
        this.observers_ = [];
        this.onTransitionEnd_ = this.onTransitionEnd_.bind(this);
        this.refresh = throttle(this.refresh.bind(this), REFRESH_DELAY);
    }
    /**
     * Adds observer to observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be added.
     * @returns {void}
     */
    ResizeObserverController.prototype.addObserver = function (observer) {
        if (!~this.observers_.indexOf(observer)) {
            this.observers_.push(observer);
        }
        // Add listeners if they haven't been added yet.
        if (!this.connected_) {
            this.connect_();
        }
    };
    /**
     * Removes observer from observers list.
     *
     * @param {ResizeObserverSPI} observer - Observer to be removed.
     * @returns {void}
     */
    ResizeObserverController.prototype.removeObserver = function (observer) {
        var observers = this.observers_;
        var index = observers.indexOf(observer);
        // Remove observer if it's present in registry.
        if (~index) {
            observers.splice(index, 1);
        }
        // Remove listeners if controller has no connected observers.
        if (!observers.length && this.connected_) {
            this.disconnect_();
        }
    };
    /**
     * Invokes the update of observers. It will continue running updates insofar
     * it detects changes.
     *
     * @returns {void}
     */
    ResizeObserverController.prototype.refresh = function () {
        var changesDetected = this.updateObservers_();
        // Continue running updates if changes have been detected as there might
        // be future ones caused by CSS transitions.
        if (changesDetected) {
            this.refresh();
        }
    };
    /**
     * Updates every observer from observers list and notifies them of queued
     * entries.
     *
     * @private
     * @returns {boolean} Returns "true" if any observer has detected changes in
     *      dimensions of it's elements.
     */
    ResizeObserverController.prototype.updateObservers_ = function () {
        // Collect observers that have active observations.
        var activeObservers = this.observers_.filter(function (observer) {
            return observer.gatherActive(), observer.hasActive();
        });
        // Deliver notifications in a separate cycle in order to avoid any
        // collisions between observers, e.g. when multiple instances of
        // ResizeObserver are tracking the same element and the callback of one
        // of them changes content dimensions of the observed target. Sometimes
        // this may result in notifications being blocked for the rest of observers.
        activeObservers.forEach(function (observer) { return observer.broadcastActive(); });
        return activeObservers.length > 0;
    };
    /**
     * Initializes DOM listeners.
     *
     * @private
     * @returns {void}
     */
    ResizeObserverController.prototype.connect_ = function () {
        // Do nothing if running in a non-browser environment or if listeners
        // have been already added.
        if (!isBrowser || this.connected_) {
            return;
        }
        // Subscription to the "Transitionend" event is used as a workaround for
        // delayed transitions. This way it's possible to capture at least the
        // final state of an element.
        document.addEventListener('transitionend', this.onTransitionEnd_);
        window.addEventListener('resize', this.refresh);
        if (mutationObserverSupported) {
            this.mutationsObserver_ = new MutationObserver(this.refresh);
            this.mutationsObserver_.observe(document, {
                attributes: true,
                childList: true,
                characterData: true,
                subtree: true
            });
        }
        else {
            document.addEventListener('DOMSubtreeModified', this.refresh);
            this.mutationEventsAdded_ = true;
        }
        this.connected_ = true;
    };
    /**
     * Removes DOM listeners.
     *
     * @private
     * @returns {void}
     */
    ResizeObserverController.prototype.disconnect_ = function () {
        // Do nothing if running in a non-browser environment or if listeners
        // have been already removed.
        if (!isBrowser || !this.connected_) {
            return;
        }
        document.removeEventListener('transitionend', this.onTransitionEnd_);
        window.removeEventListener('resize', this.refresh);
        if (this.mutationsObserver_) {
            this.mutationsObserver_.disconnect();
        }
        if (this.mutationEventsAdded_) {
            document.removeEventListener('DOMSubtreeModified', this.refresh);
        }
        this.mutationsObserver_ = null;
        this.mutationEventsAdded_ = false;
        this.connected_ = false;
    };
    /**
     * "Transitionend" event handler.
     *
     * @private
     * @param {TransitionEvent} event
     * @returns {void}
     */
    ResizeObserverController.prototype.onTransitionEnd_ = function (_a) {
        var _b = _a.propertyName, propertyName = _b === void 0 ? '' : _b;
        // Detect whether transition may affect dimensions of an element.
        var isReflowProperty = transitionKeys.some(function (key) {
            return !!~propertyName.indexOf(key);
        });
        if (isReflowProperty) {
            this.refresh();
        }
    };
    /**
     * Returns instance of the ResizeObserverController.
     *
     * @returns {ResizeObserverController}
     */
    ResizeObserverController.getInstance = function () {
        if (!this.instance_) {
            this.instance_ = new ResizeObserverController();
        }
        return this.instance_;
    };
    /**
     * Holds reference to the controller's instance.
     *
     * @private {ResizeObserverController}
     */
    ResizeObserverController.instance_ = null;
    return ResizeObserverController;
}());

/**
 * Defines non-writable/enumerable properties of the provided target object.
 *
 * @param {Object} target - Object for which to define properties.
 * @param {Object} props - Properties to be defined.
 * @returns {Object} Target object.
 */
var defineConfigurable = (function (target, props) {
    for (var _i = 0, _a = Object.keys(props); _i < _a.length; _i++) {
        var key = _a[_i];
        Object.defineProperty(target, key, {
            value: props[key],
            enumerable: false,
            writable: false,
            configurable: true
        });
    }
    return target;
});

/**
 * Returns the global object associated with provided element.
 *
 * @param {Object} target
 * @returns {Object}
 */
var getWindowOf = (function (target) {
    // Assume that the element is an instance of Node, which means that it
    // has the "ownerDocument" property from which we can retrieve a
    // corresponding global object.
    var ownerGlobal = target && target.ownerDocument && target.ownerDocument.defaultView;
    // Return the local global object if it's not possible extract one from
    // provided element.
    return ownerGlobal || global$1;
});

// Placeholder of an empty content rectangle.
var emptyRect = createRectInit(0, 0, 0, 0);
/**
 * Converts provided string to a number.
 *
 * @param {number|string} value
 * @returns {number}
 */
function toFloat(value) {
    return parseFloat(value) || 0;
}
/**
 * Extracts borders size from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @param {...string} positions - Borders positions (top, right, ...)
 * @returns {number}
 */
function getBordersSize(styles) {
    var positions = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        positions[_i - 1] = arguments[_i];
    }
    return positions.reduce(function (size, position) {
        var value = styles['border-' + position + '-width'];
        return size + toFloat(value);
    }, 0);
}
/**
 * Extracts paddings sizes from provided styles.
 *
 * @param {CSSStyleDeclaration} styles
 * @returns {Object} Paddings box.
 */
function getPaddings(styles) {
    var positions = ['top', 'right', 'bottom', 'left'];
    var paddings = {};
    for (var _i = 0, positions_1 = positions; _i < positions_1.length; _i++) {
        var position = positions_1[_i];
        var value = styles['padding-' + position];
        paddings[position] = toFloat(value);
    }
    return paddings;
}
/**
 * Calculates content rectangle of provided SVG element.
 *
 * @param {SVGGraphicsElement} target - Element content rectangle of which needs
 *      to be calculated.
 * @returns {DOMRectInit}
 */
function getSVGContentRect(target) {
    var bbox = target.getBBox();
    return createRectInit(0, 0, bbox.width, bbox.height);
}
/**
 * Calculates content rectangle of provided HTMLElement.
 *
 * @param {HTMLElement} target - Element for which to calculate the content rectangle.
 * @returns {DOMRectInit}
 */
function getHTMLElementContentRect(target) {
    // Client width & height properties can't be
    // used exclusively as they provide rounded values.
    var clientWidth = target.clientWidth, clientHeight = target.clientHeight;
    // By this condition we can catch all non-replaced inline, hidden and
    // detached elements. Though elements with width & height properties less
    // than 0.5 will be discarded as well.
    //
    // Without it we would need to implement separate methods for each of
    // those cases and it's not possible to perform a precise and performance
    // effective test for hidden elements. E.g. even jQuery's ':visible' filter
    // gives wrong results for elements with width & height less than 0.5.
    if (!clientWidth && !clientHeight) {
        return emptyRect;
    }
    var styles = getWindowOf(target).getComputedStyle(target);
    var paddings = getPaddings(styles);
    var horizPad = paddings.left + paddings.right;
    var vertPad = paddings.top + paddings.bottom;
    // Computed styles of width & height are being used because they are the
    // only dimensions available to JS that contain non-rounded values. It could
    // be possible to utilize the getBoundingClientRect if only it's data wasn't
    // affected by CSS transformations let alone paddings, borders and scroll bars.
    var width = toFloat(styles.width), height = toFloat(styles.height);
    // Width & height include paddings and borders when the 'border-box' box
    // model is applied (except for IE).
    if (styles.boxSizing === 'border-box') {
        // Following conditions are required to handle Internet Explorer which
        // doesn't include paddings and borders to computed CSS dimensions.
        //
        // We can say that if CSS dimensions + paddings are equal to the "client"
        // properties then it's either IE, and thus we don't need to subtract
        // anything, or an element merely doesn't have paddings/borders styles.
        if (Math.round(width + horizPad) !== clientWidth) {
            width -= getBordersSize(styles, 'left', 'right') + horizPad;
        }
        if (Math.round(height + vertPad) !== clientHeight) {
            height -= getBordersSize(styles, 'top', 'bottom') + vertPad;
        }
    }
    // Following steps can't be applied to the document's root element as its
    // client[Width/Height] properties represent viewport area of the window.
    // Besides, it's as well not necessary as the <html> itself neither has
    // rendered scroll bars nor it can be clipped.
    if (!isDocumentElement(target)) {
        // In some browsers (only in Firefox, actually) CSS width & height
        // include scroll bars size which can be removed at this step as scroll
        // bars are the only difference between rounded dimensions + paddings
        // and "client" properties, though that is not always true in Chrome.
        var vertScrollbar = Math.round(width + horizPad) - clientWidth;
        var horizScrollbar = Math.round(height + vertPad) - clientHeight;
        // Chrome has a rather weird rounding of "client" properties.
        // E.g. for an element with content width of 314.2px it sometimes gives
        // the client width of 315px and for the width of 314.7px it may give
        // 314px. And it doesn't happen all the time. So just ignore this delta
        // as a non-relevant.
        if (Math.abs(vertScrollbar) !== 1) {
            width -= vertScrollbar;
        }
        if (Math.abs(horizScrollbar) !== 1) {
            height -= horizScrollbar;
        }
    }
    return createRectInit(paddings.left, paddings.top, width, height);
}
/**
 * Checks whether provided element is an instance of the SVGGraphicsElement.
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
var isSVGGraphicsElement = (function () {
    // Some browsers, namely IE and Edge, don't have the SVGGraphicsElement
    // interface.
    if (typeof SVGGraphicsElement !== 'undefined') {
        return function (target) { return target instanceof getWindowOf(target).SVGGraphicsElement; };
    }
    // If it's so, then check that element is at least an instance of the
    // SVGElement and that it has the "getBBox" method.
    // eslint-disable-next-line no-extra-parens
    return function (target) { return (target instanceof getWindowOf(target).SVGElement &&
        typeof target.getBBox === 'function'); };
})();
/**
 * Checks whether provided element is a document element (<html>).
 *
 * @param {Element} target - Element to be checked.
 * @returns {boolean}
 */
function isDocumentElement(target) {
    return target === getWindowOf(target).document.documentElement;
}
/**
 * Calculates an appropriate content rectangle for provided html or svg element.
 *
 * @param {Element} target - Element content rectangle of which needs to be calculated.
 * @returns {DOMRectInit}
 */
function getContentRect(target) {
    if (!isBrowser) {
        return emptyRect;
    }
    if (isSVGGraphicsElement(target)) {
        return getSVGContentRect(target);
    }
    return getHTMLElementContentRect(target);
}
/**
 * Creates rectangle with an interface of the DOMRectReadOnly.
 * Spec: https://drafts.fxtf.org/geometry/#domrectreadonly
 *
 * @param {DOMRectInit} rectInit - Object with rectangle's x/y coordinates and dimensions.
 * @returns {DOMRectReadOnly}
 */
function createReadOnlyRect(_a) {
    var x = _a.x, y = _a.y, width = _a.width, height = _a.height;
    // If DOMRectReadOnly is available use it as a prototype for the rectangle.
    var Constr = typeof DOMRectReadOnly !== 'undefined' ? DOMRectReadOnly : Object;
    var rect = Object.create(Constr.prototype);
    // Rectangle's properties are not writable and non-enumerable.
    defineConfigurable(rect, {
        x: x, y: y, width: width, height: height,
        top: y,
        right: x + width,
        bottom: height + y,
        left: x
    });
    return rect;
}
/**
 * Creates DOMRectInit object based on the provided dimensions and the x/y coordinates.
 * Spec: https://drafts.fxtf.org/geometry/#dictdef-domrectinit
 *
 * @param {number} x - X coordinate.
 * @param {number} y - Y coordinate.
 * @param {number} width - Rectangle's width.
 * @param {number} height - Rectangle's height.
 * @returns {DOMRectInit}
 */
function createRectInit(x, y, width, height) {
    return { x: x, y: y, width: width, height: height };
}

/**
 * Class that is responsible for computations of the content rectangle of
 * provided DOM element and for keeping track of it's changes.
 */
var ResizeObservation = /** @class */ (function () {
    /**
     * Creates an instance of ResizeObservation.
     *
     * @param {Element} target - Element to be observed.
     */
    function ResizeObservation(target) {
        /**
         * Broadcasted width of content rectangle.
         *
         * @type {number}
         */
        this.broadcastWidth = 0;
        /**
         * Broadcasted height of content rectangle.
         *
         * @type {number}
         */
        this.broadcastHeight = 0;
        /**
         * Reference to the last observed content rectangle.
         *
         * @private {DOMRectInit}
         */
        this.contentRect_ = createRectInit(0, 0, 0, 0);
        this.target = target;
    }
    /**
     * Updates content rectangle and tells whether it's width or height properties
     * have changed since the last broadcast.
     *
     * @returns {boolean}
     */
    ResizeObservation.prototype.isActive = function () {
        var rect = getContentRect(this.target);
        this.contentRect_ = rect;
        return (rect.width !== this.broadcastWidth ||
            rect.height !== this.broadcastHeight);
    };
    /**
     * Updates 'broadcastWidth' and 'broadcastHeight' properties with a data
     * from the corresponding properties of the last observed content rectangle.
     *
     * @returns {DOMRectInit} Last observed content rectangle.
     */
    ResizeObservation.prototype.broadcastRect = function () {
        var rect = this.contentRect_;
        this.broadcastWidth = rect.width;
        this.broadcastHeight = rect.height;
        return rect;
    };
    return ResizeObservation;
}());

var ResizeObserverEntry = /** @class */ (function () {
    /**
     * Creates an instance of ResizeObserverEntry.
     *
     * @param {Element} target - Element that is being observed.
     * @param {DOMRectInit} rectInit - Data of the element's content rectangle.
     */
    function ResizeObserverEntry(target, rectInit) {
        var contentRect = createReadOnlyRect(rectInit);
        // According to the specification following properties are not writable
        // and are also not enumerable in the native implementation.
        //
        // Property accessors are not being used as they'd require to define a
        // private WeakMap storage which may cause memory leaks in browsers that
        // don't support this type of collections.
        defineConfigurable(this, { target: target, contentRect: contentRect });
    }
    return ResizeObserverEntry;
}());

var ResizeObserverSPI = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback function that is invoked
     *      when one of the observed elements changes it's content dimensions.
     * @param {ResizeObserverController} controller - Controller instance which
     *      is responsible for the updates of observer.
     * @param {ResizeObserver} callbackCtx - Reference to the public
     *      ResizeObserver instance which will be passed to callback function.
     */
    function ResizeObserverSPI(callback, controller, callbackCtx) {
        /**
         * Collection of resize observations that have detected changes in dimensions
         * of elements.
         *
         * @private {Array<ResizeObservation>}
         */
        this.activeObservations_ = [];
        /**
         * Registry of the ResizeObservation instances.
         *
         * @private {Map<Element, ResizeObservation>}
         */
        this.observations_ = new MapShim();
        if (typeof callback !== 'function') {
            throw new TypeError('The callback provided as parameter 1 is not a function.');
        }
        this.callback_ = callback;
        this.controller_ = controller;
        this.callbackCtx_ = callbackCtx;
    }
    /**
     * Starts observing provided element.
     *
     * @param {Element} target - Element to be observed.
     * @returns {void}
     */
    ResizeObserverSPI.prototype.observe = function (target) {
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        // Do nothing if current environment doesn't have the Element interface.
        if (typeof Element === 'undefined' || !(Element instanceof Object)) {
            return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        // Do nothing if element is already being observed.
        if (observations.has(target)) {
            return;
        }
        observations.set(target, new ResizeObservation(target));
        this.controller_.addObserver(this);
        // Force the update of observations.
        this.controller_.refresh();
    };
    /**
     * Stops observing provided element.
     *
     * @param {Element} target - Element to stop observing.
     * @returns {void}
     */
    ResizeObserverSPI.prototype.unobserve = function (target) {
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        // Do nothing if current environment doesn't have the Element interface.
        if (typeof Element === 'undefined' || !(Element instanceof Object)) {
            return;
        }
        if (!(target instanceof getWindowOf(target).Element)) {
            throw new TypeError('parameter 1 is not of type "Element".');
        }
        var observations = this.observations_;
        // Do nothing if element is not being observed.
        if (!observations.has(target)) {
            return;
        }
        observations.delete(target);
        if (!observations.size) {
            this.controller_.removeObserver(this);
        }
    };
    /**
     * Stops observing all elements.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.disconnect = function () {
        this.clearActive();
        this.observations_.clear();
        this.controller_.removeObserver(this);
    };
    /**
     * Collects observation instances the associated element of which has changed
     * it's content rectangle.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.gatherActive = function () {
        var _this = this;
        this.clearActive();
        this.observations_.forEach(function (observation) {
            if (observation.isActive()) {
                _this.activeObservations_.push(observation);
            }
        });
    };
    /**
     * Invokes initial callback function with a list of ResizeObserverEntry
     * instances collected from active resize observations.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.broadcastActive = function () {
        // Do nothing if observer doesn't have active observations.
        if (!this.hasActive()) {
            return;
        }
        var ctx = this.callbackCtx_;
        // Create ResizeObserverEntry instance for every active observation.
        var entries = this.activeObservations_.map(function (observation) {
            return new ResizeObserverEntry(observation.target, observation.broadcastRect());
        });
        this.callback_.call(ctx, entries, ctx);
        this.clearActive();
    };
    /**
     * Clears the collection of active observations.
     *
     * @returns {void}
     */
    ResizeObserverSPI.prototype.clearActive = function () {
        this.activeObservations_.splice(0);
    };
    /**
     * Tells whether observer has active observations.
     *
     * @returns {boolean}
     */
    ResizeObserverSPI.prototype.hasActive = function () {
        return this.activeObservations_.length > 0;
    };
    return ResizeObserverSPI;
}());

// Registry of internal observers. If WeakMap is not available use current shim
// for the Map collection as it has all required methods and because WeakMap
// can't be fully polyfilled anyway.
var observers = typeof WeakMap !== 'undefined' ? new WeakMap() : new MapShim();
/**
 * ResizeObserver API. Encapsulates the ResizeObserver SPI implementation
 * exposing only those methods and properties that are defined in the spec.
 */
var ResizeObserver = /** @class */ (function () {
    /**
     * Creates a new instance of ResizeObserver.
     *
     * @param {ResizeObserverCallback} callback - Callback that is invoked when
     *      dimensions of the observed elements change.
     */
    function ResizeObserver(callback) {
        if (!(this instanceof ResizeObserver)) {
            throw new TypeError('Cannot call a class as a function.');
        }
        if (!arguments.length) {
            throw new TypeError('1 argument required, but only 0 present.');
        }
        var controller = ResizeObserverController.getInstance();
        var observer = new ResizeObserverSPI(callback, controller, this);
        observers.set(this, observer);
    }
    return ResizeObserver;
}());
// Expose public methods of ResizeObserver.
[
    'observe',
    'unobserve',
    'disconnect'
].forEach(function (method) {
    ResizeObserver.prototype[method] = function () {
        var _a;
        return (_a = observers.get(this))[method].apply(_a, arguments);
    };
});

var index = (function () {
    // Export existing implementation if available.
    if (typeof global$1.ResizeObserver !== 'undefined') {
        return global$1.ResizeObserver;
    }
    return ResizeObserver;
})();

/* harmony default export */ const ResizeObserver_es = (index);

;// CONCATENATED MODULE: ./node_modules/rc-align/es/util.js



function isSamePoint(prev, next) {
  if (prev === next) return true;
  if (!prev || !next) return false;

  if ('pageX' in next && 'pageY' in next) {
    return prev.pageX === next.pageX && prev.pageY === next.pageY;
  }

  if ('clientX' in next && 'clientY' in next) {
    return prev.clientX === next.clientX && prev.clientY === next.clientY;
  }

  return false;
}
function restoreFocus(activeElement, container) {
  // Focus back if is in the container
  if (activeElement !== document.activeElement && contains(container, activeElement) && typeof activeElement.focus === 'function') {
    activeElement.focus();
  }
}
function monitorResize(element, callback) {
  var prevWidth = null;
  var prevHeight = null;

  function onResize(_ref) {
    var _ref2 = slicedToArray_slicedToArray(_ref, 1),
        target = _ref2[0].target;

    if (!document.documentElement.contains(target)) return;

    var _target$getBoundingCl = target.getBoundingClientRect(),
        width = _target$getBoundingCl.width,
        height = _target$getBoundingCl.height;

    var fixedWidth = Math.floor(width);
    var fixedHeight = Math.floor(height);

    if (prevWidth !== fixedWidth || prevHeight !== fixedHeight) {
      // https://webkit.org/blog/9997/resizeobserver-in-webkit/
      Promise.resolve().then(function () {
        callback({
          width: fixedWidth,
          height: fixedHeight
        });
      });
    }

    prevWidth = fixedWidth;
    prevHeight = fixedHeight;
  }

  var resizeObserver = new ResizeObserver_es(onResize);

  if (element) {
    resizeObserver.observe(element);
  }

  return function () {
    resizeObserver.disconnect();
  };
}
;// CONCATENATED MODULE: ./node_modules/rc-align/es/hooks/useBuffer.js

/* harmony default export */ const useBuffer = (function (callback, buffer) {
  var calledRef = external_React_default().useRef(false);
  var timeoutRef = external_React_default().useRef(null);

  function cancelTrigger() {
    window.clearTimeout(timeoutRef.current);
  }

  function trigger(force) {
    cancelTrigger();

    if (!calledRef.current || force === true) {
      if (callback() === false) {
        // Not delay since callback cancelled self
        return;
      }

      calledRef.current = true;
      timeoutRef.current = window.setTimeout(function () {
        calledRef.current = false;
      }, buffer);
    } else {
      timeoutRef.current = window.setTimeout(function () {
        calledRef.current = false;
        trigger();
      }, buffer);
    }
  }

  return [trigger, function () {
    calledRef.current = false;
    cancelTrigger();
  }];
});
;// CONCATENATED MODULE: ./node_modules/rc-align/es/Align.js



/**
 * Removed props:
 *  - childrenProps
 */









function getElement(func) {
  if (typeof func !== 'function') return null;
  return func();
}

function getPoint(point) {
  if (typeof_typeof(point) !== 'object' || !point) return null;
  return point;
}

var Align = function Align(_ref, ref) {
  var children = _ref.children,
      disabled = _ref.disabled,
      target = _ref.target,
      align = _ref.align,
      onAlign = _ref.onAlign,
      monitorWindowResize = _ref.monitorWindowResize,
      _ref$monitorBufferTim = _ref.monitorBufferTime,
      monitorBufferTime = _ref$monitorBufferTim === void 0 ? 0 : _ref$monitorBufferTim;
  var cacheRef = external_React_default().useRef({});
  var nodeRef = external_React_default().useRef();
  var childNode = external_React_default().Children.only(children); // ===================== Align ======================
  // We save the props here to avoid closure makes props ood

  var forceAlignPropsRef = external_React_default().useRef({});
  forceAlignPropsRef.current.disabled = disabled;
  forceAlignPropsRef.current.target = target;
  forceAlignPropsRef.current.align = align;
  forceAlignPropsRef.current.onAlign = onAlign;

  var _useBuffer = useBuffer(function () {
    var _forceAlignPropsRef$c = forceAlignPropsRef.current,
        latestDisabled = _forceAlignPropsRef$c.disabled,
        latestTarget = _forceAlignPropsRef$c.target,
        latestAlign = _forceAlignPropsRef$c.align,
        latestOnAlign = _forceAlignPropsRef$c.onAlign;

    if (!latestDisabled && latestTarget) {
      var source = nodeRef.current;
      var result;
      var element = getElement(latestTarget);
      var point = getPoint(latestTarget);
      cacheRef.current.element = element;
      cacheRef.current.point = point;
      cacheRef.current.align = latestAlign; // IE lose focus after element realign
      // We should record activeElement and restore later

      // IE lose focus after element realign
      // We should record activeElement and restore later
      var _document = document,
          activeElement = _document.activeElement; // We only align when element is visible

      // We only align when element is visible
      if (element && isVisible(element)) {
        result = alignElement(source, element, latestAlign);
      } else if (point) {
        result = alignPoint(source, point, latestAlign);
      }

      restoreFocus(activeElement, source);

      if (latestOnAlign && result) {
        latestOnAlign(source, result);
      }

      return true;
    }

    return false;
  }, monitorBufferTime),
      _useBuffer2 = slicedToArray_slicedToArray(_useBuffer, 2),
      _forceAlign = _useBuffer2[0],
      cancelForceAlign = _useBuffer2[1]; // ===================== Effect =====================
  // Listen for target updated


  var resizeMonitor = external_React_default().useRef({
    cancel: function cancel() {}
  }); // Listen for source updated

  var sourceResizeMonitor = external_React_default().useRef({
    cancel: function cancel() {}
  });
  external_React_default().useEffect(function () {
    var element = getElement(target);
    var point = getPoint(target);

    if (nodeRef.current !== sourceResizeMonitor.current.element) {
      sourceResizeMonitor.current.cancel();
      sourceResizeMonitor.current.element = nodeRef.current;
      sourceResizeMonitor.current.cancel = monitorResize(nodeRef.current, _forceAlign);
    }

    if (cacheRef.current.element !== element || !isSamePoint(cacheRef.current.point, point) || !isEqual_default()(cacheRef.current.align, align)) {
      _forceAlign(); // Add resize observer


      if (resizeMonitor.current.element !== element) {
        resizeMonitor.current.cancel();
        resizeMonitor.current.element = element;
        resizeMonitor.current.cancel = monitorResize(element, _forceAlign);
      }
    }
  }); // Listen for disabled change

  external_React_default().useEffect(function () {
    if (!disabled) {
      _forceAlign();
    } else {
      cancelForceAlign();
    }
  }, [disabled]); // Listen for window resize

  var winResizeRef = external_React_default().useRef(null);
  external_React_default().useEffect(function () {
    if (monitorWindowResize) {
      if (!winResizeRef.current) {
        winResizeRef.current = addEventListenerWrap(window, 'resize', _forceAlign);
      }
    } else if (winResizeRef.current) {
      winResizeRef.current.remove();
      winResizeRef.current = null;
    }
  }, [monitorWindowResize]); // Clear all if unmount

  external_React_default().useEffect(function () {
    return function () {
      resizeMonitor.current.cancel();
      sourceResizeMonitor.current.cancel();
      if (winResizeRef.current) winResizeRef.current.remove();
      cancelForceAlign();
    };
  }, []); // ====================== Ref =======================

  external_React_default().useImperativeHandle(ref, function () {
    return {
      forceAlign: function forceAlign() {
        return _forceAlign(true);
      }
    };
  }); // ===================== Render =====================

  if ( /*#__PURE__*/external_React_default().isValidElement(childNode)) {
    childNode = /*#__PURE__*/external_React_default().cloneElement(childNode, {
      ref: composeRef(childNode.ref, nodeRef)
    });
  }

  return childNode;
};

var RcAlign = /*#__PURE__*/external_React_default().forwardRef(Align);
RcAlign.displayName = 'Align';
/* harmony default export */ const es_Align = (RcAlign);
;// CONCATENATED MODULE: ./node_modules/rc-align/es/index.js
// export this package's api

/* harmony default export */ const rc_align_es = (es_Align);
;// CONCATENATED MODULE: ./node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js

function _regeneratorRuntime() {
  "use strict";
  /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */

  _regeneratorRuntime = function _regeneratorRuntime() {
    return exports;
  };

  var exports = {},
      Op = Object.prototype,
      hasOwn = Op.hasOwnProperty,
      $Symbol = "function" == typeof Symbol ? Symbol : {},
      iteratorSymbol = $Symbol.iterator || "@@iterator",
      asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator",
      toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";

  function define(obj, key, value) {
    return Object.defineProperty(obj, key, {
      value: value,
      enumerable: !0,
      configurable: !0,
      writable: !0
    }), obj[key];
  }

  try {
    define({}, "");
  } catch (err) {
    define = function define(obj, key, value) {
      return obj[key] = value;
    };
  }

  function wrap(innerFn, outerFn, self, tryLocsList) {
    var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator,
        generator = Object.create(protoGenerator.prototype),
        context = new Context(tryLocsList || []);
    return generator._invoke = function (innerFn, self, context) {
      var state = "suspendedStart";
      return function (method, arg) {
        if ("executing" === state) throw new Error("Generator is already running");

        if ("completed" === state) {
          if ("throw" === method) throw arg;
          return doneResult();
        }

        for (context.method = method, context.arg = arg;;) {
          var delegate = context.delegate;

          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);

            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }

          if ("next" === context.method) context.sent = context._sent = context.arg;else if ("throw" === context.method) {
            if ("suspendedStart" === state) throw state = "completed", context.arg;
            context.dispatchException(context.arg);
          } else "return" === context.method && context.abrupt("return", context.arg);
          state = "executing";
          var record = tryCatch(innerFn, self, context);

          if ("normal" === record.type) {
            if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
            return {
              value: record.arg,
              done: context.done
            };
          }

          "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
        }
      };
    }(innerFn, self, context), generator;
  }

  function tryCatch(fn, obj, arg) {
    try {
      return {
        type: "normal",
        arg: fn.call(obj, arg)
      };
    } catch (err) {
      return {
        type: "throw",
        arg: err
      };
    }
  }

  exports.wrap = wrap;
  var ContinueSentinel = {};

  function Generator() {}

  function GeneratorFunction() {}

  function GeneratorFunctionPrototype() {}

  var IteratorPrototype = {};
  define(IteratorPrototype, iteratorSymbol, function () {
    return this;
  });
  var getProto = Object.getPrototypeOf,
      NativeIteratorPrototype = getProto && getProto(getProto(values([])));
  NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
  var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);

  function defineIteratorMethods(prototype) {
    ["next", "throw", "return"].forEach(function (method) {
      define(prototype, method, function (arg) {
        return this._invoke(method, arg);
      });
    });
  }

  function AsyncIterator(generator, PromiseImpl) {
    function invoke(method, arg, resolve, reject) {
      var record = tryCatch(generator[method], generator, arg);

      if ("throw" !== record.type) {
        var result = record.arg,
            value = result.value;
        return value && "object" == typeof_typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function (value) {
          invoke("next", value, resolve, reject);
        }, function (err) {
          invoke("throw", err, resolve, reject);
        }) : PromiseImpl.resolve(value).then(function (unwrapped) {
          result.value = unwrapped, resolve(result);
        }, function (error) {
          return invoke("throw", error, resolve, reject);
        });
      }

      reject(record.arg);
    }

    var previousPromise;

    this._invoke = function (method, arg) {
      function callInvokeWithMethodAndArg() {
        return new PromiseImpl(function (resolve, reject) {
          invoke(method, arg, resolve, reject);
        });
      }

      return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
    };
  }

  function maybeInvokeDelegate(delegate, context) {
    var method = delegate.iterator[context.method];

    if (undefined === method) {
      if (context.delegate = null, "throw" === context.method) {
        if (delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method)) return ContinueSentinel;
        context.method = "throw", context.arg = new TypeError("The iterator does not provide a 'throw' method");
      }

      return ContinueSentinel;
    }

    var record = tryCatch(method, delegate.iterator, context.arg);
    if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
    var info = record.arg;
    return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
  }

  function pushTryEntry(locs) {
    var entry = {
      tryLoc: locs[0]
    };
    1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
  }

  function resetTryEntry(entry) {
    var record = entry.completion || {};
    record.type = "normal", delete record.arg, entry.completion = record;
  }

  function Context(tryLocsList) {
    this.tryEntries = [{
      tryLoc: "root"
    }], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
  }

  function values(iterable) {
    if (iterable) {
      var iteratorMethod = iterable[iteratorSymbol];
      if (iteratorMethod) return iteratorMethod.call(iterable);
      if ("function" == typeof iterable.next) return iterable;

      if (!isNaN(iterable.length)) {
        var i = -1,
            next = function next() {
          for (; ++i < iterable.length;) {
            if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
          }

          return next.value = undefined, next.done = !0, next;
        };

        return next.next = next;
      }
    }

    return {
      next: doneResult
    };
  }

  function doneResult() {
    return {
      value: undefined,
      done: !0
    };
  }

  return GeneratorFunction.prototype = GeneratorFunctionPrototype, define(Gp, "constructor", GeneratorFunctionPrototype), define(GeneratorFunctionPrototype, "constructor", GeneratorFunction), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function (genFun) {
    var ctor = "function" == typeof genFun && genFun.constructor;
    return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
  }, exports.mark = function (genFun) {
    return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
  }, exports.awrap = function (arg) {
    return {
      __await: arg
    };
  }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function () {
    return this;
  }), exports.AsyncIterator = AsyncIterator, exports.async = function (innerFn, outerFn, self, tryLocsList, PromiseImpl) {
    void 0 === PromiseImpl && (PromiseImpl = Promise);
    var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
    return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function (result) {
      return result.done ? result.value : iter.next();
    });
  }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function () {
    return this;
  }), define(Gp, "toString", function () {
    return "[object Generator]";
  }), exports.keys = function (object) {
    var keys = [];

    for (var key in object) {
      keys.push(key);
    }

    return keys.reverse(), function next() {
      for (; keys.length;) {
        var key = keys.pop();
        if (key in object) return next.value = key, next.done = !1, next;
      }

      return next.done = !0, next;
    };
  }, exports.values = values, Context.prototype = {
    constructor: Context,
    reset: function reset(skipTempReset) {
      if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for (var name in this) {
        "t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
      }
    },
    stop: function stop() {
      this.done = !0;
      var rootRecord = this.tryEntries[0].completion;
      if ("throw" === rootRecord.type) throw rootRecord.arg;
      return this.rval;
    },
    dispatchException: function dispatchException(exception) {
      if (this.done) throw exception;
      var context = this;

      function handle(loc, caught) {
        return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
      }

      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i],
            record = entry.completion;
        if ("root" === entry.tryLoc) return handle("end");

        if (entry.tryLoc <= this.prev) {
          var hasCatch = hasOwn.call(entry, "catchLoc"),
              hasFinally = hasOwn.call(entry, "finallyLoc");

          if (hasCatch && hasFinally) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          } else if (hasCatch) {
            if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
          } else {
            if (!hasFinally) throw new Error("try statement without catch or finally");
            if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
          }
        }
      }
    },
    abrupt: function abrupt(type, arg) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
          var finallyEntry = entry;
          break;
        }
      }

      finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
      var record = finallyEntry ? finallyEntry.completion : {};
      return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
    },
    complete: function complete(record, afterLoc) {
      if ("throw" === record.type) throw record.arg;
      return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
    },
    finish: function finish(finallyLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];
        if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
      }
    },
    "catch": function _catch(tryLoc) {
      for (var i = this.tryEntries.length - 1; i >= 0; --i) {
        var entry = this.tryEntries[i];

        if (entry.tryLoc === tryLoc) {
          var record = entry.completion;

          if ("throw" === record.type) {
            var thrown = record.arg;
            resetTryEntry(entry);
          }

          return thrown;
        }
      }

      throw new Error("illegal catch attempt");
    },
    delegateYield: function delegateYield(iterable, resultName, nextLoc) {
      return this.delegate = {
        iterator: values(iterable),
        resultName: resultName,
        nextLoc: nextLoc
      }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
    }
  }, exports;
}
;// CONCATENATED MODULE: ./node_modules/rc-trigger/es/Popup/useVisibleStatus.js






var StatusQueue = ['measure', 'alignPre', 'align', null, 'motion'];
/* harmony default export */ const useVisibleStatus = (function (visible, doMeasure) {
  var _useState = useSafeState(null),
      _useState2 = slicedToArray_slicedToArray(_useState, 2),
      status = _useState2[0],
      setInternalStatus = _useState2[1];

  var rafRef = (0,external_React_namespaceObject.useRef)();

  function setStatus(nextStatus) {
    setInternalStatus(nextStatus, true);
  }

  function cancelRaf() {
    wrapperRaf.cancel(rafRef.current);
  }

  function goNextStatus(callback) {
    cancelRaf();
    rafRef.current = wrapperRaf(function () {
      // Only align should be manually trigger
      setStatus(function (prev) {
        switch (status) {
          case 'align':
            return 'motion';

          case 'motion':
            return 'stable';

          default:
        }

        return prev;
      });
      callback === null || callback === void 0 ? void 0 : callback();
    });
  } // Init status


  (0,external_React_namespaceObject.useEffect)(function () {
    setStatus('measure');
  }, [visible]); // Go next status

  (0,external_React_namespaceObject.useEffect)(function () {
    switch (status) {
      case 'measure':
        doMeasure();
        break;

      default:
    }

    if (status) {
      rafRef.current = wrapperRaf( /*#__PURE__*/_asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {
        var index, nextStatus;
        return _regeneratorRuntime().wrap(function _callee$(_context) {
          while (1) {
            switch (_context.prev = _context.next) {
              case 0:
                index = StatusQueue.indexOf(status);
                nextStatus = StatusQueue[index + 1];

                if (nextStatus && index !== -1) {
                  setStatus(nextStatus);
                }

              case 3:
              case "end":
                return _context.stop();
            }
          }
        }, _callee);
      })));
    }
  }, [status]);
  (0,external_React_namespaceObject.useEffect)(function () {
    return function () {
      cancelRaf();
    };
  }, []);
  return [status, goNextStatus];
});
;// CONCATENATED MODULE: ./node_modules/rc-trigger/es/Popup/useStretchStyle.js


/* harmony default export */ const useStretchStyle = (function (stretch) {
  var _React$useState = external_React_namespaceObject.useState({
    width: 0,
    height: 0
  }),
      _React$useState2 = slicedToArray_slicedToArray(_React$useState, 2),
      targetSize = _React$useState2[0],
      setTargetSize = _React$useState2[1];

  function measureStretch(element) {
    setTargetSize({
      width: element.offsetWidth,
      height: element.offsetHeight
    });
  } // Merge stretch style


  var style = external_React_namespaceObject.useMemo(function () {
    var sizeStyle = {};

    if (stretch) {
      var width = targetSize.width,
          height = targetSize.height; // Stretch with target

      if (stretch.indexOf('height') !== -1 && height) {
        sizeStyle.height = height;
      } else if (stretch.indexOf('minHeight') !== -1 && height) {
        sizeStyle.minHeight = height;
      }

      if (stretch.indexOf('width') !== -1 && width) {
        sizeStyle.width = width;
      } else if (stretch.indexOf('minWidth') !== -1 && width) {
        sizeStyle.minWidth = width;
      }
    }

    return sizeStyle;
  }, [stretch, targetSize]);
  return [style, measureStretch];
});
;// CONCATENATED MODULE: ./node_modules/rc-trigger/es/Popup/PopupInner.js












var PopupInner = /*#__PURE__*/external_React_namespaceObject.forwardRef(function (props, ref) {
  var visible = props.visible,
      prefixCls = props.prefixCls,
      className = props.className,
      style = props.style,
      children = props.children,
      zIndex = props.zIndex,
      stretch = props.stretch,
      destroyPopupOnHide = props.destroyPopupOnHide,
      forceRender = props.forceRender,
      align = props.align,
      point = props.point,
      getRootDomNode = props.getRootDomNode,
      getClassNameFromAlign = props.getClassNameFromAlign,
      onAlign = props.onAlign,
      onMouseEnter = props.onMouseEnter,
      onMouseLeave = props.onMouseLeave,
      onMouseDown = props.onMouseDown,
      onTouchStart = props.onTouchStart,
      onClick = props.onClick;
  var alignRef = (0,external_React_namespaceObject.useRef)();
  var elementRef = (0,external_React_namespaceObject.useRef)();

  var _useState = (0,external_React_namespaceObject.useState)(),
      _useState2 = slicedToArray_slicedToArray(_useState, 2),
      alignedClassName = _useState2[0],
      setAlignedClassName = _useState2[1]; // ======================= Measure ========================


  var _useStretchStyle = useStretchStyle(stretch),
      _useStretchStyle2 = slicedToArray_slicedToArray(_useStretchStyle, 2),
      stretchStyle = _useStretchStyle2[0],
      measureStretchStyle = _useStretchStyle2[1];

  function doMeasure() {
    if (stretch) {
      measureStretchStyle(getRootDomNode());
    }
  } // ======================== Status ========================


  var _useVisibleStatus = useVisibleStatus(visible, doMeasure),
      _useVisibleStatus2 = slicedToArray_slicedToArray(_useVisibleStatus, 2),
      status = _useVisibleStatus2[0],
      goNextStatus = _useVisibleStatus2[1]; // ======================== Aligns ========================

  /**
   * `alignedClassName` may modify `source` size,
   * which means one time align may not move to the correct position at once.
   *
   * We will reset `alignTimes` for each status switch to `alignPre`
   * and let `rc-align` to align for multiple times to ensure get final stable place.
   * Currently we mark `alignTimes < 2` repeat align, it will increase if user report for align issue.
   */


  var _useState3 = (0,external_React_namespaceObject.useState)(0),
      _useState4 = slicedToArray_slicedToArray(_useState3, 2),
      alignTimes = _useState4[0],
      setAlignTimes = _useState4[1];

  var prepareResolveRef = (0,external_React_namespaceObject.useRef)();
  hooks_useLayoutEffect(function () {
    if (status === 'alignPre') {
      setAlignTimes(0);
    }
  }, [status]); // `target` on `rc-align` can accept as a function to get the bind element or a point.
  // ref: https://www.npmjs.com/package/rc-align

  function getAlignTarget() {
    if (point) {
      return point;
    }

    return getRootDomNode;
  }

  function forceAlign() {
    var _alignRef$current;

    (_alignRef$current = alignRef.current) === null || _alignRef$current === void 0 ? void 0 : _alignRef$current.forceAlign();
  }

  function onInternalAlign(popupDomNode, matchAlign) {
    var nextAlignedClassName = getClassNameFromAlign(matchAlign);

    if (alignedClassName !== nextAlignedClassName) {
      setAlignedClassName(nextAlignedClassName);
    } // We will retry multi times to make sure that the element has been align in the right position.


    setAlignTimes(function (val) {
      return val + 1;
    });

    if (status === 'align') {
      onAlign === null || onAlign === void 0 ? void 0 : onAlign(popupDomNode, matchAlign);
    }
  } // Delay to go to next status


  hooks_useLayoutEffect(function () {
    if (status === 'align') {
      // Repeat until not more align needed
      if (alignTimes < 2) {
        forceAlign();
      } else {
        goNextStatus(function () {
          var _prepareResolveRef$cu;

          (_prepareResolveRef$cu = prepareResolveRef.current) === null || _prepareResolveRef$cu === void 0 ? void 0 : _prepareResolveRef$cu.call(prepareResolveRef);
        });
      }
    }
  }, [alignTimes]); // ======================== Motion ========================

  var motion = _objectSpread2({}, getMotion(props));

  ['onAppearEnd', 'onEnterEnd', 'onLeaveEnd'].forEach(function (eventName) {
    var originHandler = motion[eventName];

    motion[eventName] = function (element, event) {
      goNextStatus();
      return originHandler === null || originHandler === void 0 ? void 0 : originHandler(element, event);
    };
  });

  function onShowPrepare() {
    return new Promise(function (resolve) {
      prepareResolveRef.current = resolve;
    });
  } // Go to stable directly when motion not provided


  external_React_namespaceObject.useEffect(function () {
    if (!motion.motionName && status === 'motion') {
      goNextStatus();
    }
  }, [motion.motionName, status]); // ========================= Refs =========================

  external_React_namespaceObject.useImperativeHandle(ref, function () {
    return {
      forceAlign: forceAlign,
      getElement: function getElement() {
        return elementRef.current;
      }
    };
  }); // ======================== Render ========================

  var mergedStyle = _objectSpread2(_objectSpread2({}, stretchStyle), {}, {
    zIndex: zIndex,
    opacity: status === 'motion' || status === 'stable' || !visible ? undefined : 0,
    // Cannot interact with disappearing elements
    // https://github.com/ant-design/ant-design/issues/35051#issuecomment-1101340714
    pointerEvents: !visible && status !== 'stable' ? 'none' : undefined
  }, style); // Align status


  var alignDisabled = true;

  if ((align === null || align === void 0 ? void 0 : align.points) && (status === 'align' || status === 'stable')) {
    alignDisabled = false;
  }

  var childNode = children; // Wrapper when multiple children

  if (external_React_namespaceObject.Children.count(children) > 1) {
    childNode = /*#__PURE__*/external_React_namespaceObject.createElement("div", {
      className: "".concat(prefixCls, "-content")
    }, children);
  }

  return /*#__PURE__*/external_React_namespaceObject.createElement(es, _extends({
    visible: visible,
    ref: elementRef,
    leavedClassName: "".concat(prefixCls, "-hidden")
  }, motion, {
    onAppearPrepare: onShowPrepare,
    onEnterPrepare: onShowPrepare,
    removeOnLeave: destroyPopupOnHide,
    forceRender: forceRender
  }), function (_ref, motionRef) {
    var motionClassName = _ref.className,
        motionStyle = _ref.style;
    var mergedClassName = classnames_default()(prefixCls, className, alignedClassName, motionClassName);
    return /*#__PURE__*/external_React_namespaceObject.createElement(rc_align_es, {
      target: getAlignTarget(),
      key: "popup",
      ref: alignRef,
      monitorWindowResize: true,
      disabled: alignDisabled,
      align: align,
      onAlign: onInternalAlign
    }, /*#__PURE__*/external_React_namespaceObject.createElement("div", {
      ref: motionRef,
      className: mergedClassName,
      onMouseEnter: onMouseEnter,
      onMouseLeave: onMouseLeave,
      onMouseDownCapture: onMouseDown,
      onTouchStartCapture: onTouchStart,
      onClick: onClick,
      style: _objectSpread2(_objectSpread2({}, motionStyle), mergedStyle)
    }, childNode));
  });
});
PopupInner.displayName = 'PopupInner';
/* harmony default export */ const Popup_PopupInner = (PopupInner);
;// CONCATENATED MODULE: ./node_modules/rc-trigger/es/Popup/MobilePopupInner.js





var MobilePopupInner = /*#__PURE__*/external_React_namespaceObject.forwardRef(function (props, ref) {
  var prefixCls = props.prefixCls,
      visible = props.visible,
      zIndex = props.zIndex,
      children = props.children,
      _props$mobile = props.mobile;
  _props$mobile = _props$mobile === void 0 ? {} : _props$mobile;
  var popupClassName = _props$mobile.popupClassName,
      popupStyle = _props$mobile.popupStyle,
      _props$mobile$popupMo = _props$mobile.popupMotion,
      popupMotion = _props$mobile$popupMo === void 0 ? {} : _props$mobile$popupMo,
      popupRender = _props$mobile.popupRender,
      onClick = props.onClick;
  var elementRef = external_React_namespaceObject.useRef(); // ========================= Refs =========================

  external_React_namespaceObject.useImperativeHandle(ref, function () {
    return {
      forceAlign: function forceAlign() {},
      getElement: function getElement() {
        return elementRef.current;
      }
    };
  }); // ======================== Render ========================

  var mergedStyle = _objectSpread2({
    zIndex: zIndex
  }, popupStyle);

  var childNode = children; // Wrapper when multiple children

  if (external_React_namespaceObject.Children.count(children) > 1) {
    childNode = /*#__PURE__*/external_React_namespaceObject.createElement("div", {
      className: "".concat(prefixCls, "-content")
    }, children);
  } // Mobile support additional render


  if (popupRender) {
    childNode = popupRender(childNode);
  }

  return /*#__PURE__*/external_React_namespaceObject.createElement(es, _extends({
    visible: visible,
    ref: elementRef,
    removeOnLeave: true
  }, popupMotion), function (_ref, motionRef) {
    var motionClassName = _ref.className,
        motionStyle = _ref.style;
    var mergedClassName = classnames_default()(prefixCls, popupClassName, motionClassName);
    return /*#__PURE__*/external_React_namespaceObject.createElement("div", {
      ref: motionRef,
      className: mergedClassName,
      onClick: onClick,
      style: _objectSpread2(_objectSpread2({}, motionStyle), mergedStyle)
    }, childNode);
  });
});
MobilePopupInner.displayName = 'MobilePopupInner';
/* harmony default export */ const Popup_MobilePopupInner = (MobilePopupInner);
;// CONCATENATED MODULE: ./node_modules/rc-trigger/es/Popup/index.js




var Popup_excluded = ["visible", "mobile"];






var Popup = /*#__PURE__*/external_React_namespaceObject.forwardRef(function (_ref, ref) {
  var visible = _ref.visible,
      mobile = _ref.mobile,
      props = _objectWithoutProperties(_ref, Popup_excluded);

  var _useState = (0,external_React_namespaceObject.useState)(visible),
      _useState2 = slicedToArray_slicedToArray(_useState, 2),
      innerVisible = _useState2[0],
      serInnerVisible = _useState2[1];

  var _useState3 = (0,external_React_namespaceObject.useState)(false),
      _useState4 = slicedToArray_slicedToArray(_useState3, 2),
      inMobile = _useState4[0],
      setInMobile = _useState4[1];

  var cloneProps = _objectSpread2(_objectSpread2({}, props), {}, {
    visible: innerVisible
  }); // We check mobile in visible changed here.
  // And this also delay set `innerVisible` to avoid popup component render flash


  (0,external_React_namespaceObject.useEffect)(function () {
    serInnerVisible(visible);

    if (visible && mobile) {
      setInMobile(isMobile());
    }
  }, [visible, mobile]);
  var popupNode = inMobile ? /*#__PURE__*/external_React_namespaceObject.createElement(Popup_MobilePopupInner, _extends({}, cloneProps, {
    mobile: mobile,
    ref: ref
  })) : /*#__PURE__*/external_React_namespaceObject.createElement(Popup_PopupInner, _extends({}, cloneProps, {
    ref: ref
  })); // We can use fragment directly but this may failed some selector usage. Keep as origin logic

  return /*#__PURE__*/external_React_namespaceObject.createElement("div", null, /*#__PURE__*/external_React_namespaceObject.createElement(Mask, cloneProps), popupNode);
});
Popup.displayName = 'Popup';
/* harmony default export */ const es_Popup = (Popup);
;// CONCATENATED MODULE: ./node_modules/rc-trigger/es/context.js

var TriggerContext = /*#__PURE__*/external_React_namespaceObject.createContext(null);
/* harmony default export */ const context = (TriggerContext);
;// CONCATENATED MODULE: ./node_modules/rc-trigger/es/index.js




















function es_noop() {}

function returnEmptyString() {
  return '';
}

function returnDocument(element) {
  if (element) {
    return element.ownerDocument;
  }

  return window.document;
}

var ALL_HANDLERS = ['onClick', 'onMouseDown', 'onTouchStart', 'onMouseEnter', 'onMouseLeave', 'onFocus', 'onBlur', 'onContextMenu'];
/**
 * Internal usage. Do not use in your code since this will be removed.
 */

function generateTrigger(PortalComponent) {
  var Trigger = /*#__PURE__*/function (_React$Component) {
    _inherits(Trigger, _React$Component);

    var _super = _createSuper(Trigger);

    // ensure `getContainer` will be called only once
    function Trigger(props) {
      var _this;

      _classCallCheck(this, Trigger);

      _this = _super.call(this, props);
      _this.popupRef = /*#__PURE__*/external_React_namespaceObject.createRef();
      _this.triggerRef = /*#__PURE__*/external_React_namespaceObject.createRef();
      _this.portalContainer = void 0;
      _this.attachId = void 0;
      _this.clickOutsideHandler = void 0;
      _this.touchOutsideHandler = void 0;
      _this.contextMenuOutsideHandler1 = void 0;
      _this.contextMenuOutsideHandler2 = void 0;
      _this.mouseDownTimeout = void 0;
      _this.focusTime = void 0;
      _this.preClickTime = void 0;
      _this.preTouchTime = void 0;
      _this.delayTimer = void 0;
      _this.hasPopupMouseDown = void 0;

      _this.onMouseEnter = function (e) {
        var mouseEnterDelay = _this.props.mouseEnterDelay;

        _this.fireEvents('onMouseEnter', e);

        _this.delaySetPopupVisible(true, mouseEnterDelay, mouseEnterDelay ? null : e);
      };

      _this.onMouseMove = function (e) {
        _this.fireEvents('onMouseMove', e);

        _this.setPoint(e);
      };

      _this.onMouseLeave = function (e) {
        _this.fireEvents('onMouseLeave', e);

        _this.delaySetPopupVisible(false, _this.props.mouseLeaveDelay);
      };

      _this.onPopupMouseEnter = function () {
        _this.clearDelayTimer();
      };

      _this.onPopupMouseLeave = function (e) {
        var _this$popupRef$curren;

        // https://github.com/react-component/trigger/pull/13
        // react bug?
        if (e.relatedTarget && !e.relatedTarget.setTimeout && contains((_this$popupRef$curren = _this.popupRef.current) === null || _this$popupRef$curren === void 0 ? void 0 : _this$popupRef$curren.getElement(), e.relatedTarget)) {
          return;
        }

        _this.delaySetPopupVisible(false, _this.props.mouseLeaveDelay);
      };

      _this.onFocus = function (e) {
        _this.fireEvents('onFocus', e); // incase focusin and focusout


        _this.clearDelayTimer();

        if (_this.isFocusToShow()) {
          _this.focusTime = Date.now();

          _this.delaySetPopupVisible(true, _this.props.focusDelay);
        }
      };

      _this.onMouseDown = function (e) {
        _this.fireEvents('onMouseDown', e);

        _this.preClickTime = Date.now();
      };

      _this.onTouchStart = function (e) {
        _this.fireEvents('onTouchStart', e);

        _this.preTouchTime = Date.now();
      };

      _this.onBlur = function (e) {
        _this.fireEvents('onBlur', e);

        _this.clearDelayTimer();

        if (_this.isBlurToHide()) {
          _this.delaySetPopupVisible(false, _this.props.blurDelay);
        }
      };

      _this.onContextMenu = function (e) {
        e.preventDefault();

        _this.fireEvents('onContextMenu', e);

        _this.setPopupVisible(true, e);
      };

      _this.onContextMenuClose = function () {
        if (_this.isContextMenuToShow()) {
          _this.close();
        }
      };

      _this.onClick = function (event) {
        _this.fireEvents('onClick', event); // focus will trigger click


        if (_this.focusTime) {
          var preTime;

          if (_this.preClickTime && _this.preTouchTime) {
            preTime = Math.min(_this.preClickTime, _this.preTouchTime);
          } else if (_this.preClickTime) {
            preTime = _this.preClickTime;
          } else if (_this.preTouchTime) {
            preTime = _this.preTouchTime;
          }

          if (Math.abs(preTime - _this.focusTime) < 20) {
            return;
          }

          _this.focusTime = 0;
        }

        _this.preClickTime = 0;
        _this.preTouchTime = 0; // Only prevent default when all the action is click.
        // https://github.com/ant-design/ant-design/issues/17043
        // https://github.com/ant-design/ant-design/issues/17291

        if (_this.isClickToShow() && (_this.isClickToHide() || _this.isBlurToHide()) && event && event.preventDefault) {
          event.preventDefault();
        }

        var nextVisible = !_this.state.popupVisible;

        if (_this.isClickToHide() && !nextVisible || nextVisible && _this.isClickToShow()) {
          _this.setPopupVisible(!_this.state.popupVisible, event);
        }
      };

      _this.onPopupMouseDown = function () {
        _this.hasPopupMouseDown = true;
        clearTimeout(_this.mouseDownTimeout);
        _this.mouseDownTimeout = window.setTimeout(function () {
          _this.hasPopupMouseDown = false;
        }, 0);

        if (_this.context) {
          var _this$context;

          (_this$context = _this.context).onPopupMouseDown.apply(_this$context, arguments);
        }
      };

      _this.onDocumentClick = function (event) {
        if (_this.props.mask && !_this.props.maskClosable) {
          return;
        }

        var target = event.target;

        var root = _this.getRootDomNode();

        var popupNode = _this.getPopupDomNode();

        if ( // mousedown on the target should also close popup when action is contextMenu.
        // https://github.com/ant-design/ant-design/issues/29853
        (!contains(root, target) || _this.isContextMenuOnly()) && !contains(popupNode, target) && !_this.hasPopupMouseDown) {
          _this.close();
        }
      };

      _this.getRootDomNode = function () {
        var getTriggerDOMNode = _this.props.getTriggerDOMNode;

        if (getTriggerDOMNode) {
          return getTriggerDOMNode(_this.triggerRef.current);
        }

        try {
          var domNode = findDOMNode(_this.triggerRef.current);

          if (domNode) {
            return domNode;
          }
        } catch (err) {// Do nothing
        }

        return external_ReactDOM_default().findDOMNode(_assertThisInitialized(_this));
      };

      _this.getPopupClassNameFromAlign = function (align) {
        var className = [];
        var _this$props = _this.props,
            popupPlacement = _this$props.popupPlacement,
            builtinPlacements = _this$props.builtinPlacements,
            prefixCls = _this$props.prefixCls,
            alignPoint = _this$props.alignPoint,
            getPopupClassNameFromAlign = _this$props.getPopupClassNameFromAlign;

        if (popupPlacement && builtinPlacements) {
          className.push(getAlignPopupClassName(builtinPlacements, prefixCls, align, alignPoint));
        }

        if (getPopupClassNameFromAlign) {
          className.push(getPopupClassNameFromAlign(align));
        }

        return className.join(' ');
      };

      _this.getComponent = function () {
        var _this$props2 = _this.props,
            prefixCls = _this$props2.prefixCls,
            destroyPopupOnHide = _this$props2.destroyPopupOnHide,
            popupClassName = _this$props2.popupClassName,
            onPopupAlign = _this$props2.onPopupAlign,
            popupMotion = _this$props2.popupMotion,
            popupAnimation = _this$props2.popupAnimation,
            popupTransitionName = _this$props2.popupTransitionName,
            popupStyle = _this$props2.popupStyle,
            mask = _this$props2.mask,
            maskAnimation = _this$props2.maskAnimation,
            maskTransitionName = _this$props2.maskTransitionName,
            maskMotion = _this$props2.maskMotion,
            zIndex = _this$props2.zIndex,
            popup = _this$props2.popup,
            stretch = _this$props2.stretch,
            alignPoint = _this$props2.alignPoint,
            mobile = _this$props2.mobile,
            forceRender = _this$props2.forceRender,
            onPopupClick = _this$props2.onPopupClick;
        var _this$state = _this.state,
            popupVisible = _this$state.popupVisible,
            point = _this$state.point;

        var align = _this.getPopupAlign();

        var mouseProps = {};

        if (_this.isMouseEnterToShow()) {
          mouseProps.onMouseEnter = _this.onPopupMouseEnter;
        }

        if (_this.isMouseLeaveToHide()) {
          mouseProps.onMouseLeave = _this.onPopupMouseLeave;
        }

        mouseProps.onMouseDown = _this.onPopupMouseDown;
        mouseProps.onTouchStart = _this.onPopupMouseDown;
        return /*#__PURE__*/external_React_namespaceObject.createElement(es_Popup, _extends({
          prefixCls: prefixCls,
          destroyPopupOnHide: destroyPopupOnHide,
          visible: popupVisible,
          point: alignPoint && point,
          className: popupClassName,
          align: align,
          onAlign: onPopupAlign,
          animation: popupAnimation,
          getClassNameFromAlign: _this.getPopupClassNameFromAlign
        }, mouseProps, {
          stretch: stretch,
          getRootDomNode: _this.getRootDomNode,
          style: popupStyle,
          mask: mask,
          zIndex: zIndex,
          transitionName: popupTransitionName,
          maskAnimation: maskAnimation,
          maskTransitionName: maskTransitionName,
          maskMotion: maskMotion,
          ref: _this.popupRef,
          motion: popupMotion,
          mobile: mobile,
          forceRender: forceRender,
          onClick: onPopupClick
        }), typeof popup === 'function' ? popup() : popup);
      };

      _this.attachParent = function (popupContainer) {
        wrapperRaf.cancel(_this.attachId);
        var _this$props3 = _this.props,
            getPopupContainer = _this$props3.getPopupContainer,
            getDocument = _this$props3.getDocument;

        var domNode = _this.getRootDomNode();

        var mountNode;

        if (!getPopupContainer) {
          mountNode = getDocument(_this.getRootDomNode()).body;
        } else if (domNode || getPopupContainer.length === 0) {
          // Compatible for legacy getPopupContainer with domNode argument.
          // If no need `domNode` argument, will call directly.
          // https://codesandbox.io/s/eloquent-mclean-ss93m?file=/src/App.js
          mountNode = getPopupContainer(domNode);
        }

        if (mountNode) {
          mountNode.appendChild(popupContainer);
        } else {
          // Retry after frame render in case parent not ready
          _this.attachId = wrapperRaf(function () {
            _this.attachParent(popupContainer);
          });
        }
      };

      _this.getContainer = function () {
        if (!_this.portalContainer) {
          // In React.StrictMode component will call render multiple time in first mount.
          // When you want to refactor with FC, useRef will also init multiple time and
          // point to different useRef instance which will create multiple element
          // (This multiple render will not trigger effect so you can not clean up this
          // in effect). But this is safe with class component since it always point to same class instance.
          var getDocument = _this.props.getDocument;
          var popupContainer = getDocument(_this.getRootDomNode()).createElement('div'); // Make sure default popup container will never cause scrollbar appearing
          // https://github.com/react-component/trigger/issues/41

          popupContainer.style.position = 'absolute';
          popupContainer.style.top = '0';
          popupContainer.style.left = '0';
          popupContainer.style.width = '100%';
          _this.portalContainer = popupContainer;
        }

        _this.attachParent(_this.portalContainer);

        return _this.portalContainer;
      };

      _this.setPoint = function (point) {
        var alignPoint = _this.props.alignPoint;
        if (!alignPoint || !point) return;

        _this.setState({
          point: {
            pageX: point.pageX,
            pageY: point.pageY
          }
        });
      };

      _this.handlePortalUpdate = function () {
        if (_this.state.prevPopupVisible !== _this.state.popupVisible) {
          _this.props.afterPopupVisibleChange(_this.state.popupVisible);
        }
      };

      _this.triggerContextValue = {
        onPopupMouseDown: _this.onPopupMouseDown
      };

      var _popupVisible;

      if ('popupVisible' in props) {
        _popupVisible = !!props.popupVisible;
      } else {
        _popupVisible = !!props.defaultPopupVisible;
      }

      _this.state = {
        prevPopupVisible: _popupVisible,
        popupVisible: _popupVisible
      };
      ALL_HANDLERS.forEach(function (h) {
        _this["fire".concat(h)] = function (e) {
          _this.fireEvents(h, e);
        };
      });
      return _this;
    }

    _createClass(Trigger, [{
      key: "componentDidMount",
      value: function componentDidMount() {
        this.componentDidUpdate();
      }
    }, {
      key: "componentDidUpdate",
      value: function componentDidUpdate() {
        var props = this.props;
        var state = this.state; // We must listen to `mousedown` or `touchstart`, edge case:
        // https://github.com/ant-design/ant-design/issues/5804
        // https://github.com/react-component/calendar/issues/250
        // https://github.com/react-component/trigger/issues/50

        if (state.popupVisible) {
          var currentDocument;

          if (!this.clickOutsideHandler && (this.isClickToHide() || this.isContextMenuToShow())) {
            currentDocument = props.getDocument(this.getRootDomNode());
            this.clickOutsideHandler = addEventListenerWrap(currentDocument, 'mousedown', this.onDocumentClick);
          } // always hide on mobile


          if (!this.touchOutsideHandler) {
            currentDocument = currentDocument || props.getDocument(this.getRootDomNode());
            this.touchOutsideHandler = addEventListenerWrap(currentDocument, 'touchstart', this.onDocumentClick);
          } // close popup when trigger type contains 'onContextMenu' and document is scrolling.


          if (!this.contextMenuOutsideHandler1 && this.isContextMenuToShow()) {
            currentDocument = currentDocument || props.getDocument(this.getRootDomNode());
            this.contextMenuOutsideHandler1 = addEventListenerWrap(currentDocument, 'scroll', this.onContextMenuClose);
          } // close popup when trigger type contains 'onContextMenu' and window is blur.


          if (!this.contextMenuOutsideHandler2 && this.isContextMenuToShow()) {
            this.contextMenuOutsideHandler2 = addEventListenerWrap(window, 'blur', this.onContextMenuClose);
          }

          return;
        }

        this.clearOutsideHandler();
      }
    }, {
      key: "componentWillUnmount",
      value: function componentWillUnmount() {
        this.clearDelayTimer();
        this.clearOutsideHandler();
        clearTimeout(this.mouseDownTimeout);
        wrapperRaf.cancel(this.attachId);
      }
    }, {
      key: "getPopupDomNode",
      value: function getPopupDomNode() {
        var _this$popupRef$curren2;

        // for test
        return ((_this$popupRef$curren2 = this.popupRef.current) === null || _this$popupRef$curren2 === void 0 ? void 0 : _this$popupRef$curren2.getElement()) || null;
      }
    }, {
      key: "getPopupAlign",
      value: function getPopupAlign() {
        var props = this.props;
        var popupPlacement = props.popupPlacement,
            popupAlign = props.popupAlign,
            builtinPlacements = props.builtinPlacements;

        if (popupPlacement && builtinPlacements) {
          return getAlignFromPlacement(builtinPlacements, popupPlacement, popupAlign);
        }

        return popupAlign;
      }
    }, {
      key: "setPopupVisible",
      value:
      /**
       * @param popupVisible    Show or not the popup element
       * @param event           SyntheticEvent, used for `pointAlign`
       */
      function setPopupVisible(popupVisible, event) {
        var alignPoint = this.props.alignPoint;
        var prevPopupVisible = this.state.popupVisible;
        this.clearDelayTimer();

        if (prevPopupVisible !== popupVisible) {
          if (!('popupVisible' in this.props)) {
            this.setState({
              popupVisible: popupVisible,
              prevPopupVisible: prevPopupVisible
            });
          }

          this.props.onPopupVisibleChange(popupVisible);
        } // Always record the point position since mouseEnterDelay will delay the show


        if (alignPoint && event && popupVisible) {
          this.setPoint(event);
        }
      }
    }, {
      key: "delaySetPopupVisible",
      value: function delaySetPopupVisible(visible, delayS, event) {
        var _this2 = this;

        var delay = delayS * 1000;
        this.clearDelayTimer();

        if (delay) {
          var point = event ? {
            pageX: event.pageX,
            pageY: event.pageY
          } : null;
          this.delayTimer = window.setTimeout(function () {
            _this2.setPopupVisible(visible, point);

            _this2.clearDelayTimer();
          }, delay);
        } else {
          this.setPopupVisible(visible, event);
        }
      }
    }, {
      key: "clearDelayTimer",
      value: function clearDelayTimer() {
        if (this.delayTimer) {
          clearTimeout(this.delayTimer);
          this.delayTimer = null;
        }
      }
    }, {
      key: "clearOutsideHandler",
      value: function clearOutsideHandler() {
        if (this.clickOutsideHandler) {
          this.clickOutsideHandler.remove();
          this.clickOutsideHandler = null;
        }

        if (this.contextMenuOutsideHandler1) {
          this.contextMenuOutsideHandler1.remove();
          this.contextMenuOutsideHandler1 = null;
        }

        if (this.contextMenuOutsideHandler2) {
          this.contextMenuOutsideHandler2.remove();
          this.contextMenuOutsideHandler2 = null;
        }

        if (this.touchOutsideHandler) {
          this.touchOutsideHandler.remove();
          this.touchOutsideHandler = null;
        }
      }
    }, {
      key: "createTwoChains",
      value: function createTwoChains(event) {
        var childPros = this.props.children.props;
        var props = this.props;

        if (childPros[event] && props[event]) {
          return this["fire".concat(event)];
        }

        return childPros[event] || props[event];
      }
    }, {
      key: "isClickToShow",
      value: function isClickToShow() {
        var _this$props4 = this.props,
            action = _this$props4.action,
            showAction = _this$props4.showAction;
        return action.indexOf('click') !== -1 || showAction.indexOf('click') !== -1;
      }
    }, {
      key: "isContextMenuOnly",
      value: function isContextMenuOnly() {
        var action = this.props.action;
        return action === 'contextMenu' || action.length === 1 && action[0] === 'contextMenu';
      }
    }, {
      key: "isContextMenuToShow",
      value: function isContextMenuToShow() {
        var _this$props5 = this.props,
            action = _this$props5.action,
            showAction = _this$props5.showAction;
        return action.indexOf('contextMenu') !== -1 || showAction.indexOf('contextMenu') !== -1;
      }
    }, {
      key: "isClickToHide",
      value: function isClickToHide() {
        var _this$props6 = this.props,
            action = _this$props6.action,
            hideAction = _this$props6.hideAction;
        return action.indexOf('click') !== -1 || hideAction.indexOf('click') !== -1;
      }
    }, {
      key: "isMouseEnterToShow",
      value: function isMouseEnterToShow() {
        var _this$props7 = this.props,
            action = _this$props7.action,
            showAction = _this$props7.showAction;
        return action.indexOf('hover') !== -1 || showAction.indexOf('mouseEnter') !== -1;
      }
    }, {
      key: "isMouseLeaveToHide",
      value: function isMouseLeaveToHide() {
        var _this$props8 = this.props,
            action = _this$props8.action,
            hideAction = _this$props8.hideAction;
        return action.indexOf('hover') !== -1 || hideAction.indexOf('mouseLeave') !== -1;
      }
    }, {
      key: "isFocusToShow",
      value: function isFocusToShow() {
        var _this$props9 = this.props,
            action = _this$props9.action,
            showAction = _this$props9.showAction;
        return action.indexOf('focus') !== -1 || showAction.indexOf('focus') !== -1;
      }
    }, {
      key: "isBlurToHide",
      value: function isBlurToHide() {
        var _this$props10 = this.props,
            action = _this$props10.action,
            hideAction = _this$props10.hideAction;
        return action.indexOf('focus') !== -1 || hideAction.indexOf('blur') !== -1;
      }
    }, {
      key: "forcePopupAlign",
      value: function forcePopupAlign() {
        if (this.state.popupVisible) {
          var _this$popupRef$curren3;

          (_this$popupRef$curren3 = this.popupRef.current) === null || _this$popupRef$curren3 === void 0 ? void 0 : _this$popupRef$curren3.forceAlign();
        }
      }
    }, {
      key: "fireEvents",
      value: function fireEvents(type, e) {
        var childCallback = this.props.children.props[type];

        if (childCallback) {
          childCallback(e);
        }

        var callback = this.props[type];

        if (callback) {
          callback(e);
        }
      }
    }, {
      key: "close",
      value: function close() {
        this.setPopupVisible(false);
      }
    }, {
      key: "render",
      value: function render() {
        var popupVisible = this.state.popupVisible;
        var _this$props11 = this.props,
            children = _this$props11.children,
            forceRender = _this$props11.forceRender,
            alignPoint = _this$props11.alignPoint,
            className = _this$props11.className,
            autoDestroy = _this$props11.autoDestroy;
        var child = external_React_namespaceObject.Children.only(children);
        var newChildProps = {
          key: 'trigger'
        }; // ============================== Visible Handlers ==============================
        // >>> ContextMenu

        if (this.isContextMenuToShow()) {
          newChildProps.onContextMenu = this.onContextMenu;
        } else {
          newChildProps.onContextMenu = this.createTwoChains('onContextMenu');
        } // >>> Click


        if (this.isClickToHide() || this.isClickToShow()) {
          newChildProps.onClick = this.onClick;
          newChildProps.onMouseDown = this.onMouseDown;
          newChildProps.onTouchStart = this.onTouchStart;
        } else {
          newChildProps.onClick = this.createTwoChains('onClick');
          newChildProps.onMouseDown = this.createTwoChains('onMouseDown');
          newChildProps.onTouchStart = this.createTwoChains('onTouchStart');
        } // >>> Hover(enter)


        if (this.isMouseEnterToShow()) {
          newChildProps.onMouseEnter = this.onMouseEnter; // Point align

          if (alignPoint) {
            newChildProps.onMouseMove = this.onMouseMove;
          }
        } else {
          newChildProps.onMouseEnter = this.createTwoChains('onMouseEnter');
        } // >>> Hover(leave)


        if (this.isMouseLeaveToHide()) {
          newChildProps.onMouseLeave = this.onMouseLeave;
        } else {
          newChildProps.onMouseLeave = this.createTwoChains('onMouseLeave');
        } // >>> Focus


        if (this.isFocusToShow() || this.isBlurToHide()) {
          newChildProps.onFocus = this.onFocus;
          newChildProps.onBlur = this.onBlur;
        } else {
          newChildProps.onFocus = this.createTwoChains('onFocus');
          newChildProps.onBlur = this.createTwoChains('onBlur');
        } // =================================== Render ===================================


        var childrenClassName = classnames_default()(child && child.props && child.props.className, className);

        if (childrenClassName) {
          newChildProps.className = childrenClassName;
        }

        var cloneProps = _objectSpread2({}, newChildProps);

        if (supportRef(child)) {
          cloneProps.ref = composeRef(this.triggerRef, child.ref);
        }

        var trigger = /*#__PURE__*/external_React_namespaceObject.cloneElement(child, cloneProps);
        var portal; // prevent unmounting after it's rendered

        if (popupVisible || this.popupRef.current || forceRender) {
          portal = /*#__PURE__*/external_React_namespaceObject.createElement(PortalComponent, {
            key: "portal",
            getContainer: this.getContainer,
            didUpdate: this.handlePortalUpdate
          }, this.getComponent());
        }

        if (!popupVisible && autoDestroy) {
          portal = null;
        }

        return /*#__PURE__*/external_React_namespaceObject.createElement(context.Provider, {
          value: this.triggerContextValue
        }, trigger, portal);
      }
    }], [{
      key: "getDerivedStateFromProps",
      value: function getDerivedStateFromProps(_ref, prevState) {
        var popupVisible = _ref.popupVisible;
        var newState = {};

        if (popupVisible !== undefined && prevState.popupVisible !== popupVisible) {
          newState.popupVisible = popupVisible;
          newState.prevPopupVisible = prevState.popupVisible;
        }

        return newState;
      }
    }]);

    return Trigger;
  }(external_React_namespaceObject.Component);

  Trigger.contextType = context;
  Trigger.defaultProps = {
    prefixCls: 'rc-trigger-popup',
    getPopupClassNameFromAlign: returnEmptyString,
    getDocument: returnDocument,
    onPopupVisibleChange: es_noop,
    afterPopupVisibleChange: es_noop,
    onPopupAlign: es_noop,
    popupClassName: '',
    mouseEnterDelay: 0,
    mouseLeaveDelay: 0.1,
    focusDelay: 0,
    blurDelay: 0.15,
    popupStyle: {},
    destroyPopupOnHide: false,
    popupAlign: {},
    defaultPopupVisible: false,
    mask: false,
    maskClosable: true,
    action: [],
    showAction: [],
    hideAction: [],
    autoDestroy: false
  };
  return Trigger;
}
/* harmony default export */ const rc_trigger_es = (generateTrigger(es_Portal));
;// CONCATENATED MODULE: ./node_modules/rc-select/es/SelectTrigger.js




var SelectTrigger_excluded = ["prefixCls", "disabled", "visible", "children", "popupElement", "containerWidth", "animation", "transitionName", "dropdownStyle", "dropdownClassName", "direction", "placement", "dropdownMatchSelectWidth", "dropdownRender", "dropdownAlign", "getPopupContainer", "empty", "getTriggerDOMNode", "onPopupVisibleChange", "onPopupMouseEnter"];




var getBuiltInPlacements = function getBuiltInPlacements(dropdownMatchSelectWidth) {
  // Enable horizontal overflow auto-adjustment when a custom dropdown width is provided
  var adjustX = dropdownMatchSelectWidth === true ? 0 : 1;
  return {
    bottomLeft: {
      points: ['tl', 'bl'],
      offset: [0, 4],
      overflow: {
        adjustX: adjustX,
        adjustY: 1
      }
    },
    bottomRight: {
      points: ['tr', 'br'],
      offset: [0, 4],
      overflow: {
        adjustX: adjustX,
        adjustY: 1
      }
    },
    topLeft: {
      points: ['bl', 'tl'],
      offset: [0, -4],
      overflow: {
        adjustX: adjustX,
        adjustY: 1
      }
    },
    topRight: {
      points: ['br', 'tr'],
      offset: [0, -4],
      overflow: {
        adjustX: adjustX,
        adjustY: 1
      }
    }
  };
};

var SelectTrigger = function SelectTrigger(props, ref) {
  var prefixCls = props.prefixCls,
      disabled = props.disabled,
      visible = props.visible,
      children = props.children,
      popupElement = props.popupElement,
      containerWidth = props.containerWidth,
      animation = props.animation,
      transitionName = props.transitionName,
      dropdownStyle = props.dropdownStyle,
      dropdownClassName = props.dropdownClassName,
      _props$direction = props.direction,
      direction = _props$direction === void 0 ? 'ltr' : _props$direction,
      placement = props.placement,
      dropdownMatchSelectWidth = props.dropdownMatchSelectWidth,
      dropdownRender = props.dropdownRender,
      dropdownAlign = props.dropdownAlign,
      getPopupContainer = props.getPopupContainer,
      empty = props.empty,
      getTriggerDOMNode = props.getTriggerDOMNode,
      onPopupVisibleChange = props.onPopupVisibleChange,
      onPopupMouseEnter = props.onPopupMouseEnter,
      restProps = _objectWithoutProperties(props, SelectTrigger_excluded);

  var dropdownPrefixCls = "".concat(prefixCls, "-dropdown");
  var popupNode = popupElement;

  if (dropdownRender) {
    popupNode = dropdownRender(popupElement);
  }

  var builtInPlacements = external_React_namespaceObject.useMemo(function () {
    return getBuiltInPlacements(dropdownMatchSelectWidth);
  }, [dropdownMatchSelectWidth]); // ===================== Motion ======================

  var mergedTransitionName = animation ? "".concat(dropdownPrefixCls, "-").concat(animation) : transitionName; // ======================= Ref =======================

  var popupRef = external_React_namespaceObject.useRef(null);
  external_React_namespaceObject.useImperativeHandle(ref, function () {
    return {
      getPopupElement: function getPopupElement() {
        return popupRef.current;
      }
    };
  });

  var popupStyle = _objectSpread2({
    minWidth: containerWidth
  }, dropdownStyle);

  if (typeof dropdownMatchSelectWidth === 'number') {
    popupStyle.width = dropdownMatchSelectWidth;
  } else if (dropdownMatchSelectWidth) {
    popupStyle.width = containerWidth;
  }

  return /*#__PURE__*/external_React_namespaceObject.createElement(rc_trigger_es, _extends({}, restProps, {
    showAction: onPopupVisibleChange ? ['click'] : [],
    hideAction: onPopupVisibleChange ? ['click'] : [],
    popupPlacement: placement || (direction === 'rtl' ? 'bottomRight' : 'bottomLeft'),
    builtinPlacements: builtInPlacements,
    prefixCls: dropdownPrefixCls,
    popupTransitionName: mergedTransitionName,
    popup: /*#__PURE__*/external_React_namespaceObject.createElement("div", {
      ref: popupRef,
      onMouseEnter: onPopupMouseEnter
    }, popupNode),
    popupAlign: dropdownAlign,
    popupVisible: visible,
    getPopupContainer: getPopupContainer,
    popupClassName: classnames_default()(dropdownClassName, _defineProperty({}, "".concat(dropdownPrefixCls, "-empty"), empty)),
    popupStyle: popupStyle,
    getTriggerDOMNode: getTriggerDOMNode,
    onPopupVisibleChange: onPopupVisibleChange
  }), children);
};

var RefSelectTrigger = /*#__PURE__*/external_React_namespaceObject.forwardRef(SelectTrigger);
RefSelectTrigger.displayName = 'SelectTrigger';
/* harmony default export */ const es_SelectTrigger = (RefSelectTrigger);
;// CONCATENATED MODULE: ./node_modules/rc-util/es/pickAttrs.js

var attributes = "accept acceptCharset accessKey action allowFullScreen allowTransparency\n    alt async autoComplete autoFocus autoPlay capture cellPadding cellSpacing challenge\n    charSet checked classID className colSpan cols content contentEditable contextMenu\n    controls coords crossOrigin data dateTime default defer dir disabled download draggable\n    encType form formAction formEncType formMethod formNoValidate formTarget frameBorder\n    headers height hidden high href hrefLang htmlFor httpEquiv icon id inputMode integrity\n    is keyParams keyType kind label lang list loop low manifest marginHeight marginWidth max maxLength media\n    mediaGroup method min minLength multiple muted name noValidate nonce open\n    optimum pattern placeholder poster preload radioGroup readOnly rel required\n    reversed role rowSpan rows sandbox scope scoped scrolling seamless selected\n    shape size sizes span spellCheck src srcDoc srcLang srcSet start step style\n    summary tabIndex target title type useMap value width wmode wrap";
var eventsName = "onCopy onCut onPaste onCompositionEnd onCompositionStart onCompositionUpdate onKeyDown\n    onKeyPress onKeyUp onFocus onBlur onChange onInput onSubmit onClick onContextMenu onDoubleClick\n    onDrag onDragEnd onDragEnter onDragExit onDragLeave onDragOver onDragStart onDrop onMouseDown\n    onMouseEnter onMouseLeave onMouseMove onMouseOut onMouseOver onMouseUp onSelect onTouchCancel\n    onTouchEnd onTouchMove onTouchStart onScroll onWheel onAbort onCanPlay onCanPlayThrough\n    onDurationChange onEmptied onEncrypted onEnded onError onLoadedData onLoadedMetadata\n    onLoadStart onPause onPlay onPlaying onProgress onRateChange onSeeked onSeeking onStalled onSuspend onTimeUpdate onVolumeChange onWaiting onLoad onError";
var propList = "".concat(attributes, " ").concat(eventsName).split(/[\s\n]+/);
/* eslint-enable max-len */

var ariaPrefix = 'aria-';
var dataPrefix = 'data-';

function match(key, prefix) {
  return key.indexOf(prefix) === 0;
}
/**
 * Picker props from exist props with filter
 * @param props Passed props
 * @param ariaOnly boolean | { aria?: boolean; data?: boolean; attr?: boolean; } filter config
 */


function pickAttrs(props) {
  var ariaOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  var mergedConfig;

  if (ariaOnly === false) {
    mergedConfig = {
      aria: true,
      data: true,
      attr: true
    };
  } else if (ariaOnly === true) {
    mergedConfig = {
      aria: true
    };
  } else {
    mergedConfig = _objectSpread2({}, ariaOnly);
  }

  var attrs = {};
  Object.keys(props).forEach(function (key) {
    if ( // Aria
    mergedConfig.aria && (key === 'role' || match(key, ariaPrefix)) || // Data
    mergedConfig.data && match(key, dataPrefix) || // Attr
    mergedConfig.attr && propList.includes(key)) {
      attrs[key] = props[key];
    }
  });
  return attrs;
}
;// CONCATENATED MODULE: ./node_modules/rc-util/es/Children/toArray.js


function toArray_toArray(children) {
  var option = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  var ret = [];
  external_React_default().Children.forEach(children, function (child) {
    if ((child === undefined || child === null) && !option.keepEmpty) {
      return;
    }

    if (Array.isArray(child)) {
      ret = ret.concat(toArray_toArray(child));
    } else if ((0,react_is.isFragment)(child) && child.props) {
      ret = ret.concat(toArray_toArray(child.props.children, option));
    } else {
      ret.push(child);
    }
  });
  return ret;
}
;// CONCATENATED MODULE: ./node_modules/rc-resize-observer/es/utils/observerUtil.js
 // =============================== Const ===============================

var elementListeners = new Map();

function onResize(entities) {
  entities.forEach(function (entity) {
    var _elementListeners$get;

    var target = entity.target;
    (_elementListeners$get = elementListeners.get(target)) === null || _elementListeners$get === void 0 ? void 0 : _elementListeners$get.forEach(function (listener) {
      return listener(target);
    });
  });
} // Note: ResizeObserver polyfill not support option to measure border-box resize


var resizeObserver = new ResizeObserver_es(onResize); // Dev env only

var _el = (/* unused pure expression or super */ null && ( false ? 0 : null)); // eslint-disable-line

var _rs = (/* unused pure expression or super */ null && ( false ? 0 : null)); // eslint-disable-line
// ============================== Observe ==============================

function observe(element, callback) {
  if (!elementListeners.has(element)) {
    elementListeners.set(element, new Set());
    resizeObserver.observe(element);
  }

  elementListeners.get(element).add(callback);
}
function unobserve(element, callback) {
  if (elementListeners.has(element)) {
    elementListeners.get(element).delete(callback);

    if (!elementListeners.get(element).size) {
      resizeObserver.unobserve(element);
      elementListeners.delete(element);
    }
  }
}
;// CONCATENATED MODULE: ./node_modules/rc-resize-observer/es/SingleObserver/DomWrapper.js





/**
 * Fallback to findDOMNode if origin ref do not provide any dom element
 */

var DomWrapper_DomWrapper = /*#__PURE__*/function (_React$Component) {
  _inherits(DomWrapper, _React$Component);

  var _super = _createSuper(DomWrapper);

  function DomWrapper() {
    _classCallCheck(this, DomWrapper);

    return _super.apply(this, arguments);
  }

  _createClass(DomWrapper, [{
    key: "render",
    value: function render() {
      return this.props.children;
    }
  }]);

  return DomWrapper;
}(external_React_namespaceObject.Component);


;// CONCATENATED MODULE: ./node_modules/rc-resize-observer/es/Collection.js

var CollectionContext = /*#__PURE__*/external_React_namespaceObject.createContext(null);
/**
 * Collect all the resize event from children ResizeObserver
 */

function Collection(_ref) {
  var children = _ref.children,
      onBatchResize = _ref.onBatchResize;
  var resizeIdRef = external_React_namespaceObject.useRef(0);
  var resizeInfosRef = external_React_namespaceObject.useRef([]);
  var onCollectionResize = external_React_namespaceObject.useContext(CollectionContext);
  var onResize = external_React_namespaceObject.useCallback(function (size, element, data) {
    resizeIdRef.current += 1;
    var currentId = resizeIdRef.current;
    resizeInfosRef.current.push({
      size: size,
      element: element,
      data: data
    });
    Promise.resolve().then(function () {
      if (currentId === resizeIdRef.current) {
        onBatchResize === null || onBatchResize === void 0 ? void 0 : onBatchResize(resizeInfosRef.current);
        resizeInfosRef.current = [];
      }
    }); // Continue bubbling if parent exist

    onCollectionResize === null || onCollectionResize === void 0 ? void 0 : onCollectionResize(size, element, data);
  }, [onBatchResize, onCollectionResize]);
  return /*#__PURE__*/external_React_namespaceObject.createElement(CollectionContext.Provider, {
    value: onResize
  }, children);
}
;// CONCATENATED MODULE: ./node_modules/rc-resize-observer/es/SingleObserver/index.js







function SingleObserver(props) {
  var children = props.children,
      disabled = props.disabled;
  var elementRef = external_React_namespaceObject.useRef(null);
  var wrapperRef = external_React_namespaceObject.useRef(null);
  var onCollectionResize = external_React_namespaceObject.useContext(CollectionContext); // =========================== Children ===========================

  var isRenderProps = typeof children === 'function';
  var mergedChildren = isRenderProps ? children(elementRef) : children; // ============================= Size =============================

  var sizeRef = external_React_namespaceObject.useRef({
    width: -1,
    height: -1,
    offsetWidth: -1,
    offsetHeight: -1
  }); // ============================= Ref ==============================

  var canRef = !isRenderProps && /*#__PURE__*/external_React_namespaceObject.isValidElement(mergedChildren) && supportRef(mergedChildren);
  var originRef = canRef ? mergedChildren.ref : null;
  var mergedRef = external_React_namespaceObject.useMemo(function () {
    return composeRef(originRef, elementRef);
  }, [originRef, elementRef]); // =========================== Observe ============================

  var propsRef = external_React_namespaceObject.useRef(props);
  propsRef.current = props; // Handler

  var onInternalResize = external_React_namespaceObject.useCallback(function (target) {
    var _propsRef$current = propsRef.current,
        onResize = _propsRef$current.onResize,
        data = _propsRef$current.data;

    var _target$getBoundingCl = target.getBoundingClientRect(),
        width = _target$getBoundingCl.width,
        height = _target$getBoundingCl.height;

    var offsetWidth = target.offsetWidth,
        offsetHeight = target.offsetHeight;
    /**
     * Resize observer trigger when content size changed.
     * In most case we just care about element size,
     * let's use `boundary` instead of `contentRect` here to avoid shaking.
     */

    var fixedWidth = Math.floor(width);
    var fixedHeight = Math.floor(height);

    if (sizeRef.current.width !== fixedWidth || sizeRef.current.height !== fixedHeight || sizeRef.current.offsetWidth !== offsetWidth || sizeRef.current.offsetHeight !== offsetHeight) {
      var size = {
        width: fixedWidth,
        height: fixedHeight,
        offsetWidth: offsetWidth,
        offsetHeight: offsetHeight
      };
      sizeRef.current = size; // IE is strange, right?

      var mergedOffsetWidth = offsetWidth === Math.round(width) ? width : offsetWidth;
      var mergedOffsetHeight = offsetHeight === Math.round(height) ? height : offsetHeight;

      var sizeInfo = _objectSpread2(_objectSpread2({}, size), {}, {
        offsetWidth: mergedOffsetWidth,
        offsetHeight: mergedOffsetHeight
      }); // Let collection know what happened


      onCollectionResize === null || onCollectionResize === void 0 ? void 0 : onCollectionResize(sizeInfo, target, data);

      if (onResize) {
        // defer the callback but not defer to next frame
        Promise.resolve().then(function () {
          onResize(sizeInfo, target);
        });
      }
    }
  }, []); // Dynamic observe

  external_React_namespaceObject.useEffect(function () {
    var currentElement = findDOMNode(elementRef.current) || findDOMNode(wrapperRef.current);

    if (currentElement && !disabled) {
      observe(currentElement, onInternalResize);
    }

    return function () {
      return unobserve(currentElement, onInternalResize);
    };
  }, [elementRef.current, disabled]); // ============================ Render ============================

  return /*#__PURE__*/external_React_namespaceObject.createElement(DomWrapper_DomWrapper, {
    ref: wrapperRef
  }, canRef ? /*#__PURE__*/external_React_namespaceObject.cloneElement(mergedChildren, {
    ref: mergedRef
  }) : mergedChildren);
}
;// CONCATENATED MODULE: ./node_modules/rc-resize-observer/es/index.js






var INTERNAL_PREFIX_KEY = 'rc-observer-key';

function es_ResizeObserver(props) {
  var children = props.children;
  var childNodes = typeof children === 'function' ? [children] : toArray_toArray(children);

  if (false) {}

  return childNodes.map(function (child, index) {
    var key = (child === null || child === void 0 ? void 0 : child.key) || "".concat(INTERNAL_PREFIX_KEY, "-").concat(index);
    return /*#__PURE__*/external_React_namespaceObject.createElement(SingleObserver, _extends({}, props, {
      key: key
    }), child);
  });
}

es_ResizeObserver.Collection = Collection;
/* harmony default export */ const rc_resize_observer_es = (es_ResizeObserver);
;// CONCATENATED MODULE: ./node_modules/rc-overflow/es/Item.js



var Item_excluded = ["prefixCls", "invalidate", "item", "renderItem", "responsive", "responsiveDisabled", "registerSize", "itemKey", "className", "style", "children", "display", "order", "component"];


 // Use shared variable to save bundle size

var UNDEFINED = undefined;

function InternalItem(props, ref) {
  var prefixCls = props.prefixCls,
      invalidate = props.invalidate,
      item = props.item,
      renderItem = props.renderItem,
      responsive = props.responsive,
      responsiveDisabled = props.responsiveDisabled,
      registerSize = props.registerSize,
      itemKey = props.itemKey,
      className = props.className,
      style = props.style,
      children = props.children,
      display = props.display,
      order = props.order,
      _props$component = props.component,
      Component = _props$component === void 0 ? 'div' : _props$component,
      restProps = _objectWithoutProperties(props, Item_excluded);

  var mergedHidden = responsive && !display; // ================================ Effect ================================

  function internalRegisterSize(width) {
    registerSize(itemKey, width);
  }

  external_React_namespaceObject.useEffect(function () {
    return function () {
      internalRegisterSize(null);
    };
  }, []); // ================================ Render ================================

  var childNode = renderItem && item !== UNDEFINED ? renderItem(item) : children;
  var overflowStyle;

  if (!invalidate) {
    overflowStyle = {
      opacity: mergedHidden ? 0 : 1,
      height: mergedHidden ? 0 : UNDEFINED,
      overflowY: mergedHidden ? 'hidden' : UNDEFINED,
      order: responsive ? order : UNDEFINED,
      pointerEvents: mergedHidden ? 'none' : UNDEFINED,
      position: mergedHidden ? 'absolute' : UNDEFINED
    };
  }

  var overflowProps = {};

  if (mergedHidden) {
    overflowProps['aria-hidden'] = true;
  }

  var itemNode = /*#__PURE__*/external_React_namespaceObject.createElement(Component, _extends({
    className: classnames_default()(!invalidate && prefixCls, className),
    style: _objectSpread2(_objectSpread2({}, overflowStyle), style)
  }, overflowProps, restProps, {
    ref: ref
  }), childNode);

  if (responsive) {
    itemNode = /*#__PURE__*/external_React_namespaceObject.createElement(rc_resize_observer_es, {
      onResize: function onResize(_ref) {
        var offsetWidth = _ref.offsetWidth;
        internalRegisterSize(offsetWidth);
      },
      disabled: responsiveDisabled
    }, itemNode);
  }

  return itemNode;
}

var Item = /*#__PURE__*/external_React_namespaceObject.forwardRef(InternalItem);
Item.displayName = 'Item';
/* harmony default export */ const es_Item = (Item);
;// CONCATENATED MODULE: ./node_modules/rc-overflow/es/hooks/useBatchFrameState.js




/**
 * State generate. Return a `setState` but it will flush all state with one render to save perf.
 * This is not a realization of `unstable_batchedUpdates`.
 */

function useBatchFrameState() {
  var _useState = useSafeState({}),
      _useState2 = slicedToArray_slicedToArray(_useState, 2),
      forceUpdate = _useState2[1];

  var statesRef = (0,external_React_namespaceObject.useRef)([]);
  var walkingIndex = 0;
  var beforeFrameId = 0;

  function createState(defaultValue) {
    var myIndex = walkingIndex;
    walkingIndex += 1; // Fill value if not exist yet

    if (statesRef.current.length < myIndex + 1) {
      statesRef.current[myIndex] = defaultValue;
    } // Return filled as `setState`


    var value = statesRef.current[myIndex];

    function setValue(val) {
      statesRef.current[myIndex] = typeof val === 'function' ? val(statesRef.current[myIndex]) : val;
      wrapperRaf.cancel(beforeFrameId); // Flush with batch

      beforeFrameId = wrapperRaf(function () {
        forceUpdate({}, true);
      });
    }

    return [value, setValue];
  }

  return createState;
}
;// CONCATENATED MODULE: ./node_modules/rc-overflow/es/RawItem.js


var RawItem_excluded = ["component"],
    RawItem_excluded2 = ["className"],
    _excluded3 = ["className"];





var InternalRawItem = function InternalRawItem(props, ref) {
  var context = external_React_namespaceObject.useContext(OverflowContext); // Render directly when context not provided

  if (!context) {
    var _props$component = props.component,
        Component = _props$component === void 0 ? 'div' : _props$component,
        _restProps = _objectWithoutProperties(props, RawItem_excluded);

    return /*#__PURE__*/external_React_namespaceObject.createElement(Component, _extends({}, _restProps, {
      ref: ref
    }));
  }

  var contextClassName = context.className,
      restContext = _objectWithoutProperties(context, RawItem_excluded2);

  var className = props.className,
      restProps = _objectWithoutProperties(props, _excluded3); // Do not pass context to sub item to avoid multiple measure


  return /*#__PURE__*/external_React_namespaceObject.createElement(OverflowContext.Provider, {
    value: null
  }, /*#__PURE__*/external_React_namespaceObject.createElement(es_Item, _extends({
    ref: ref,
    className: classnames_default()(contextClassName, className)
  }, restContext, restProps)));
};

var RawItem = /*#__PURE__*/external_React_namespaceObject.forwardRef(InternalRawItem);
RawItem.displayName = 'RawItem';
/* harmony default export */ const es_RawItem = (RawItem);
;// CONCATENATED MODULE: ./node_modules/rc-overflow/es/Overflow.js




var Overflow_excluded = ["prefixCls", "data", "renderItem", "renderRawItem", "itemKey", "itemWidth", "ssr", "style", "className", "maxCount", "renderRest", "renderRawRest", "suffix", "component", "itemComponent", "onVisibleChange"];








var OverflowContext = /*#__PURE__*/external_React_namespaceObject.createContext(null);
var RESPONSIVE = 'responsive';
var INVALIDATE = 'invalidate';

function defaultRenderRest(omittedItems) {
  return "+ ".concat(omittedItems.length, " ...");
}

function Overflow(props, ref) {
  var _props$prefixCls = props.prefixCls,
      prefixCls = _props$prefixCls === void 0 ? 'rc-overflow' : _props$prefixCls,
      _props$data = props.data,
      data = _props$data === void 0 ? [] : _props$data,
      renderItem = props.renderItem,
      renderRawItem = props.renderRawItem,
      itemKey = props.itemKey,
      _props$itemWidth = props.itemWidth,
      itemWidth = _props$itemWidth === void 0 ? 10 : _props$itemWidth,
      ssr = props.ssr,
      style = props.style,
      className = props.className,
      maxCount = props.maxCount,
      renderRest = props.renderRest,
      renderRawRest = props.renderRawRest,
      suffix = props.suffix,
      _props$component = props.component,
      Component = _props$component === void 0 ? 'div' : _props$component,
      itemComponent = props.itemComponent,
      onVisibleChange = props.onVisibleChange,
      restProps = _objectWithoutProperties(props, Overflow_excluded);

  var createUseState = useBatchFrameState();
  var fullySSR = ssr === 'full';

  var _createUseState = createUseState(null),
      _createUseState2 = slicedToArray_slicedToArray(_createUseState, 2),
      containerWidth = _createUseState2[0],
      setContainerWidth = _createUseState2[1];

  var mergedContainerWidth = containerWidth || 0;

  var _createUseState3 = createUseState(new Map()),
      _createUseState4 = slicedToArray_slicedToArray(_createUseState3, 2),
      itemWidths = _createUseState4[0],
      setItemWidths = _createUseState4[1];

  var _createUseState5 = createUseState(0),
      _createUseState6 = slicedToArray_slicedToArray(_createUseState5, 2),
      prevRestWidth = _createUseState6[0],
      setPrevRestWidth = _createUseState6[1];

  var _createUseState7 = createUseState(0),
      _createUseState8 = slicedToArray_slicedToArray(_createUseState7, 2),
      restWidth = _createUseState8[0],
      setRestWidth = _createUseState8[1];

  var _createUseState9 = createUseState(0),
      _createUseState10 = slicedToArray_slicedToArray(_createUseState9, 2),
      suffixWidth = _createUseState10[0],
      setSuffixWidth = _createUseState10[1];

  var _useState = (0,external_React_namespaceObject.useState)(null),
      _useState2 = slicedToArray_slicedToArray(_useState, 2),
      suffixFixedStart = _useState2[0],
      setSuffixFixedStart = _useState2[1];

  var _useState3 = (0,external_React_namespaceObject.useState)(null),
      _useState4 = slicedToArray_slicedToArray(_useState3, 2),
      displayCount = _useState4[0],
      setDisplayCount = _useState4[1];

  var mergedDisplayCount = external_React_namespaceObject.useMemo(function () {
    if (displayCount === null && fullySSR) {
      return Number.MAX_SAFE_INTEGER;
    }

    return displayCount || 0;
  }, [displayCount, containerWidth]);

  var _useState5 = (0,external_React_namespaceObject.useState)(false),
      _useState6 = slicedToArray_slicedToArray(_useState5, 2),
      restReady = _useState6[0],
      setRestReady = _useState6[1];

  var itemPrefixCls = "".concat(prefixCls, "-item"); // Always use the max width to avoid blink

  var mergedRestWidth = Math.max(prevRestWidth, restWidth); // ================================= Data =================================

  var isResponsive = maxCount === RESPONSIVE;
  var shouldResponsive = data.length && isResponsive;
  var invalidate = maxCount === INVALIDATE;
  /**
   * When is `responsive`, we will always render rest node to get the real width of it for calculation
   */

  var showRest = shouldResponsive || typeof maxCount === 'number' && data.length > maxCount;
  var mergedData = (0,external_React_namespaceObject.useMemo)(function () {
    var items = data;

    if (shouldResponsive) {
      if (containerWidth === null && fullySSR) {
        items = data;
      } else {
        items = data.slice(0, Math.min(data.length, mergedContainerWidth / itemWidth));
      }
    } else if (typeof maxCount === 'number') {
      items = data.slice(0, maxCount);
    }

    return items;
  }, [data, itemWidth, containerWidth, maxCount, shouldResponsive]);
  var omittedItems = (0,external_React_namespaceObject.useMemo)(function () {
    if (shouldResponsive) {
      return data.slice(mergedDisplayCount + 1);
    }

    return data.slice(mergedData.length);
  }, [data, mergedData, shouldResponsive, mergedDisplayCount]); // ================================= Item =================================

  var getKey = (0,external_React_namespaceObject.useCallback)(function (item, index) {
    var _ref;

    if (typeof itemKey === 'function') {
      return itemKey(item);
    }

    return (_ref = itemKey && (item === null || item === void 0 ? void 0 : item[itemKey])) !== null && _ref !== void 0 ? _ref : index;
  }, [itemKey]);
  var mergedRenderItem = (0,external_React_namespaceObject.useCallback)(renderItem || function (item) {
    return item;
  }, [renderItem]);

  function updateDisplayCount(count, suffixFixedStartVal, notReady) {
    // React 18 will sync render even when the value is same in some case.
    // We take `mergedData` as deps which may cause dead loop if it's dynamic generate.
    // ref: https://github.com/ant-design/ant-design/issues/36559
    if (displayCount === count && (suffixFixedStartVal === undefined || suffixFixedStartVal === suffixFixedStart)) {
      return;
    }

    setDisplayCount(count);

    if (!notReady) {
      setRestReady(count < data.length - 1);
      onVisibleChange === null || onVisibleChange === void 0 ? void 0 : onVisibleChange(count);
    }

    if (suffixFixedStartVal !== undefined) {
      setSuffixFixedStart(suffixFixedStartVal);
    }
  } // ================================= Size =================================


  function onOverflowResize(_, element) {
    setContainerWidth(element.clientWidth);
  }

  function registerSize(key, width) {
    setItemWidths(function (origin) {
      var clone = new Map(origin);

      if (width === null) {
        clone.delete(key);
      } else {
        clone.set(key, width);
      }

      return clone;
    });
  }

  function registerOverflowSize(_, width) {
    setRestWidth(width);
    setPrevRestWidth(restWidth);
  }

  function registerSuffixSize(_, width) {
    setSuffixWidth(width);
  } // ================================ Effect ================================


  function getItemWidth(index) {
    return itemWidths.get(getKey(mergedData[index], index));
  }

  hooks_useLayoutEffect(function () {
    if (mergedContainerWidth && mergedRestWidth && mergedData) {
      var totalWidth = suffixWidth;
      var len = mergedData.length;
      var lastIndex = len - 1; // When data count change to 0, reset this since not loop will reach

      if (!len) {
        updateDisplayCount(0, null);
        return;
      }

      for (var i = 0; i < len; i += 1) {
        var currentItemWidth = getItemWidth(i); // Fully will always render

        if (fullySSR) {
          currentItemWidth = currentItemWidth || 0;
        } // Break since data not ready


        if (currentItemWidth === undefined) {
          updateDisplayCount(i - 1, undefined, true);
          break;
        } // Find best match


        totalWidth += currentItemWidth;

        if ( // Only one means `totalWidth` is the final width
        lastIndex === 0 && totalWidth <= mergedContainerWidth || // Last two width will be the final width
        i === lastIndex - 1 && totalWidth + getItemWidth(lastIndex) <= mergedContainerWidth) {
          // Additional check if match the end
          updateDisplayCount(lastIndex, null);
          break;
        } else if (totalWidth + mergedRestWidth > mergedContainerWidth) {
          // Can not hold all the content to show rest
          updateDisplayCount(i - 1, totalWidth - currentItemWidth - suffixWidth + restWidth);
          break;
        }
      }

      if (suffix && getItemWidth(0) + suffixWidth > mergedContainerWidth) {
        setSuffixFixedStart(null);
      }
    }
  }, [mergedContainerWidth, itemWidths, restWidth, suffixWidth, getKey, mergedData]); // ================================ Render ================================

  var displayRest = restReady && !!omittedItems.length;
  var suffixStyle = {};

  if (suffixFixedStart !== null && shouldResponsive) {
    suffixStyle = {
      position: 'absolute',
      left: suffixFixedStart,
      top: 0
    };
  }

  var itemSharedProps = {
    prefixCls: itemPrefixCls,
    responsive: shouldResponsive,
    component: itemComponent,
    invalidate: invalidate
  }; // >>>>> Choice render fun by `renderRawItem`

  var internalRenderItemNode = renderRawItem ? function (item, index) {
    var key = getKey(item, index);
    return /*#__PURE__*/external_React_namespaceObject.createElement(OverflowContext.Provider, {
      key: key,
      value: _objectSpread2(_objectSpread2({}, itemSharedProps), {}, {
        order: index,
        item: item,
        itemKey: key,
        registerSize: registerSize,
        display: index <= mergedDisplayCount
      })
    }, renderRawItem(item, index));
  } : function (item, index) {
    var key = getKey(item, index);
    return /*#__PURE__*/external_React_namespaceObject.createElement(es_Item, _extends({}, itemSharedProps, {
      order: index,
      key: key,
      item: item,
      renderItem: mergedRenderItem,
      itemKey: key,
      registerSize: registerSize,
      display: index <= mergedDisplayCount
    }));
  }; // >>>>> Rest node

  var restNode;
  var restContextProps = {
    order: displayRest ? mergedDisplayCount : Number.MAX_SAFE_INTEGER,
    className: "".concat(itemPrefixCls, "-rest"),
    registerSize: registerOverflowSize,
    display: displayRest
  };

  if (!renderRawRest) {
    var mergedRenderRest = renderRest || defaultRenderRest;
    restNode = /*#__PURE__*/external_React_namespaceObject.createElement(es_Item, _extends({}, itemSharedProps, restContextProps), typeof mergedRenderRest === 'function' ? mergedRenderRest(omittedItems) : mergedRenderRest);
  } else if (renderRawRest) {
    restNode = /*#__PURE__*/external_React_namespaceObject.createElement(OverflowContext.Provider, {
      value: _objectSpread2(_objectSpread2({}, itemSharedProps), restContextProps)
    }, renderRawRest(omittedItems));
  }

  var overflowNode = /*#__PURE__*/external_React_namespaceObject.createElement(Component, _extends({
    className: classnames_default()(!invalidate && prefixCls, className),
    style: style,
    ref: ref
  }, restProps), mergedData.map(internalRenderItemNode), showRest ? restNode : null, suffix && /*#__PURE__*/external_React_namespaceObject.createElement(es_Item, _extends({}, itemSharedProps, {
    responsive: isResponsive,
    responsiveDisabled: !shouldResponsive,
    order: mergedDisplayCount,
    className: "".concat(itemPrefixCls, "-suffix"),
    registerSize: registerSuffixSize,
    display: true,
    style: suffixStyle
  }), suffix));

  if (isResponsive) {
    overflowNode = /*#__PURE__*/external_React_namespaceObject.createElement(rc_resize_observer_es, {
      onResize: onOverflowResize,
      disabled: !shouldResponsive
    }, overflowNode);
  }

  return overflowNode;
}

var ForwardOverflow = /*#__PURE__*/external_React_namespaceObject.forwardRef(Overflow);
ForwardOverflow.displayName = 'Overflow';
ForwardOverflow.Item = es_RawItem;
ForwardOverflow.RESPONSIVE = RESPONSIVE;
ForwardOverflow.INVALIDATE = INVALIDATE; // Convert to generic type

/* harmony default export */ const es_Overflow = (ForwardOverflow);
;// CONCATENATED MODULE: ./node_modules/rc-overflow/es/index.js

/* harmony default export */ const rc_overflow_es = (es_Overflow);
;// CONCATENATED MODULE: ./node_modules/rc-select/es/TransBtn.js



var TransBtn = function TransBtn(_ref) {
  var className = _ref.className,
      customizeIcon = _ref.customizeIcon,
      customizeIconProps = _ref.customizeIconProps,
      _onMouseDown = _ref.onMouseDown,
      onClick = _ref.onClick,
      children = _ref.children;
  var icon;

  if (typeof customizeIcon === 'function') {
    icon = customizeIcon(customizeIconProps);
  } else {
    icon = customizeIcon;
  }

  return /*#__PURE__*/external_React_namespaceObject.createElement("span", {
    className: className,
    onMouseDown: function onMouseDown(event) {
      event.preventDefault();

      if (_onMouseDown) {
        _onMouseDown(event);
      }
    },
    style: {
      userSelect: 'none',
      WebkitUserSelect: 'none'
    },
    unselectable: "on",
    onClick: onClick,
    "aria-hidden": true
  }, icon !== undefined ? icon : /*#__PURE__*/external_React_namespaceObject.createElement("span", {
    className: classnames_default()(className.split(/\s+/).map(function (cls) {
      return "".concat(cls, "-icon");
    }))
  }, children));
};

/* harmony default export */ const es_TransBtn = (TransBtn);
;// CONCATENATED MODULE: ./node_modules/rc-select/es/Selector/Input.js






var Input = function Input(_ref, ref) {
  var _inputNode2, _inputNode2$props;

  var prefixCls = _ref.prefixCls,
      id = _ref.id,
      inputElement = _ref.inputElement,
      disabled = _ref.disabled,
      tabIndex = _ref.tabIndex,
      autoFocus = _ref.autoFocus,
      autoComplete = _ref.autoComplete,
      editable = _ref.editable,
      activeDescendantId = _ref.activeDescendantId,
      value = _ref.value,
      maxLength = _ref.maxLength,
      _onKeyDown = _ref.onKeyDown,
      _onMouseDown = _ref.onMouseDown,
      _onChange = _ref.onChange,
      onPaste = _ref.onPaste,
      _onCompositionStart = _ref.onCompositionStart,
      _onCompositionEnd = _ref.onCompositionEnd,
      open = _ref.open,
      attrs = _ref.attrs;
  var inputNode = inputElement || /*#__PURE__*/external_React_namespaceObject.createElement("input", null);
  var _inputNode = inputNode,
      originRef = _inputNode.ref,
      originProps = _inputNode.props;
  var onOriginKeyDown = originProps.onKeyDown,
      onOriginChange = originProps.onChange,
      onOriginMouseDown = originProps.onMouseDown,
      onOriginCompositionStart = originProps.onCompositionStart,
      onOriginCompositionEnd = originProps.onCompositionEnd,
      style = originProps.style;
  warning_warning(!('maxLength' in inputNode.props), "Passing 'maxLength' to input element directly may not work because input in BaseSelect is controlled.");
  inputNode = /*#__PURE__*/external_React_namespaceObject.cloneElement(inputNode, _objectSpread2(_objectSpread2(_objectSpread2({
    type: 'search'
  }, originProps), {}, {
    // Override over origin props
    id: id,
    ref: composeRef(ref, originRef),
    disabled: disabled,
    tabIndex: tabIndex,
    autoComplete: autoComplete || 'off',
    autoFocus: autoFocus,
    className: classnames_default()("".concat(prefixCls, "-selection-search-input"), (_inputNode2 = inputNode) === null || _inputNode2 === void 0 ? void 0 : (_inputNode2$props = _inputNode2.props) === null || _inputNode2$props === void 0 ? void 0 : _inputNode2$props.className),
    role: 'combobox',
    'aria-expanded': open,
    'aria-haspopup': 'listbox',
    'aria-owns': "".concat(id, "_list"),
    'aria-autocomplete': 'list',
    'aria-controls': "".concat(id, "_list"),
    'aria-activedescendant': activeDescendantId
  }, attrs), {}, {
    value: editable ? value : '',
    maxLength: maxLength,
    readOnly: !editable,
    unselectable: !editable ? 'on' : null,
    style: _objectSpread2(_objectSpread2({}, style), {}, {
      opacity: editable ? null : 0
    }),
    onKeyDown: function onKeyDown(event) {
      _onKeyDown(event);

      if (onOriginKeyDown) {
        onOriginKeyDown(event);
      }
    },
    onMouseDown: function onMouseDown(event) {
      _onMouseDown(event);

      if (onOriginMouseDown) {
        onOriginMouseDown(event);
      }
    },
    onChange: function onChange(event) {
      _onChange(event);

      if (onOriginChange) {
        onOriginChange(event);
      }
    },
    onCompositionStart: function onCompositionStart(event) {
      _onCompositionStart(event);

      if (onOriginCompositionStart) {
        onOriginCompositionStart(event);
      }
    },
    onCompositionEnd: function onCompositionEnd(event) {
      _onCompositionEnd(event);

      if (onOriginCompositionEnd) {
        onOriginCompositionEnd(event);
      }
    },
    onPaste: onPaste
  }));
  return inputNode;
};

var RefInput = /*#__PURE__*/external_React_namespaceObject.forwardRef(Input);
RefInput.displayName = 'Input';
/* harmony default export */ const Selector_Input = (RefInput);
;// CONCATENATED MODULE: ./node_modules/rc-select/es/utils/commonUtil.js
function commonUtil_toArray(value) {
  if (Array.isArray(value)) {
    return value;
  }

  return value !== undefined ? [value] : [];
}
var isClient = typeof window !== 'undefined' && window.document && window.document.documentElement;
/** Is client side and not jsdom */

var isBrowserClient =  true && isClient;
;// CONCATENATED MODULE: ./node_modules/rc-select/es/hooks/useLayoutEffect.js
/* eslint-disable react-hooks/rules-of-hooks */


/**
 * Wrap `React.useLayoutEffect` which will not throw warning message in test env
 */

function useLayoutEffect_useLayoutEffect(effect, deps) {
  // Never happen in test env
  if (isBrowserClient) {
    /* istanbul ignore next */
    external_React_namespaceObject.useLayoutEffect(effect, deps);
  } else {
    external_React_namespaceObject.useEffect(effect, deps);
  }
}
/* eslint-enable */
;// CONCATENATED MODULE: ./node_modules/rc-select/es/Selector/MultipleSelector.js











function itemKey(value) {
  var _value$key;

  return (_value$key = value.key) !== null && _value$key !== void 0 ? _value$key : value.value;
}

var onPreventMouseDown = function onPreventMouseDown(event) {
  event.preventDefault();
  event.stopPropagation();
};

var SelectSelector = function SelectSelector(props) {
  var id = props.id,
      prefixCls = props.prefixCls,
      values = props.values,
      open = props.open,
      searchValue = props.searchValue,
      inputRef = props.inputRef,
      placeholder = props.placeholder,
      disabled = props.disabled,
      mode = props.mode,
      showSearch = props.showSearch,
      autoFocus = props.autoFocus,
      autoComplete = props.autoComplete,
      activeDescendantId = props.activeDescendantId,
      tabIndex = props.tabIndex,
      removeIcon = props.removeIcon,
      maxTagCount = props.maxTagCount,
      maxTagTextLength = props.maxTagTextLength,
      _props$maxTagPlacehol = props.maxTagPlaceholder,
      maxTagPlaceholder = _props$maxTagPlacehol === void 0 ? function (omittedValues) {
    return "+ ".concat(omittedValues.length, " ...");
  } : _props$maxTagPlacehol,
      tagRender = props.tagRender,
      onToggleOpen = props.onToggleOpen,
      onRemove = props.onRemove,
      onInputChange = props.onInputChange,
      onInputPaste = props.onInputPaste,
      onInputKeyDown = props.onInputKeyDown,
      onInputMouseDown = props.onInputMouseDown,
      onInputCompositionStart = props.onInputCompositionStart,
      onInputCompositionEnd = props.onInputCompositionEnd;
  var measureRef = external_React_namespaceObject.useRef(null);

  var _useState = (0,external_React_namespaceObject.useState)(0),
      _useState2 = slicedToArray_slicedToArray(_useState, 2),
      inputWidth = _useState2[0],
      setInputWidth = _useState2[1];

  var _useState3 = (0,external_React_namespaceObject.useState)(false),
      _useState4 = slicedToArray_slicedToArray(_useState3, 2),
      focused = _useState4[0],
      setFocused = _useState4[1];

  var selectionPrefixCls = "".concat(prefixCls, "-selection"); // ===================== Search ======================

  var inputValue = open || mode === 'tags' ? searchValue : '';
  var inputEditable = mode === 'tags' || showSearch && (open || focused); // We measure width and set to the input immediately

  useLayoutEffect_useLayoutEffect(function () {
    setInputWidth(measureRef.current.scrollWidth);
  }, [inputValue]); // ===================== Render ======================
  // >>> Render Selector Node. Includes Item & Rest

  function defaultRenderSelector(title, content, itemDisabled, closable, onClose) {
    return /*#__PURE__*/external_React_namespaceObject.createElement("span", {
      className: classnames_default()("".concat(selectionPrefixCls, "-item"), _defineProperty({}, "".concat(selectionPrefixCls, "-item-disabled"), itemDisabled)),
      title: typeof title === 'string' || typeof title === 'number' ? title.toString() : undefined
    }, /*#__PURE__*/external_React_namespaceObject.createElement("span", {
      className: "".concat(selectionPrefixCls, "-item-content")
    }, content), closable && /*#__PURE__*/external_React_namespaceObject.createElement(es_TransBtn, {
      className: "".concat(selectionPrefixCls, "-item-remove"),
      onMouseDown: onPreventMouseDown,
      onClick: onClose,
      customizeIcon: removeIcon
    }, "\xD7"));
  }

  function customizeRenderSelector(value, content, itemDisabled, closable, onClose) {
    var onMouseDown = function onMouseDown(e) {
      onPreventMouseDown(e);
      onToggleOpen(!open);
    };

    return /*#__PURE__*/external_React_namespaceObject.createElement("span", {
      onMouseDown: onMouseDown
    }, tagRender({
      label: content,
      value: value,
      disabled: itemDisabled,
      closable: closable,
      onClose: onClose
    }));
  }

  function renderItem(valueItem) {
    var itemDisabled = valueItem.disabled,
        label = valueItem.label,
        value = valueItem.value;
    var closable = !disabled && !itemDisabled;
    var displayLabel = label;

    if (typeof maxTagTextLength === 'number') {
      if (typeof label === 'string' || typeof label === 'number') {
        var strLabel = String(displayLabel);

        if (strLabel.length > maxTagTextLength) {
          displayLabel = "".concat(strLabel.slice(0, maxTagTextLength), "...");
        }
      }
    }

    var onClose = function onClose(event) {
      if (event) event.stopPropagation();
      onRemove(valueItem);
    };

    return typeof tagRender === 'function' ? customizeRenderSelector(value, displayLabel, itemDisabled, closable, onClose) : defaultRenderSelector(label, displayLabel, itemDisabled, closable, onClose);
  }

  function renderRest(omittedValues) {
    var content = typeof maxTagPlaceholder === 'function' ? maxTagPlaceholder(omittedValues) : maxTagPlaceholder;
    return defaultRenderSelector(content, content, false);
  } // >>> Input Node


  var inputNode = /*#__PURE__*/external_React_namespaceObject.createElement("div", {
    className: "".concat(selectionPrefixCls, "-search"),
    style: {
      width: inputWidth
    },
    onFocus: function onFocus() {
      setFocused(true);
    },
    onBlur: function onBlur() {
      setFocused(false);
    }
  }, /*#__PURE__*/external_React_namespaceObject.createElement(Selector_Input, {
    ref: inputRef,
    open: open,
    prefixCls: prefixCls,
    id: id,
    inputElement: null,
    disabled: disabled,
    autoFocus: autoFocus,
    autoComplete: autoComplete,
    editable: inputEditable,
    activeDescendantId: activeDescendantId,
    value: inputValue,
    onKeyDown: onInputKeyDown,
    onMouseDown: onInputMouseDown,
    onChange: onInputChange,
    onPaste: onInputPaste,
    onCompositionStart: onInputCompositionStart,
    onCompositionEnd: onInputCompositionEnd,
    tabIndex: tabIndex,
    attrs: pickAttrs(props, true)
  }), /*#__PURE__*/external_React_namespaceObject.createElement("span", {
    ref: measureRef,
    className: "".concat(selectionPrefixCls, "-search-mirror"),
    "aria-hidden": true
  }, inputValue, "\xA0")); // >>> Selections

  var selectionNode = /*#__PURE__*/external_React_namespaceObject.createElement(rc_overflow_es, {
    prefixCls: "".concat(selectionPrefixCls, "-overflow"),
    data: values,
    renderItem: renderItem,
    renderRest: renderRest,
    suffix: inputNode,
    itemKey: itemKey,
    maxCount: maxTagCount
  });
  return /*#__PURE__*/external_React_namespaceObject.createElement(external_React_namespaceObject.Fragment, null, selectionNode, !values.length && !inputValue && /*#__PURE__*/external_React_namespaceObject.createElement("span", {
    className: "".concat(selectionPrefixCls, "-placeholder")
  }, placeholder));
};

/* harmony default export */ const MultipleSelector = (SelectSelector);
;// CONCATENATED MODULE: ./node_modules/rc-select/es/Selector/SingleSelector.js





var SingleSelector = function SingleSelector(props) {
  var inputElement = props.inputElement,
      prefixCls = props.prefixCls,
      id = props.id,
      inputRef = props.inputRef,
      disabled = props.disabled,
      autoFocus = props.autoFocus,
      autoComplete = props.autoComplete,
      activeDescendantId = props.activeDescendantId,
      mode = props.mode,
      open = props.open,
      values = props.values,
      placeholder = props.placeholder,
      tabIndex = props.tabIndex,
      showSearch = props.showSearch,
      searchValue = props.searchValue,
      activeValue = props.activeValue,
      maxLength = props.maxLength,
      onInputKeyDown = props.onInputKeyDown,
      onInputMouseDown = props.onInputMouseDown,
      onInputChange = props.onInputChange,
      onInputPaste = props.onInputPaste,
      onInputCompositionStart = props.onInputCompositionStart,
      onInputCompositionEnd = props.onInputCompositionEnd;

  var _React$useState = external_React_namespaceObject.useState(false),
      _React$useState2 = slicedToArray_slicedToArray(_React$useState, 2),
      inputChanged = _React$useState2[0],
      setInputChanged = _React$useState2[1];

  var combobox = mode === 'combobox';
  var inputEditable = combobox || showSearch;
  var item = values[0];
  var inputValue = searchValue || '';

  if (combobox && activeValue && !inputChanged) {
    inputValue = activeValue;
  }

  external_React_namespaceObject.useEffect(function () {
    if (combobox) {
      setInputChanged(false);
    }
  }, [combobox, activeValue]); // Not show text when closed expect combobox mode

  var hasTextInput = mode !== 'combobox' && !open && !showSearch ? false : !!inputValue;
  var title = item && (typeof item.label === 'string' || typeof item.label === 'number') ? item.label.toString() : undefined;

  var renderPlaceholder = function renderPlaceholder() {
    if (item) {
      return null;
    }

    var hiddenStyle = hasTextInput ? {
      visibility: 'hidden'
    } : undefined;
    return /*#__PURE__*/external_React_namespaceObject.createElement("span", {
      className: "".concat(prefixCls, "-selection-placeholder"),
      style: hiddenStyle
    }, placeholder);
  };

  return /*#__PURE__*/external_React_namespaceObject.createElement(external_React_namespaceObject.Fragment, null, /*#__PURE__*/external_React_namespaceObject.createElement("span", {
    className: "".concat(prefixCls, "-selection-search")
  }, /*#__PURE__*/external_React_namespaceObject.createElement(Selector_Input, {
    ref: inputRef,
    prefixCls: prefixCls,
    id: id,
    open: open,
    inputElement: inputElement,
    disabled: disabled,
    autoFocus: autoFocus,
    autoComplete: autoComplete,
    editable: inputEditable,
    activeDescendantId: activeDescendantId,
    value: inputValue,
    onKeyDown: onInputKeyDown,
    onMouseDown: onInputMouseDown,
    onChange: function onChange(e) {
      setInputChanged(true);
      onInputChange(e);
    },
    onPaste: onInputPaste,
    onCompositionStart: onInputCompositionStart,
    onCompositionEnd: onInputCompositionEnd,
    tabIndex: tabIndex,
    attrs: pickAttrs(props, true),
    maxLength: combobox ? maxLength : undefined
  })), !combobox && item && !hasTextInput && /*#__PURE__*/external_React_namespaceObject.createElement("span", {
    className: "".concat(prefixCls, "-selection-item"),
    title: title
  }, item.label), renderPlaceholder());
};

/* harmony default export */ const Selector_SingleSelector = (SingleSelector);
;// CONCATENATED MODULE: ./node_modules/rc-select/es/hooks/useLock.js

/**
 * Locker return cached mark.
 * If set to `true`, will return `true` in a short time even if set `false`.
 * If set to `false` and then set to `true`, will change to `true`.
 * And after time duration, it will back to `null` automatically.
 */

function useLock() {
  var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 250;
  var lockRef = external_React_namespaceObject.useRef(null);
  var timeoutRef = external_React_namespaceObject.useRef(null); // Clean up

  external_React_namespaceObject.useEffect(function () {
    return function () {
      window.clearTimeout(timeoutRef.current);
    };
  }, []);

  function doLock(locked) {
    if (locked || lockRef.current === null) {
      lockRef.current = locked;
    }

    window.clearTimeout(timeoutRef.current);
    timeoutRef.current = window.setTimeout(function () {
      lockRef.current = null;
    }, duration);
  }

  return [function () {
    return lockRef.current;
  }, doLock];
}
;// CONCATENATED MODULE: ./node_modules/rc-select/es/utils/keyUtil.js

/** keyCode Judgment function */

function isValidateOpenKey(currentKeyCode) {
  return ![// System function button
  es_KeyCode.ESC, es_KeyCode.SHIFT, es_KeyCode.BACKSPACE, es_KeyCode.TAB, es_KeyCode.WIN_KEY, es_KeyCode.ALT, es_KeyCode.META, es_KeyCode.WIN_KEY_RIGHT, es_KeyCode.CTRL, es_KeyCode.SEMICOLON, es_KeyCode.EQUALS, es_KeyCode.CAPS_LOCK, es_KeyCode.CONTEXT_MENU, // F1-F12
  es_KeyCode.F1, es_KeyCode.F2, es_KeyCode.F3, es_KeyCode.F4, es_KeyCode.F5, es_KeyCode.F6, es_KeyCode.F7, es_KeyCode.F8, es_KeyCode.F9, es_KeyCode.F10, es_KeyCode.F11, es_KeyCode.F12].includes(currentKeyCode);
}
;// CONCATENATED MODULE: ./node_modules/rc-select/es/Selector/index.js



/**
 * Cursor rule:
 * 1. Only `showSearch` enabled
 * 2. Only `open` is `true`
 * 3. When typing, set `open` to `true` which hit rule of 2
 *
 * Accessibility:
 * - https://www.w3.org/TR/wai-aria-practices/examples/combobox/aria1.1pattern/listbox-combo.html
 */








var Selector = function Selector(props, ref) {
  var inputRef = (0,external_React_namespaceObject.useRef)(null);
  var compositionStatusRef = (0,external_React_namespaceObject.useRef)(false);
  var prefixCls = props.prefixCls,
      open = props.open,
      mode = props.mode,
      showSearch = props.showSearch,
      tokenWithEnter = props.tokenWithEnter,
      onSearch = props.onSearch,
      onSearchSubmit = props.onSearchSubmit,
      onToggleOpen = props.onToggleOpen,
      onInputKeyDown = props.onInputKeyDown,
      domRef = props.domRef; // ======================= Ref =======================

  external_React_namespaceObject.useImperativeHandle(ref, function () {
    return {
      focus: function focus() {
        inputRef.current.focus();
      },
      blur: function blur() {
        inputRef.current.blur();
      }
    };
  }); // ====================== Input ======================

  var _useLock = useLock(0),
      _useLock2 = slicedToArray_slicedToArray(_useLock, 2),
      getInputMouseDown = _useLock2[0],
      setInputMouseDown = _useLock2[1];

  var onInternalInputKeyDown = function onInternalInputKeyDown(event) {
    var which = event.which;

    if (which === es_KeyCode.UP || which === es_KeyCode.DOWN) {
      event.preventDefault();
    }

    if (onInputKeyDown) {
      onInputKeyDown(event);
    }

    if (which === es_KeyCode.ENTER && mode === 'tags' && !compositionStatusRef.current && !open) {
      // When menu isn't open, OptionList won't trigger a value change
      // So when enter is pressed, the tag's input value should be emitted here to let selector know
      onSearchSubmit === null || onSearchSubmit === void 0 ? void 0 : onSearchSubmit(event.target.value);
    }

    if (isValidateOpenKey(which)) {
      onToggleOpen(true);
    }
  };
  /**
   * We can not use `findDOMNode` sine it will get warning,
   * have to use timer to check if is input element.
   */


  var onInternalInputMouseDown = function onInternalInputMouseDown() {
    setInputMouseDown(true);
  }; // When paste come, ignore next onChange


  var pastedTextRef = (0,external_React_namespaceObject.useRef)(null);

  var triggerOnSearch = function triggerOnSearch(value) {
    if (onSearch(value, true, compositionStatusRef.current) !== false) {
      onToggleOpen(true);
    }
  };

  var onInputCompositionStart = function onInputCompositionStart() {
    compositionStatusRef.current = true;
  };

  var onInputCompositionEnd = function onInputCompositionEnd(e) {
    compositionStatusRef.current = false; // Trigger search again to support `tokenSeparators` with typewriting

    if (mode !== 'combobox') {
      triggerOnSearch(e.target.value);
    }
  };

  var onInputChange = function onInputChange(event) {
    var value = event.target.value; // Pasted text should replace back to origin content

    if (tokenWithEnter && pastedTextRef.current && /[\r\n]/.test(pastedTextRef.current)) {
      // CRLF will be treated as a single space for input element
      var replacedText = pastedTextRef.current.replace(/[\r\n]+$/, '').replace(/\r\n/g, ' ').replace(/[\r\n]/g, ' ');
      value = value.replace(replacedText, pastedTextRef.current);
    }

    pastedTextRef.current = null;
    triggerOnSearch(value);
  };

  var onInputPaste = function onInputPaste(e) {
    var clipboardData = e.clipboardData;
    var value = clipboardData.getData('text');
    pastedTextRef.current = value;
  };

  var onClick = function onClick(_ref) {
    var target = _ref.target;

    if (target !== inputRef.current) {
      // Should focus input if click the selector
      var isIE = document.body.style.msTouchAction !== undefined;

      if (isIE) {
        setTimeout(function () {
          inputRef.current.focus();
        });
      } else {
        inputRef.current.focus();
      }
    }
  };

  var onMouseDown = function onMouseDown(event) {
    var inputMouseDown = getInputMouseDown();

    if (event.target !== inputRef.current && !inputMouseDown) {
      event.preventDefault();
    }

    if (mode !== 'combobox' && (!showSearch || !inputMouseDown) || !open) {
      if (open) {
        onSearch('', true, false);
      }

      onToggleOpen();
    }
  }; // ================= Inner Selector ==================


  var sharedProps = {
    inputRef: inputRef,
    onInputKeyDown: onInternalInputKeyDown,
    onInputMouseDown: onInternalInputMouseDown,
    onInputChange: onInputChange,
    onInputPaste: onInputPaste,
    onInputCompositionStart: onInputCompositionStart,
    onInputCompositionEnd: onInputCompositionEnd
  };
  var selectNode = mode === 'multiple' || mode === 'tags' ? /*#__PURE__*/external_React_namespaceObject.createElement(MultipleSelector, _extends({}, props, sharedProps)) : /*#__PURE__*/external_React_namespaceObject.createElement(Selector_SingleSelector, _extends({}, props, sharedProps));
  return /*#__PURE__*/external_React_namespaceObject.createElement("div", {
    ref: domRef,
    className: "".concat(prefixCls, "-selector"),
    onClick: onClick,
    onMouseDown: onMouseDown
  }, selectNode);
};

var ForwardSelector = /*#__PURE__*/external_React_namespaceObject.forwardRef(Selector);
ForwardSelector.displayName = 'Selector';
/* harmony default export */ const es_Selector = (ForwardSelector);
;// CONCATENATED MODULE: ./node_modules/rc-select/es/hooks/useSelectTriggerControl.js

function useSelectTriggerControl(elements, open, triggerOpen, customizedTrigger) {
  var propsRef = external_React_namespaceObject.useRef(null);
  propsRef.current = {
    open: open,
    triggerOpen: triggerOpen,
    customizedTrigger: customizedTrigger
  };
  external_React_namespaceObject.useEffect(function () {
    function onGlobalMouseDown(event) {
      var _propsRef$current;

      // If trigger is customized, Trigger will take control of popupVisible
      if ((_propsRef$current = propsRef.current) === null || _propsRef$current === void 0 ? void 0 : _propsRef$current.customizedTrigger) {
        return;
      }

      var target = event.target;

      if (target.shadowRoot && event.composed) {
        target = event.composedPath()[0] || target;
      }

      if (propsRef.current.open && elements().filter(function (element) {
        return element;
      }).every(function (element) {
        return !element.contains(target) && element !== target;
      })) {
        // Should trigger close
        propsRef.current.triggerOpen(false);
      }
    }

    window.addEventListener('mousedown', onGlobalMouseDown);
    return function () {
      return window.removeEventListener('mousedown', onGlobalMouseDown);
    };
  }, []);
}
;// CONCATENATED MODULE: ./node_modules/rc-select/es/hooks/useDelayReset.js


/**
 * Similar with `useLock`, but this hook will always execute last value.
 * When set to `true`, it will keep `true` for a short time even if `false` is set.
 */

function useDelayReset() {
  var timeout = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;

  var _React$useState = external_React_namespaceObject.useState(false),
      _React$useState2 = slicedToArray_slicedToArray(_React$useState, 2),
      bool = _React$useState2[0],
      setBool = _React$useState2[1];

  var delayRef = external_React_namespaceObject.useRef(null);

  var cancelLatest = function cancelLatest() {
    window.clearTimeout(delayRef.current);
  };

  external_React_namespaceObject.useEffect(function () {
    return cancelLatest;
  }, []);

  var delaySetBool = function delaySetBool(value, callback) {
    cancelLatest();
    delayRef.current = window.setTimeout(function () {
      setBool(value);

      if (callback) {
        callback();
      }
    }, timeout);
  };

  return [bool, delaySetBool, cancelLatest];
}
;// CONCATENATED MODULE: ./node_modules/rc-select/es/hooks/useBaseProps.js
/**
 * BaseSelect provide some parsed data into context.
 * You can use this hooks to get them.
 */

var BaseSelectContext = /*#__PURE__*/external_React_namespaceObject.createContext(null);
function useBaseProps() {
  return external_React_namespaceObject.useContext(BaseSelectContext);
}
;// CONCATENATED MODULE: ./node_modules/rc-select/es/BaseSelect.js







var BaseSelect_excluded = ["id", "prefixCls", "className", "showSearch", "tagRender", "direction", "omitDomProps", "displayValues", "onDisplayValuesChange", "emptyOptions", "notFoundContent", "onClear", "mode", "disabled", "loading", "getInputElement", "getRawInputElement", "open", "defaultOpen", "onDropdownVisibleChange", "activeValue", "onActiveValueChange", "activeDescendantId", "searchValue", "onSearch", "onSearchSplit", "tokenSeparators", "allowClear", "showArrow", "inputIcon", "clearIcon", "OptionList", "animation", "transitionName", "dropdownStyle", "dropdownClassName", "dropdownMatchSelectWidth", "dropdownRender", "dropdownAlign", "placement", "getPopupContainer", "showAction", "onFocus", "onBlur", "onKeyUp", "onKeyDown", "onMouseDown"];















var DEFAULT_OMIT_PROPS = ['value', 'onChange', 'removeIcon', 'placeholder', 'autoFocus', 'maxTagCount', 'maxTagTextLength', 'maxTagPlaceholder', 'choiceTransitionName', 'onInputKeyDown', 'onPopupScroll', 'tabIndex'];
function BaseSelect_isMultiple(mode) {
  return mode === 'tags' || mode === 'multiple';
}
var BaseSelect = /*#__PURE__*/external_React_namespaceObject.forwardRef(function (props, ref) {
  var _customizeRawInputEle, _classNames2;

  var id = props.id,
      prefixCls = props.prefixCls,
      className = props.className,
      showSearch = props.showSearch,
      tagRender = props.tagRender,
      direction = props.direction,
      omitDomProps = props.omitDomProps,
      displayValues = props.displayValues,
      onDisplayValuesChange = props.onDisplayValuesChange,
      emptyOptions = props.emptyOptions,
      _props$notFoundConten = props.notFoundContent,
      notFoundContent = _props$notFoundConten === void 0 ? 'Not Found' : _props$notFoundConten,
      onClear = props.onClear,
      mode = props.mode,
      disabled = props.disabled,
      loading = props.loading,
      getInputElement = props.getInputElement,
      getRawInputElement = props.getRawInputElement,
      open = props.open,
      defaultOpen = props.defaultOpen,
      onDropdownVisibleChange = props.onDropdownVisibleChange,
      activeValue = props.activeValue,
      onActiveValueChange = props.onActiveValueChange,
      activeDescendantId = props.activeDescendantId,
      searchValue = props.searchValue,
      onSearch = props.onSearch,
      onSearchSplit = props.onSearchSplit,
      tokenSeparators = props.tokenSeparators,
      allowClear = props.allowClear,
      showArrow = props.showArrow,
      inputIcon = props.inputIcon,
      clearIcon = props.clearIcon,
      OptionList = props.OptionList,
      animation = props.animation,
      transitionName = props.transitionName,
      dropdownStyle = props.dropdownStyle,
      dropdownClassName = props.dropdownClassName,
      dropdownMatchSelectWidth = props.dropdownMatchSelectWidth,
      dropdownRender = props.dropdownRender,
      dropdownAlign = props.dropdownAlign,
      placement = props.placement,
      getPopupContainer = props.getPopupContainer,
      _props$showAction = props.showAction,
      showAction = _props$showAction === void 0 ? [] : _props$showAction,
      onFocus = props.onFocus,
      onBlur = props.onBlur,
      onKeyUp = props.onKeyUp,
      onKeyDown = props.onKeyDown,
      onMouseDown = props.onMouseDown,
      restProps = _objectWithoutProperties(props, BaseSelect_excluded); // ============================== MISC ==============================


  var multiple = BaseSelect_isMultiple(mode);
  var mergedShowSearch = (showSearch !== undefined ? showSearch : multiple) || mode === 'combobox';

  var domProps = _objectSpread2({}, restProps);

  DEFAULT_OMIT_PROPS.forEach(function (propName) {
    delete domProps[propName];
  });
  omitDomProps === null || omitDomProps === void 0 ? void 0 : omitDomProps.forEach(function (propName) {
    delete domProps[propName];
  }); // ============================= Mobile =============================

  var _React$useState = external_React_namespaceObject.useState(false),
      _React$useState2 = slicedToArray_slicedToArray(_React$useState, 2),
      mobile = _React$useState2[0],
      setMobile = _React$useState2[1];

  external_React_namespaceObject.useEffect(function () {
    // Only update on the client side
    setMobile(isMobile());
  }, []); // ============================== Refs ==============================

  var containerRef = external_React_namespaceObject.useRef(null);
  var selectorDomRef = external_React_namespaceObject.useRef(null);
  var triggerRef = external_React_namespaceObject.useRef(null);
  var selectorRef = external_React_namespaceObject.useRef(null);
  var listRef = external_React_namespaceObject.useRef(null);
  /** Used for component focused management */

  var _useDelayReset = useDelayReset(),
      _useDelayReset2 = slicedToArray_slicedToArray(_useDelayReset, 3),
      mockFocused = _useDelayReset2[0],
      setMockFocused = _useDelayReset2[1],
      cancelSetMockFocused = _useDelayReset2[2]; // =========================== Imperative ===========================


  external_React_namespaceObject.useImperativeHandle(ref, function () {
    var _selectorRef$current, _selectorRef$current2;

    return {
      focus: (_selectorRef$current = selectorRef.current) === null || _selectorRef$current === void 0 ? void 0 : _selectorRef$current.focus,
      blur: (_selectorRef$current2 = selectorRef.current) === null || _selectorRef$current2 === void 0 ? void 0 : _selectorRef$current2.blur,
      scrollTo: function scrollTo(arg) {
        var _listRef$current;

        return (_listRef$current = listRef.current) === null || _listRef$current === void 0 ? void 0 : _listRef$current.scrollTo(arg);
      }
    };
  }); // ========================== Search Value ==========================

  var mergedSearchValue = external_React_namespaceObject.useMemo(function () {
    var _displayValues$;

    if (mode !== 'combobox') {
      return searchValue;
    }

    var val = (_displayValues$ = displayValues[0]) === null || _displayValues$ === void 0 ? void 0 : _displayValues$.value;
    return typeof val === 'string' || typeof val === 'number' ? String(val) : '';
  }, [searchValue, mode, displayValues]); // ========================== Custom Input ==========================
  // Only works in `combobox`

  var customizeInputElement = mode === 'combobox' && typeof getInputElement === 'function' && getInputElement() || null; // Used for customize replacement for `rc-cascader`

  var customizeRawInputElement = typeof getRawInputElement === 'function' && getRawInputElement();
  var customizeRawInputRef = useComposeRef(selectorDomRef, customizeRawInputElement === null || customizeRawInputElement === void 0 ? void 0 : (_customizeRawInputEle = customizeRawInputElement.props) === null || _customizeRawInputEle === void 0 ? void 0 : _customizeRawInputEle.ref); // ============================== Open ==============================

  var _useMergedState = useMergedState(undefined, {
    defaultValue: defaultOpen,
    value: open
  }),
      _useMergedState2 = slicedToArray_slicedToArray(_useMergedState, 2),
      innerOpen = _useMergedState2[0],
      setInnerOpen = _useMergedState2[1];

  var mergedOpen = innerOpen; // Not trigger `open` in `combobox` when `notFoundContent` is empty

  var emptyListContent = !notFoundContent && emptyOptions;

  if (disabled || emptyListContent && mergedOpen && mode === 'combobox') {
    mergedOpen = false;
  }

  var triggerOpen = emptyListContent ? false : mergedOpen;
  var onToggleOpen = external_React_namespaceObject.useCallback(function (newOpen) {
    var nextOpen = newOpen !== undefined ? newOpen : !mergedOpen;

    if (mergedOpen !== nextOpen && !disabled) {
      setInnerOpen(nextOpen);
      onDropdownVisibleChange === null || onDropdownVisibleChange === void 0 ? void 0 : onDropdownVisibleChange(nextOpen);
    }
  }, [disabled, mergedOpen, setInnerOpen, onDropdownVisibleChange]); // ============================= Search =============================

  var tokenWithEnter = external_React_namespaceObject.useMemo(function () {
    return (tokenSeparators || []).some(function (tokenSeparator) {
      return ['\n', '\r\n'].includes(tokenSeparator);
    });
  }, [tokenSeparators]);

  var onInternalSearch = function onInternalSearch(searchText, fromTyping, isCompositing) {
    var ret = true;
    var newSearchText = searchText;
    onActiveValueChange === null || onActiveValueChange === void 0 ? void 0 : onActiveValueChange(null); // Check if match the `tokenSeparators`

    var patchLabels = isCompositing ? null : getSeparatedContent(searchText, tokenSeparators); // Ignore combobox since it's not split-able

    if (mode !== 'combobox' && patchLabels) {
      newSearchText = '';
      onSearchSplit === null || onSearchSplit === void 0 ? void 0 : onSearchSplit(patchLabels); // Should close when paste finish

      onToggleOpen(false); // Tell Selector that break next actions

      ret = false;
    }

    if (onSearch && mergedSearchValue !== newSearchText) {
      onSearch(newSearchText, {
        source: fromTyping ? 'typing' : 'effect'
      });
    }

    return ret;
  }; // Only triggered when menu is closed & mode is tags
  // If menu is open, OptionList will take charge
  // If mode isn't tags, press enter is not meaningful when you can't see any option


  var onInternalSearchSubmit = function onInternalSearchSubmit(searchText) {
    // prevent empty tags from appearing when you click the Enter button
    if (!searchText || !searchText.trim()) {
      return;
    }

    onSearch(searchText, {
      source: 'submit'
    });
  }; // Close will clean up single mode search text


  external_React_namespaceObject.useEffect(function () {
    if (!mergedOpen && !multiple && mode !== 'combobox') {
      onInternalSearch('', false, false);
    }
  }, [mergedOpen]); // ============================ Disabled ============================
  // Close dropdown & remove focus state when disabled change

  external_React_namespaceObject.useEffect(function () {
    if (innerOpen && disabled) {
      setInnerOpen(false);
    }

    if (disabled) {
      setMockFocused(false);
    }
  }, [disabled]); // ============================ Keyboard ============================

  /**
   * We record input value here to check if can press to clean up by backspace
   * - null: Key is not down, this is reset by key up
   * - true: Search text is empty when first time backspace down
   * - false: Search text is not empty when first time backspace down
   */

  var _useLock = useLock(),
      _useLock2 = slicedToArray_slicedToArray(_useLock, 2),
      getClearLock = _useLock2[0],
      setClearLock = _useLock2[1]; // KeyDown


  var onInternalKeyDown = function onInternalKeyDown(event) {
    var clearLock = getClearLock();
    var which = event.which;

    if (which === es_KeyCode.ENTER) {
      // Do not submit form when type in the input
      if (mode !== 'combobox') {
        event.preventDefault();
      } // We only manage open state here, close logic should handle by list component


      if (!mergedOpen) {
        onToggleOpen(true);
      }
    }

    setClearLock(!!mergedSearchValue); // Remove value by `backspace`

    if (which === es_KeyCode.BACKSPACE && !clearLock && multiple && !mergedSearchValue && displayValues.length) {
      var cloneDisplayValues = _toConsumableArray(displayValues);

      var removedDisplayValue = null;

      for (var i = cloneDisplayValues.length - 1; i >= 0; i -= 1) {
        var current = cloneDisplayValues[i];

        if (!current.disabled) {
          cloneDisplayValues.splice(i, 1);
          removedDisplayValue = current;
          break;
        }
      }

      if (removedDisplayValue) {
        onDisplayValuesChange(cloneDisplayValues, {
          type: 'remove',
          values: [removedDisplayValue]
        });
      }
    }

    for (var _len = arguments.length, rest = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      rest[_key - 1] = arguments[_key];
    }

    if (mergedOpen && listRef.current) {
      var _listRef$current2;

      (_listRef$current2 = listRef.current).onKeyDown.apply(_listRef$current2, [event].concat(rest));
    }

    onKeyDown === null || onKeyDown === void 0 ? void 0 : onKeyDown.apply(void 0, [event].concat(rest));
  }; // KeyUp


  var onInternalKeyUp = function onInternalKeyUp(event) {
    for (var _len2 = arguments.length, rest = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
      rest[_key2 - 1] = arguments[_key2];
    }

    if (mergedOpen && listRef.current) {
      var _listRef$current3;

      (_listRef$current3 = listRef.current).onKeyUp.apply(_listRef$current3, [event].concat(rest));
    }

    onKeyUp === null || onKeyUp === void 0 ? void 0 : onKeyUp.apply(void 0, [event].concat(rest));
  }; // ============================ Selector ============================


  var onSelectorRemove = function onSelectorRemove(val) {
    var newValues = displayValues.filter(function (i) {
      return i !== val;
    });
    onDisplayValuesChange(newValues, {
      type: 'remove',
      values: [val]
    });
  }; // ========================== Focus / Blur ==========================

  /** Record real focus status */


  var focusRef = external_React_namespaceObject.useRef(false);

  var onContainerFocus = function onContainerFocus() {
    setMockFocused(true);

    if (!disabled) {
      if (onFocus && !focusRef.current) {
        onFocus.apply(void 0, arguments);
      } // `showAction` should handle `focus` if set


      if (showAction.includes('focus')) {
        onToggleOpen(true);
      }
    }

    focusRef.current = true;
  };

  var onContainerBlur = function onContainerBlur() {
    setMockFocused(false, function () {
      focusRef.current = false;
      onToggleOpen(false);
    });

    if (disabled) {
      return;
    }

    if (mergedSearchValue) {
      // `tags` mode should move `searchValue` into values
      if (mode === 'tags') {
        onSearch(mergedSearchValue, {
          source: 'submit'
        });
      } else if (mode === 'multiple') {
        // `multiple` mode only clean the search value but not trigger event
        onSearch('', {
          source: 'blur'
        });
      }
    }

    if (onBlur) {
      onBlur.apply(void 0, arguments);
    }
  }; // Give focus back of Select


  var activeTimeoutIds = [];
  external_React_namespaceObject.useEffect(function () {
    return function () {
      activeTimeoutIds.forEach(function (timeoutId) {
        return clearTimeout(timeoutId);
      });
      activeTimeoutIds.splice(0, activeTimeoutIds.length);
    };
  }, []);

  var onInternalMouseDown = function onInternalMouseDown(event) {
    var _triggerRef$current;

    var target = event.target;
    var popupElement = (_triggerRef$current = triggerRef.current) === null || _triggerRef$current === void 0 ? void 0 : _triggerRef$current.getPopupElement(); // We should give focus back to selector if clicked item is not focusable

    if (popupElement && popupElement.contains(target)) {
      var timeoutId = setTimeout(function () {
        var index = activeTimeoutIds.indexOf(timeoutId);

        if (index !== -1) {
          activeTimeoutIds.splice(index, 1);
        }

        cancelSetMockFocused();

        if (!mobile && !popupElement.contains(document.activeElement)) {
          var _selectorRef$current3;

          (_selectorRef$current3 = selectorRef.current) === null || _selectorRef$current3 === void 0 ? void 0 : _selectorRef$current3.focus();
        }
      });
      activeTimeoutIds.push(timeoutId);
    }

    for (var _len3 = arguments.length, restArgs = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
      restArgs[_key3 - 1] = arguments[_key3];
    }

    onMouseDown === null || onMouseDown === void 0 ? void 0 : onMouseDown.apply(void 0, [event].concat(restArgs));
  }; // ============================ Dropdown ============================


  var _React$useState3 = external_React_namespaceObject.useState(null),
      _React$useState4 = slicedToArray_slicedToArray(_React$useState3, 2),
      containerWidth = _React$useState4[0],
      setContainerWidth = _React$useState4[1];

  var _React$useState5 = external_React_namespaceObject.useState({}),
      _React$useState6 = slicedToArray_slicedToArray(_React$useState5, 2),
      forceUpdate = _React$useState6[1]; // We need force update here since popup dom is render async


  function onPopupMouseEnter() {
    forceUpdate({});
  }

  hooks_useLayoutEffect(function () {
    if (triggerOpen) {
      var _containerRef$current;

      var newWidth = Math.ceil((_containerRef$current = containerRef.current) === null || _containerRef$current === void 0 ? void 0 : _containerRef$current.offsetWidth);

      if (containerWidth !== newWidth && !Number.isNaN(newWidth)) {
        setContainerWidth(newWidth);
      }
    }
  }, [triggerOpen]); // Used for raw custom input trigger

  var onTriggerVisibleChange;

  if (customizeRawInputElement) {
    onTriggerVisibleChange = function onTriggerVisibleChange(newOpen) {
      onToggleOpen(newOpen);
    };
  } // Close when click on non-select element


  useSelectTriggerControl(function () {
    var _triggerRef$current2;

    return [containerRef.current, (_triggerRef$current2 = triggerRef.current) === null || _triggerRef$current2 === void 0 ? void 0 : _triggerRef$current2.getPopupElement()];
  }, triggerOpen, onToggleOpen, !!customizeRawInputElement); // ============================ Context =============================

  var baseSelectContext = external_React_namespaceObject.useMemo(function () {
    return _objectSpread2(_objectSpread2({}, props), {}, {
      notFoundContent: notFoundContent,
      open: mergedOpen,
      triggerOpen: triggerOpen,
      id: id,
      showSearch: mergedShowSearch,
      multiple: multiple,
      toggleOpen: onToggleOpen
    });
  }, [props, notFoundContent, triggerOpen, mergedOpen, id, mergedShowSearch, multiple, onToggleOpen]); // ==================================================================
  // ==                            Render                            ==
  // ==================================================================
  // ============================= Arrow ==============================

  var mergedShowArrow = showArrow !== undefined ? showArrow : loading || !multiple && mode !== 'combobox';
  var arrowNode;

  if (mergedShowArrow) {
    arrowNode = /*#__PURE__*/external_React_namespaceObject.createElement(es_TransBtn, {
      className: classnames_default()("".concat(prefixCls, "-arrow"), _defineProperty({}, "".concat(prefixCls, "-arrow-loading"), loading)),
      customizeIcon: inputIcon,
      customizeIconProps: {
        loading: loading,
        searchValue: mergedSearchValue,
        open: mergedOpen,
        focused: mockFocused,
        showSearch: mergedShowSearch
      }
    });
  } // ============================= Clear ==============================


  var clearNode;

  var onClearMouseDown = function onClearMouseDown() {
    onClear === null || onClear === void 0 ? void 0 : onClear();
    onDisplayValuesChange([], {
      type: 'clear',
      values: displayValues
    });
    onInternalSearch('', false, false);
  };

  if (!disabled && allowClear && (displayValues.length || mergedSearchValue)) {
    clearNode = /*#__PURE__*/external_React_namespaceObject.createElement(es_TransBtn, {
      className: "".concat(prefixCls, "-clear"),
      onMouseDown: onClearMouseDown,
      customizeIcon: clearIcon
    }, "\xD7");
  } // =========================== OptionList ===========================


  var optionList = /*#__PURE__*/external_React_namespaceObject.createElement(OptionList, {
    ref: listRef
  }); // ============================= Select =============================

  var mergedClassName = classnames_default()(prefixCls, className, (_classNames2 = {}, _defineProperty(_classNames2, "".concat(prefixCls, "-focused"), mockFocused), _defineProperty(_classNames2, "".concat(prefixCls, "-multiple"), multiple), _defineProperty(_classNames2, "".concat(prefixCls, "-single"), !multiple), _defineProperty(_classNames2, "".concat(prefixCls, "-allow-clear"), allowClear), _defineProperty(_classNames2, "".concat(prefixCls, "-show-arrow"), mergedShowArrow), _defineProperty(_classNames2, "".concat(prefixCls, "-disabled"), disabled), _defineProperty(_classNames2, "".concat(prefixCls, "-loading"), loading), _defineProperty(_classNames2, "".concat(prefixCls, "-open"), mergedOpen), _defineProperty(_classNames2, "".concat(prefixCls, "-customize-input"), customizeInputElement), _defineProperty(_classNames2, "".concat(prefixCls, "-show-search"), mergedShowSearch), _classNames2)); // >>> Selector

  var selectorNode = /*#__PURE__*/external_React_namespaceObject.createElement(es_SelectTrigger, {
    ref: triggerRef,
    disabled: disabled,
    prefixCls: prefixCls,
    visible: triggerOpen,
    popupElement: optionList,
    containerWidth: containerWidth,
    animation: animation,
    transitionName: transitionName,
    dropdownStyle: dropdownStyle,
    dropdownClassName: dropdownClassName,
    direction: direction,
    dropdownMatchSelectWidth: dropdownMatchSelectWidth,
    dropdownRender: dropdownRender,
    dropdownAlign: dropdownAlign,
    placement: placement,
    getPopupContainer: getPopupContainer,
    empty: emptyOptions,
    getTriggerDOMNode: function getTriggerDOMNode() {
      return selectorDomRef.current;
    },
    onPopupVisibleChange: onTriggerVisibleChange,
    onPopupMouseEnter: onPopupMouseEnter
  }, customizeRawInputElement ? /*#__PURE__*/external_React_namespaceObject.cloneElement(customizeRawInputElement, {
    ref: customizeRawInputRef
  }) : /*#__PURE__*/external_React_namespaceObject.createElement(es_Selector, _extends({}, props, {
    domRef: selectorDomRef,
    prefixCls: prefixCls,
    inputElement: customizeInputElement,
    ref: selectorRef,
    id: id,
    showSearch: mergedShowSearch,
    mode: mode,
    activeDescendantId: activeDescendantId,
    tagRender: tagRender,
    values: displayValues,
    open: mergedOpen,
    onToggleOpen: onToggleOpen,
    activeValue: activeValue,
    searchValue: mergedSearchValue,
    onSearch: onInternalSearch,
    onSearchSubmit: onInternalSearchSubmit,
    onRemove: onSelectorRemove,
    tokenWithEnter: tokenWithEnter
  }))); // >>> Render

  var renderNode; // Render raw

  if (customizeRawInputElement) {
    renderNode = selectorNode;
  } else {
    renderNode = /*#__PURE__*/external_React_namespaceObject.createElement("div", _extends({
      className: mergedClassName
    }, domProps, {
      ref: containerRef,
      onMouseDown: onInternalMouseDown,
      onKeyDown: onInternalKeyDown,
      onKeyUp: onInternalKeyUp,
      onFocus: onContainerFocus,
      onBlur: onContainerBlur
    }), mockFocused && !mergedOpen && /*#__PURE__*/external_React_namespaceObject.createElement("span", {
      style: {
        width: 0,
        height: 0,
        position: 'absolute',
        overflow: 'hidden',
        opacity: 0
      },
      "aria-live": "polite"
    }, "".concat(displayValues.map(function (_ref) {
      var label = _ref.label,
          value = _ref.value;
      return ['number', 'string'].includes(typeof_typeof(label)) ? label : value;
    }).join(', '))), selectorNode, arrowNode, clearNode);
  }

  return /*#__PURE__*/external_React_namespaceObject.createElement(BaseSelectContext.Provider, {
    value: baseSelectContext
  }, renderNode);
}); // Set display name for dev

if (false) {}

/* harmony default export */ const es_BaseSelect = (BaseSelect);
;// CONCATENATED MODULE: ./node_modules/rc-select/es/hooks/useCache.js


/**
 * Cache `value` related LabeledValue & options.
 */

/* harmony default export */ const useCache = (function (labeledValues, valueOptions) {
  var cacheRef = external_React_namespaceObject.useRef({
    values: new Map(),
    options: new Map()
  });
  var filledLabeledValues = external_React_namespaceObject.useMemo(function () {
    var _cacheRef$current = cacheRef.current,
        prevValueCache = _cacheRef$current.values,
        prevOptionCache = _cacheRef$current.options; // Fill label by cache

    var patchedValues = labeledValues.map(function (item) {
      if (item.label === undefined) {
        var _prevValueCache$get;

        return _objectSpread2(_objectSpread2({}, item), {}, {
          label: (_prevValueCache$get = prevValueCache.get(item.value)) === null || _prevValueCache$get === void 0 ? void 0 : _prevValueCache$get.label
        });
      }

      return item;
    }); // Refresh cache

    var valueCache = new Map();
    var optionCache = new Map();
    patchedValues.forEach(function (item) {
      valueCache.set(item.value, item);
      optionCache.set(item.value, valueOptions.get(item.value) || prevOptionCache.get(item.value));
    });
    cacheRef.current.values = valueCache;
    cacheRef.current.options = optionCache;
    return patchedValues;
  }, [labeledValues, valueOptions]);
  var getOption = external_React_namespaceObject.useCallback(function (val) {
    return valueOptions.get(val) || cacheRef.current.options.get(val);
  }, [valueOptions]);
  return [filledLabeledValues, getOption];
});
;// CONCATENATED MODULE: ./node_modules/rc-select/es/hooks/useFilterOptions.js






function includes(test, search) {
  return commonUtil_toArray(test).join('').toUpperCase().includes(search);
}

/* harmony default export */ const useFilterOptions = (function (options, fieldNames, searchValue, filterOption, optionFilterProp) {
  return external_React_namespaceObject.useMemo(function () {
    if (!searchValue || filterOption === false) {
      return options;
    }

    var fieldOptions = fieldNames.options,
        fieldLabel = fieldNames.label,
        fieldValue = fieldNames.value;
    var filteredOptions = [];
    var customizeFilter = typeof filterOption === 'function';
    var upperSearch = searchValue.toUpperCase();
    var filterFunc = customizeFilter ? filterOption : function (_, option) {
      // Use provided `optionFilterProp`
      if (optionFilterProp) {
        return includes(option[optionFilterProp], upperSearch);
      } // Auto select `label` or `value` by option type


      if (option[fieldOptions]) {
        // hack `fieldLabel` since `OptionGroup` children is not `label`
        return includes(option[fieldLabel !== 'children' ? fieldLabel : 'label'], upperSearch);
      }

      return includes(option[fieldValue], upperSearch);
    };
    var wrapOption = customizeFilter ? function (opt) {
      return injectPropsWithOption(opt);
    } : function (opt) {
      return opt;
    };
    options.forEach(function (item) {
      // Group should check child options
      if (item[fieldOptions]) {
        // Check group first
        var matchGroup = filterFunc(searchValue, wrapOption(item));

        if (matchGroup) {
          filteredOptions.push(item);
        } else {
          // Check option
          var subOptions = item[fieldOptions].filter(function (subItem) {
            return filterFunc(searchValue, wrapOption(subItem));
          });

          if (subOptions.length) {
            filteredOptions.push(_objectSpread2(_objectSpread2({}, item), {}, _defineProperty({}, fieldOptions, subOptions)));
          }
        }

        return;
      }

      if (filterFunc(searchValue, wrapOption(item))) {
        filteredOptions.push(item);
      }
    });
    return filteredOptions;
  }, [options, filterOption, optionFilterProp, searchValue, fieldNames]);
});
;// CONCATENATED MODULE: ./node_modules/rc-select/es/hooks/useId.js



var uuid = 0;
/** Is client side and not jsdom */

var useId_isBrowserClient =  true && canUseDom();
/** Get unique id for accessibility usage */

function getUUID() {
  var retId; // Test never reach

  /* istanbul ignore if */

  if (useId_isBrowserClient) {
    retId = uuid;
    uuid += 1;
  } else {
    retId = 'TEST_OR_SSR';
  }

  return retId;
}
function useId(id) {
  // Inner id for accessibility usage. Only work in client side
  var _React$useState = external_React_namespaceObject.useState(),
      _React$useState2 = slicedToArray_slicedToArray(_React$useState, 2),
      innerId = _React$useState2[0],
      setInnerId = _React$useState2[1];

  external_React_namespaceObject.useEffect(function () {
    setInnerId("rc_select_".concat(getUUID()));
  }, []);
  return id || innerId;
}
;// CONCATENATED MODULE: ./node_modules/rc-select/es/utils/legacyUtil.js


var legacyUtil_excluded = ["children", "value"],
    legacyUtil_excluded2 = ["children"];



function convertNodeToOption(node) {
  var key = node.key,
      _node$props = node.props,
      children = _node$props.children,
      value = _node$props.value,
      restProps = _objectWithoutProperties(_node$props, legacyUtil_excluded);

  return _objectSpread2({
    key: key,
    value: value !== undefined ? value : key,
    children: children
  }, restProps);
}

function legacyUtil_convertChildrenToData(nodes) {
  var optionOnly = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
  return toArray_toArray(nodes).map(function (node, index) {
    if (! /*#__PURE__*/external_React_namespaceObject.isValidElement(node) || !node.type) {
      return null;
    }

    var isSelectOptGroup = node.type.isSelectOptGroup,
        key = node.key,
        _node$props2 = node.props,
        children = _node$props2.children,
        restProps = _objectWithoutProperties(_node$props2, legacyUtil_excluded2);

    if (optionOnly || !isSelectOptGroup) {
      return convertNodeToOption(node);
    }

    return _objectSpread2(_objectSpread2({
      key: "__RC_SELECT_GRP__".concat(key === null ? index : key, "__"),
      label: key
    }, restProps), {}, {
      options: legacyUtil_convertChildrenToData(children)
    });
  }).filter(function (data) {
    return data;
  });
}
;// CONCATENATED MODULE: ./node_modules/rc-select/es/hooks/useOptions.js


/**
 * Parse `children` to `options` if `options` is not provided.
 * Then flatten the `options`.
 */

function useOptions(options, children, fieldNames, optionFilterProp, optionLabelProp) {
  return external_React_namespaceObject.useMemo(function () {
    var mergedOptions = options;
    var childrenAsData = !options;

    if (childrenAsData) {
      mergedOptions = legacyUtil_convertChildrenToData(children);
    }

    var valueOptions = new Map();
    var labelOptions = new Map();

    var setLabelOptions = function setLabelOptions(labelOptionsMap, option, key) {
      if (key && typeof key === 'string') {
        labelOptionsMap.set(option[key], option);
      }
    };

    function dig(optionList) {
      var isChildren = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      // for loop to speed up collection speed
      for (var i = 0; i < optionList.length; i += 1) {
        var option = optionList[i];

        if (!option[fieldNames.options] || isChildren) {
          valueOptions.set(option[fieldNames.value], option);
          setLabelOptions(labelOptions, option, fieldNames.label); // https://github.com/ant-design/ant-design/issues/35304

          setLabelOptions(labelOptions, option, optionFilterProp);
          setLabelOptions(labelOptions, option, optionLabelProp);
        } else {
          dig(option[fieldNames.options], true);
        }
      }
    }

    dig(mergedOptions);
    return {
      options: mergedOptions,
      valueOptions: valueOptions,
      labelOptions: labelOptions
    };
  }, [options, children, fieldNames, optionFilterProp, optionLabelProp]);
}
;// CONCATENATED MODULE: ./node_modules/rc-select/es/hooks/useRefFunc.js

/**
 * Same as `React.useCallback` but always return a memoized function
 * but redirect to real function.
 */

function useRefFunc(callback) {
  var funcRef = external_React_namespaceObject.useRef();
  funcRef.current = callback;
  var cacheFn = external_React_namespaceObject.useCallback(function () {
    return funcRef.current.apply(funcRef, arguments);
  }, []);
  return cacheFn;
}
;// CONCATENATED MODULE: ./node_modules/rc-select/es/OptGroup.js
/** This is a placeholder, not real render in dom */
var OptGroup = function OptGroup() {
  return null;
};

OptGroup.isSelectOptGroup = true;
/* harmony default export */ const es_OptGroup = (OptGroup);
;// CONCATENATED MODULE: ./node_modules/rc-select/es/Option.js
/** This is a placeholder, not real render in dom */
var Option = function Option() {
  return null;
};

Option.isSelectOption = true;
/* harmony default export */ const es_Option = (Option);
;// CONCATENATED MODULE: ./node_modules/rc-util/es/omit.js

function omit(obj, fields) {
  var clone = _objectSpread2({}, obj);

  if (Array.isArray(fields)) {
    fields.forEach(function (key) {
      delete clone[key];
    });
  }

  return clone;
}
;// CONCATENATED MODULE: ./node_modules/rc-virtual-list/es/Filler.js
function Filler_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function Filler_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? Filler_ownKeys(Object(source), !0).forEach(function (key) { Filler_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : Filler_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function Filler_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




/**
 * Fill component to provided the scroll content real height.
 */

var Filler = /*#__PURE__*/external_React_namespaceObject.forwardRef(function (_ref, ref) {
  var height = _ref.height,
      offset = _ref.offset,
      children = _ref.children,
      prefixCls = _ref.prefixCls,
      onInnerResize = _ref.onInnerResize;
  var outerStyle = {};
  var innerStyle = {
    display: 'flex',
    flexDirection: 'column'
  };

  if (offset !== undefined) {
    outerStyle = {
      height: height,
      position: 'relative',
      overflow: 'hidden'
    };
    innerStyle = Filler_objectSpread(Filler_objectSpread({}, innerStyle), {}, {
      transform: "translateY(".concat(offset, "px)"),
      position: 'absolute',
      left: 0,
      right: 0,
      top: 0
    });
  }

  return /*#__PURE__*/external_React_namespaceObject.createElement("div", {
    style: outerStyle
  }, /*#__PURE__*/external_React_namespaceObject.createElement(rc_resize_observer_es, {
    onResize: function onResize(_ref2) {
      var offsetHeight = _ref2.offsetHeight;

      if (offsetHeight && onInnerResize) {
        onInnerResize();
      }
    }
  }, /*#__PURE__*/external_React_namespaceObject.createElement("div", {
    style: innerStyle,
    className: classnames_default()(Filler_defineProperty({}, "".concat(prefixCls, "-holder-inner"), prefixCls)),
    ref: ref
  }, children)));
});
Filler.displayName = 'Filler';
/* harmony default export */ const es_Filler = (Filler);
;// CONCATENATED MODULE: ./node_modules/rc-virtual-list/es/ScrollBar.js
function ScrollBar_typeof(obj) { "@babel/helpers - typeof"; return ScrollBar_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, ScrollBar_typeof(obj); }

function ScrollBar_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function ScrollBar_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function ScrollBar_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function ScrollBar_createClass(Constructor, protoProps, staticProps) { if (protoProps) ScrollBar_defineProperties(Constructor.prototype, protoProps); if (staticProps) ScrollBar_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

function ScrollBar_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) ScrollBar_setPrototypeOf(subClass, superClass); }

function ScrollBar_setPrototypeOf(o, p) { ScrollBar_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return ScrollBar_setPrototypeOf(o, p); }

function ScrollBar_createSuper(Derived) { var hasNativeReflectConstruct = ScrollBar_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = ScrollBar_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = ScrollBar_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return ScrollBar_possibleConstructorReturn(this, result); }; }

function ScrollBar_possibleConstructorReturn(self, call) { if (call && (ScrollBar_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return ScrollBar_assertThisInitialized(self); }

function ScrollBar_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

function ScrollBar_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }

function ScrollBar_getPrototypeOf(o) { ScrollBar_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return ScrollBar_getPrototypeOf(o); }




var ScrollBar_MIN_SIZE = 20;

function getPageY(e) {
  return 'touches' in e ? e.touches[0].pageY : e.pageY;
}

var ScrollBar = /*#__PURE__*/function (_React$Component) {
  ScrollBar_inherits(ScrollBar, _React$Component);

  var _super = ScrollBar_createSuper(ScrollBar);

  function ScrollBar() {
    var _this;

    ScrollBar_classCallCheck(this, ScrollBar);

    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
      args[_key] = arguments[_key];
    }

    _this = _super.call.apply(_super, [this].concat(args));
    _this.moveRaf = null;
    _this.scrollbarRef = /*#__PURE__*/external_React_namespaceObject.createRef();
    _this.thumbRef = /*#__PURE__*/external_React_namespaceObject.createRef();
    _this.visibleTimeout = null;
    _this.state = {
      dragging: false,
      pageY: null,
      startTop: null,
      visible: false
    };

    _this.delayHidden = function () {
      clearTimeout(_this.visibleTimeout);

      _this.setState({
        visible: true
      });

      _this.visibleTimeout = setTimeout(function () {
        _this.setState({
          visible: false
        });
      }, 2000);
    };

    _this.onScrollbarTouchStart = function (e) {
      e.preventDefault();
    };

    _this.onContainerMouseDown = function (e) {
      e.stopPropagation();
      e.preventDefault();
    };

    _this.patchEvents = function () {
      window.addEventListener('mousemove', _this.onMouseMove);
      window.addEventListener('mouseup', _this.onMouseUp);

      _this.thumbRef.current.addEventListener('touchmove', _this.onMouseMove);

      _this.thumbRef.current.addEventListener('touchend', _this.onMouseUp);
    };

    _this.removeEvents = function () {
      var _this$scrollbarRef$cu;

      window.removeEventListener('mousemove', _this.onMouseMove);
      window.removeEventListener('mouseup', _this.onMouseUp);
      (_this$scrollbarRef$cu = _this.scrollbarRef.current) === null || _this$scrollbarRef$cu === void 0 ? void 0 : _this$scrollbarRef$cu.removeEventListener('touchstart', _this.onScrollbarTouchStart);

      if (_this.thumbRef.current) {
        _this.thumbRef.current.removeEventListener('touchstart', _this.onMouseDown);

        _this.thumbRef.current.removeEventListener('touchmove', _this.onMouseMove);

        _this.thumbRef.current.removeEventListener('touchend', _this.onMouseUp);
      }

      wrapperRaf.cancel(_this.moveRaf);
    };

    _this.onMouseDown = function (e) {
      var onStartMove = _this.props.onStartMove;

      _this.setState({
        dragging: true,
        pageY: getPageY(e),
        startTop: _this.getTop()
      });

      onStartMove();

      _this.patchEvents();

      e.stopPropagation();
      e.preventDefault();
    };

    _this.onMouseMove = function (e) {
      var _this$state = _this.state,
          dragging = _this$state.dragging,
          pageY = _this$state.pageY,
          startTop = _this$state.startTop;
      var onScroll = _this.props.onScroll;
      wrapperRaf.cancel(_this.moveRaf);

      if (dragging) {
        var offsetY = getPageY(e) - pageY;
        var newTop = startTop + offsetY;

        var enableScrollRange = _this.getEnableScrollRange();

        var enableHeightRange = _this.getEnableHeightRange();

        var ptg = enableHeightRange ? newTop / enableHeightRange : 0;
        var newScrollTop = Math.ceil(ptg * enableScrollRange);
        _this.moveRaf = wrapperRaf(function () {
          onScroll(newScrollTop);
        });
      }
    };

    _this.onMouseUp = function () {
      var onStopMove = _this.props.onStopMove;

      _this.setState({
        dragging: false
      });

      onStopMove();

      _this.removeEvents();
    };

    _this.getSpinHeight = function () {
      var _this$props = _this.props,
          height = _this$props.height,
          count = _this$props.count;
      var baseHeight = height / count * 10;
      baseHeight = Math.max(baseHeight, ScrollBar_MIN_SIZE);
      baseHeight = Math.min(baseHeight, height / 2);
      return Math.floor(baseHeight);
    };

    _this.getEnableScrollRange = function () {
      var _this$props2 = _this.props,
          scrollHeight = _this$props2.scrollHeight,
          height = _this$props2.height;
      return scrollHeight - height || 0;
    };

    _this.getEnableHeightRange = function () {
      var height = _this.props.height;

      var spinHeight = _this.getSpinHeight();

      return height - spinHeight || 0;
    };

    _this.getTop = function () {
      var scrollTop = _this.props.scrollTop;

      var enableScrollRange = _this.getEnableScrollRange();

      var enableHeightRange = _this.getEnableHeightRange();

      if (scrollTop === 0 || enableScrollRange === 0) {
        return 0;
      }

      var ptg = scrollTop / enableScrollRange;
      return ptg * enableHeightRange;
    };

    _this.showScroll = function () {
      var _this$props3 = _this.props,
          height = _this$props3.height,
          scrollHeight = _this$props3.scrollHeight;
      return scrollHeight > height;
    };

    return _this;
  }

  ScrollBar_createClass(ScrollBar, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.scrollbarRef.current.addEventListener('touchstart', this.onScrollbarTouchStart);
      this.thumbRef.current.addEventListener('touchstart', this.onMouseDown);
    }
  }, {
    key: "componentDidUpdate",
    value: function componentDidUpdate(prevProps) {
      if (prevProps.scrollTop !== this.props.scrollTop) {
        this.delayHidden();
      }
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.removeEvents();
      clearTimeout(this.visibleTimeout);
    }
  }, {
    key: "render",
    value: // ====================== Render =======================
    function render() {
      var _this$state2 = this.state,
          dragging = _this$state2.dragging,
          visible = _this$state2.visible;
      var prefixCls = this.props.prefixCls;
      var spinHeight = this.getSpinHeight();
      var top = this.getTop();
      var canScroll = this.showScroll();
      var mergedVisible = canScroll && visible;
      return /*#__PURE__*/external_React_namespaceObject.createElement("div", {
        ref: this.scrollbarRef,
        className: classnames_default()("".concat(prefixCls, "-scrollbar"), ScrollBar_defineProperty({}, "".concat(prefixCls, "-scrollbar-show"), canScroll)),
        style: {
          width: 8,
          top: 0,
          bottom: 0,
          right: 0,
          position: 'absolute',
          display: mergedVisible ? null : 'none'
        },
        onMouseDown: this.onContainerMouseDown,
        onMouseMove: this.delayHidden
      }, /*#__PURE__*/external_React_namespaceObject.createElement("div", {
        ref: this.thumbRef,
        className: classnames_default()("".concat(prefixCls, "-scrollbar-thumb"), ScrollBar_defineProperty({}, "".concat(prefixCls, "-scrollbar-thumb-moving"), dragging)),
        style: {
          width: '100%',
          height: spinHeight,
          top: top,
          left: 0,
          position: 'absolute',
          background: 'rgba(0, 0, 0, 0.5)',
          borderRadius: 99,
          cursor: 'pointer',
          userSelect: 'none'
        },
        onMouseDown: this.onMouseDown
      }));
    }
  }]);

  return ScrollBar;
}(external_React_namespaceObject.Component);


;// CONCATENATED MODULE: ./node_modules/rc-virtual-list/es/Item.js

function Item_Item(_ref) {
  var children = _ref.children,
      setRef = _ref.setRef;
  var refFunc = external_React_namespaceObject.useCallback(function (node) {
    setRef(node);
  }, []);
  return /*#__PURE__*/external_React_namespaceObject.cloneElement(children, {
    ref: refFunc
  });
}
;// CONCATENATED MODULE: ./node_modules/rc-virtual-list/es/hooks/useChildren.js


function useChildren(list, startIndex, endIndex, setNodeRef, renderFunc, _ref) {
  var getKey = _ref.getKey;
  return list.slice(startIndex, endIndex + 1).map(function (item, index) {
    var eleIndex = startIndex + index;
    var node = renderFunc(item, eleIndex, {// style: status === 'MEASURE_START' ? { visibility: 'hidden' } : {},
    });
    var key = getKey(item);
    return /*#__PURE__*/external_React_namespaceObject.createElement(Item_Item, {
      key: key,
      setRef: function setRef(ele) {
        return setNodeRef(item, ele);
      }
    }, node);
  });
}
;// CONCATENATED MODULE: ./node_modules/rc-virtual-list/es/utils/CacheMap.js
function CacheMap_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function CacheMap_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function CacheMap_createClass(Constructor, protoProps, staticProps) { if (protoProps) CacheMap_defineProperties(Constructor.prototype, protoProps); if (staticProps) CacheMap_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }

// Firefox has low performance of map.
var CacheMap = /*#__PURE__*/function () {
  function CacheMap() {
    CacheMap_classCallCheck(this, CacheMap);

    this.maps = void 0;
    this.maps = Object.create(null);
  }

  CacheMap_createClass(CacheMap, [{
    key: "set",
    value: function set(key, value) {
      this.maps[key] = value;
    }
  }, {
    key: "get",
    value: function get(key) {
      return this.maps[key];
    }
  }]);

  return CacheMap;
}();

/* harmony default export */ const utils_CacheMap = (CacheMap);
;// CONCATENATED MODULE: ./node_modules/rc-virtual-list/es/hooks/useHeights.js
function useHeights_slicedToArray(arr, i) { return useHeights_arrayWithHoles(arr) || useHeights_iterableToArrayLimit(arr, i) || useHeights_unsupportedIterableToArray(arr, i) || useHeights_nonIterableRest(); }

function useHeights_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function useHeights_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return useHeights_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return useHeights_arrayLikeToArray(o, minLen); }

function useHeights_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function useHeights_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function useHeights_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }






function useHeights(getKey, onItemAdd, onItemRemove) {
  var _React$useState = external_React_namespaceObject.useState(0),
      _React$useState2 = useHeights_slicedToArray(_React$useState, 2),
      updatedMark = _React$useState2[0],
      setUpdatedMark = _React$useState2[1];

  var instanceRef = (0,external_React_namespaceObject.useRef)(new Map());
  var heightsRef = (0,external_React_namespaceObject.useRef)(new utils_CacheMap());
  var collectRafRef = (0,external_React_namespaceObject.useRef)();

  function cancelRaf() {
    wrapperRaf.cancel(collectRafRef.current);
  }

  function collectHeight() {
    cancelRaf();
    collectRafRef.current = wrapperRaf(function () {
      instanceRef.current.forEach(function (element, key) {
        if (element && element.offsetParent) {
          var htmlElement = findDOMNode(element);
          var offsetHeight = htmlElement.offsetHeight;

          if (heightsRef.current.get(key) !== offsetHeight) {
            heightsRef.current.set(key, htmlElement.offsetHeight);
          }
        }
      }); // Always trigger update mark to tell parent that should re-calculate heights when resized

      setUpdatedMark(function (c) {
        return c + 1;
      });
    });
  }

  function setInstanceRef(item, instance) {
    var key = getKey(item);
    var origin = instanceRef.current.get(key);

    if (instance) {
      instanceRef.current.set(key, instance);
      collectHeight();
    } else {
      instanceRef.current.delete(key);
    } // Instance changed


    if (!origin !== !instance) {
      if (instance) {
        onItemAdd === null || onItemAdd === void 0 ? void 0 : onItemAdd(item);
      } else {
        onItemRemove === null || onItemRemove === void 0 ? void 0 : onItemRemove(item);
      }
    }
  }

  (0,external_React_namespaceObject.useEffect)(function () {
    return cancelRaf;
  }, []);
  return [setInstanceRef, collectHeight, heightsRef.current, updatedMark];
}
;// CONCATENATED MODULE: ./node_modules/rc-virtual-list/es/hooks/useScrollTo.js
function useScrollTo_typeof(obj) { "@babel/helpers - typeof"; return useScrollTo_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, useScrollTo_typeof(obj); }

/* eslint-disable no-param-reassign */


function useScrollTo(containerRef, data, heights, itemHeight, getKey, collectHeight, syncScrollTop, triggerFlash) {
  var scrollRef = external_React_namespaceObject.useRef();
  return function (arg) {
    // When not argument provided, we think dev may want to show the scrollbar
    if (arg === null || arg === undefined) {
      triggerFlash();
      return;
    } // Normal scroll logic


    wrapperRaf.cancel(scrollRef.current);

    if (typeof arg === 'number') {
      syncScrollTop(arg);
    } else if (arg && useScrollTo_typeof(arg) === 'object') {
      var index;
      var align = arg.align;

      if ('index' in arg) {
        index = arg.index;
      } else {
        index = data.findIndex(function (item) {
          return getKey(item) === arg.key;
        });
      }

      var _arg$offset = arg.offset,
          offset = _arg$offset === void 0 ? 0 : _arg$offset; // We will retry 3 times in case dynamic height shaking

      var syncScroll = function syncScroll(times, targetAlign) {
        if (times < 0 || !containerRef.current) return;
        var height = containerRef.current.clientHeight;
        var needCollectHeight = false;
        var newTargetAlign = targetAlign; // Go to next frame if height not exist

        if (height) {
          var mergedAlign = targetAlign || align; // Get top & bottom

          var stackTop = 0;
          var itemTop = 0;
          var itemBottom = 0;
          var maxLen = Math.min(data.length, index);

          for (var i = 0; i <= maxLen; i += 1) {
            var key = getKey(data[i]);
            itemTop = stackTop;
            var cacheHeight = heights.get(key);
            itemBottom = itemTop + (cacheHeight === undefined ? itemHeight : cacheHeight);
            stackTop = itemBottom;

            if (i === index && cacheHeight === undefined) {
              needCollectHeight = true;
            }
          } // Scroll to


          var targetTop = null;

          switch (mergedAlign) {
            case 'top':
              targetTop = itemTop - offset;
              break;

            case 'bottom':
              targetTop = itemBottom - height + offset;
              break;

            default:
              {
                var scrollTop = containerRef.current.scrollTop;
                var scrollBottom = scrollTop + height;

                if (itemTop < scrollTop) {
                  newTargetAlign = 'top';
                } else if (itemBottom > scrollBottom) {
                  newTargetAlign = 'bottom';
                }
              }
          }

          if (targetTop !== null && targetTop !== containerRef.current.scrollTop) {
            syncScrollTop(targetTop);
          }
        } // We will retry since element may not sync height as it described


        scrollRef.current = wrapperRaf(function () {
          if (needCollectHeight) {
            collectHeight();
          }

          syncScroll(times - 1, newTargetAlign);
        });
      };

      syncScroll(3);
    }
  };
}
;// CONCATENATED MODULE: ./node_modules/rc-virtual-list/es/utils/algorithmUtil.js
/**
 * Get index with specific start index one by one. e.g.
 * min: 3, max: 9, start: 6
 *
 * Return index is:
 * [0]: 6
 * [1]: 7
 * [2]: 5
 * [3]: 8
 * [4]: 4
 * [5]: 9
 * [6]: 3
 */
function getIndexByStartLoc(min, max, start, index) {
  var beforeCount = start - min;
  var afterCount = max - start;
  var balanceCount = Math.min(beforeCount, afterCount) * 2; // Balance

  if (index <= balanceCount) {
    var stepIndex = Math.floor(index / 2);

    if (index % 2) {
      return start + stepIndex + 1;
    }

    return start - stepIndex;
  } // One is out of range


  if (beforeCount > afterCount) {
    return start - (index - afterCount);
  }

  return start + (index - beforeCount);
}
/**
 * We assume that 2 list has only 1 item diff and others keeping the order.
 * So we can use dichotomy algorithm to find changed one.
 */

function findListDiffIndex(originList, targetList, getKey) {
  var originLen = originList.length;
  var targetLen = targetList.length;
  var shortList;
  var longList;

  if (originLen === 0 && targetLen === 0) {
    return null;
  }

  if (originLen < targetLen) {
    shortList = originList;
    longList = targetList;
  } else {
    shortList = targetList;
    longList = originList;
  }

  var notExistKey = {
    __EMPTY_ITEM__: true
  };

  function getItemKey(item) {
    if (item !== undefined) {
      return getKey(item);
    }

    return notExistKey;
  } // Loop to find diff one


  var diffIndex = null;
  var multiple = Math.abs(originLen - targetLen) !== 1;

  for (var i = 0; i < longList.length; i += 1) {
    var shortKey = getItemKey(shortList[i]);
    var longKey = getItemKey(longList[i]);

    if (shortKey !== longKey) {
      diffIndex = i;
      multiple = multiple || shortKey !== getItemKey(longList[i + 1]);
      break;
    }
  }

  return diffIndex === null ? null : {
    index: diffIndex,
    multiple: multiple
  };
}
;// CONCATENATED MODULE: ./node_modules/rc-virtual-list/es/hooks/useDiffItem.js
function useDiffItem_slicedToArray(arr, i) { return useDiffItem_arrayWithHoles(arr) || useDiffItem_iterableToArrayLimit(arr, i) || useDiffItem_unsupportedIterableToArray(arr, i) || useDiffItem_nonIterableRest(); }

function useDiffItem_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function useDiffItem_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return useDiffItem_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return useDiffItem_arrayLikeToArray(o, minLen); }

function useDiffItem_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function useDiffItem_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function useDiffItem_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }



function useDiffItem(data, getKey, onDiff) {
  var _React$useState = external_React_namespaceObject.useState(data),
      _React$useState2 = useDiffItem_slicedToArray(_React$useState, 2),
      prevData = _React$useState2[0],
      setPrevData = _React$useState2[1];

  var _React$useState3 = external_React_namespaceObject.useState(null),
      _React$useState4 = useDiffItem_slicedToArray(_React$useState3, 2),
      diffItem = _React$useState4[0],
      setDiffItem = _React$useState4[1];

  external_React_namespaceObject.useEffect(function () {
    var diff = findListDiffIndex(prevData || [], data || [], getKey);

    if ((diff === null || diff === void 0 ? void 0 : diff.index) !== undefined) {
      onDiff === null || onDiff === void 0 ? void 0 : onDiff(diff.index);
      setDiffItem(data[diff.index]);
    }

    setPrevData(data);
  }, [data]);
  return [diffItem];
}
;// CONCATENATED MODULE: ./node_modules/rc-virtual-list/es/utils/isFirefox.js
function isFirefox_typeof(obj) { "@babel/helpers - typeof"; return isFirefox_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, isFirefox_typeof(obj); }

var isFF = (typeof navigator === "undefined" ? "undefined" : isFirefox_typeof(navigator)) === 'object' && /Firefox/i.test(navigator.userAgent);
/* harmony default export */ const isFirefox = (isFF);
;// CONCATENATED MODULE: ./node_modules/rc-virtual-list/es/hooks/useOriginScroll.js

/* harmony default export */ const useOriginScroll = (function (isScrollAtTop, isScrollAtBottom) {
  // Do lock for a wheel when scrolling
  var lockRef = (0,external_React_namespaceObject.useRef)(false);
  var lockTimeoutRef = (0,external_React_namespaceObject.useRef)(null);

  function lockScroll() {
    clearTimeout(lockTimeoutRef.current);
    lockRef.current = true;
    lockTimeoutRef.current = setTimeout(function () {
      lockRef.current = false;
    }, 50);
  } // Pass to ref since global add is in closure


  var scrollPingRef = (0,external_React_namespaceObject.useRef)({
    top: isScrollAtTop,
    bottom: isScrollAtBottom
  });
  scrollPingRef.current.top = isScrollAtTop;
  scrollPingRef.current.bottom = isScrollAtBottom;
  return function (deltaY) {
    var smoothOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    var originScroll = // Pass origin wheel when on the top
    deltaY < 0 && scrollPingRef.current.top || // Pass origin wheel when on the bottom
    deltaY > 0 && scrollPingRef.current.bottom;

    if (smoothOffset && originScroll) {
      // No need lock anymore when it's smooth offset from touchMove interval
      clearTimeout(lockTimeoutRef.current);
      lockRef.current = false;
    } else if (!originScroll || lockRef.current) {
      lockScroll();
    }

    return !lockRef.current && originScroll;
  };
});
;// CONCATENATED MODULE: ./node_modules/rc-virtual-list/es/hooks/useFrameWheel.js




function useFrameWheel(inVirtual, isScrollAtTop, isScrollAtBottom, onWheelDelta) {
  var offsetRef = (0,external_React_namespaceObject.useRef)(0);
  var nextFrameRef = (0,external_React_namespaceObject.useRef)(null); // Firefox patch

  var wheelValueRef = (0,external_React_namespaceObject.useRef)(null);
  var isMouseScrollRef = (0,external_React_namespaceObject.useRef)(false); // Scroll status sync

  var originScroll = useOriginScroll(isScrollAtTop, isScrollAtBottom);

  function onWheel(event) {
    if (!inVirtual) return;
    wrapperRaf.cancel(nextFrameRef.current);
    var deltaY = event.deltaY;
    offsetRef.current += deltaY;
    wheelValueRef.current = deltaY; // Do nothing when scroll at the edge, Skip check when is in scroll

    if (originScroll(deltaY)) return; // Proxy of scroll events

    if (!isFirefox) {
      event.preventDefault();
    }

    nextFrameRef.current = wrapperRaf(function () {
      // Patch a multiple for Firefox to fix wheel number too small
      // ref: https://github.com/ant-design/ant-design/issues/26372#issuecomment-679460266
      var patchMultiple = isMouseScrollRef.current ? 10 : 1;
      onWheelDelta(offsetRef.current * patchMultiple);
      offsetRef.current = 0;
    });
  } // A patch for firefox


  function onFireFoxScroll(event) {
    if (!inVirtual) return;
    isMouseScrollRef.current = event.detail === wheelValueRef.current;
  }

  return [onWheel, onFireFoxScroll];
}
;// CONCATENATED MODULE: ./node_modules/rc-virtual-list/es/hooks/useMobileTouchMove.js


var SMOOTH_PTG = 14 / 15;
function useMobileTouchMove(inVirtual, listRef, callback) {
  var touchedRef = (0,external_React_namespaceObject.useRef)(false);
  var touchYRef = (0,external_React_namespaceObject.useRef)(0);
  var elementRef = (0,external_React_namespaceObject.useRef)(null); // Smooth scroll

  var intervalRef = (0,external_React_namespaceObject.useRef)(null);
  /* eslint-disable prefer-const */

  var cleanUpEvents;

  var onTouchMove = function onTouchMove(e) {
    if (touchedRef.current) {
      var currentY = Math.ceil(e.touches[0].pageY);
      var offsetY = touchYRef.current - currentY;
      touchYRef.current = currentY;

      if (callback(offsetY)) {
        e.preventDefault();
      } // Smooth interval


      clearInterval(intervalRef.current);
      intervalRef.current = setInterval(function () {
        offsetY *= SMOOTH_PTG;

        if (!callback(offsetY, true) || Math.abs(offsetY) <= 0.1) {
          clearInterval(intervalRef.current);
        }
      }, 16);
    }
  };

  var onTouchEnd = function onTouchEnd() {
    touchedRef.current = false;
    cleanUpEvents();
  };

  var onTouchStart = function onTouchStart(e) {
    cleanUpEvents();

    if (e.touches.length === 1 && !touchedRef.current) {
      touchedRef.current = true;
      touchYRef.current = Math.ceil(e.touches[0].pageY);
      elementRef.current = e.target;
      elementRef.current.addEventListener('touchmove', onTouchMove);
      elementRef.current.addEventListener('touchend', onTouchEnd);
    }
  };

  cleanUpEvents = function cleanUpEvents() {
    if (elementRef.current) {
      elementRef.current.removeEventListener('touchmove', onTouchMove);
      elementRef.current.removeEventListener('touchend', onTouchEnd);
    }
  };

  hooks_useLayoutEffect(function () {
    if (inVirtual) {
      listRef.current.addEventListener('touchstart', onTouchStart);
    }

    return function () {
      var _listRef$current;

      (_listRef$current = listRef.current) === null || _listRef$current === void 0 ? void 0 : _listRef$current.removeEventListener('touchstart', onTouchStart);
      cleanUpEvents();
      clearInterval(intervalRef.current);
    };
  }, [inVirtual]);
}
;// CONCATENATED MODULE: ./node_modules/rc-virtual-list/es/List.js
var List_excluded = ["prefixCls", "className", "height", "itemHeight", "fullHeight", "style", "data", "children", "itemKey", "virtual", "component", "onScroll", "onVisibleChange"];

function List_extends() { List_extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; }; return List_extends.apply(this, arguments); }

function List_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function List_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? List_ownKeys(Object(source), !0).forEach(function (key) { List_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : List_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }

function List_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function List_slicedToArray(arr, i) { return List_arrayWithHoles(arr) || List_iterableToArrayLimit(arr, i) || List_unsupportedIterableToArray(arr, i) || List_nonIterableRest(); }

function List_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }

function List_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return List_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return List_arrayLikeToArray(o, minLen); }

function List_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }

function List_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }

function List_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }

function List_objectWithoutProperties(source, excluded) { if (source == null) return {}; var target = List_objectWithoutPropertiesLoose(source, excluded); var key, i; if (Object.getOwnPropertySymbols) { var sourceSymbolKeys = Object.getOwnPropertySymbols(source); for (i = 0; i < sourceSymbolKeys.length; i++) { key = sourceSymbolKeys[i]; if (excluded.indexOf(key) >= 0) continue; if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue; target[key] = source[key]; } } return target; }

function List_objectWithoutPropertiesLoose(source, excluded) { if (source == null) return {}; var target = {}; var sourceKeys = Object.keys(source); var key, i; for (i = 0; i < sourceKeys.length; i++) { key = sourceKeys[i]; if (excluded.indexOf(key) >= 0) continue; target[key] = source[key]; } return target; }














var EMPTY_DATA = [];
var ScrollStyle = {
  overflowY: 'auto',
  overflowAnchor: 'none'
};
function RawList(props, ref) {
  var _props$prefixCls = props.prefixCls,
      prefixCls = _props$prefixCls === void 0 ? 'rc-virtual-list' : _props$prefixCls,
      className = props.className,
      height = props.height,
      itemHeight = props.itemHeight,
      _props$fullHeight = props.fullHeight,
      fullHeight = _props$fullHeight === void 0 ? true : _props$fullHeight,
      style = props.style,
      data = props.data,
      children = props.children,
      itemKey = props.itemKey,
      virtual = props.virtual,
      _props$component = props.component,
      Component = _props$component === void 0 ? 'div' : _props$component,
      onScroll = props.onScroll,
      onVisibleChange = props.onVisibleChange,
      restProps = List_objectWithoutProperties(props, List_excluded); // ================================= MISC =================================


  var useVirtual = !!(virtual !== false && height && itemHeight);
  var inVirtual = useVirtual && data && itemHeight * data.length > height;

  var _useState = (0,external_React_namespaceObject.useState)(0),
      _useState2 = List_slicedToArray(_useState, 2),
      scrollTop = _useState2[0],
      setScrollTop = _useState2[1];

  var _useState3 = (0,external_React_namespaceObject.useState)(false),
      _useState4 = List_slicedToArray(_useState3, 2),
      scrollMoving = _useState4[0],
      setScrollMoving = _useState4[1];

  var mergedClassName = classnames_default()(prefixCls, className);
  var mergedData = data || EMPTY_DATA;
  var componentRef = (0,external_React_namespaceObject.useRef)();
  var fillerInnerRef = (0,external_React_namespaceObject.useRef)();
  var scrollBarRef = (0,external_React_namespaceObject.useRef)(); // Hack on scrollbar to enable flash call
  // =============================== Item Key ===============================

  var getKey = external_React_namespaceObject.useCallback(function (item) {
    if (typeof itemKey === 'function') {
      return itemKey(item);
    }

    return item === null || item === void 0 ? void 0 : item[itemKey];
  }, [itemKey]);
  var sharedConfig = {
    getKey: getKey
  }; // ================================ Scroll ================================

  function syncScrollTop(newTop) {
    setScrollTop(function (origin) {
      var value;

      if (typeof newTop === 'function') {
        value = newTop(origin);
      } else {
        value = newTop;
      }

      var alignedTop = keepInRange(value);
      componentRef.current.scrollTop = alignedTop;
      return alignedTop;
    });
  } // ================================ Legacy ================================
  // Put ref here since the range is generate by follow


  var rangeRef = (0,external_React_namespaceObject.useRef)({
    start: 0,
    end: mergedData.length
  });
  var diffItemRef = (0,external_React_namespaceObject.useRef)();

  var _useDiffItem = useDiffItem(mergedData, getKey),
      _useDiffItem2 = List_slicedToArray(_useDiffItem, 1),
      diffItem = _useDiffItem2[0];

  diffItemRef.current = diffItem; // ================================ Height ================================

  var _useHeights = useHeights(getKey, null, null),
      _useHeights2 = List_slicedToArray(_useHeights, 4),
      setInstanceRef = _useHeights2[0],
      collectHeight = _useHeights2[1],
      heights = _useHeights2[2],
      heightUpdatedMark = _useHeights2[3]; // ========================== Visible Calculation =========================


  var _React$useMemo = external_React_namespaceObject.useMemo(function () {
    if (!useVirtual) {
      return {
        scrollHeight: undefined,
        start: 0,
        end: mergedData.length - 1,
        offset: undefined
      };
    } // Always use virtual scroll bar in avoid shaking


    // Always use virtual scroll bar in avoid shaking
    if (!inVirtual) {
      var _fillerInnerRef$curre;

      return {
        scrollHeight: ((_fillerInnerRef$curre = fillerInnerRef.current) === null || _fillerInnerRef$curre === void 0 ? void 0 : _fillerInnerRef$curre.offsetHeight) || 0,
        start: 0,
        end: mergedData.length - 1,
        offset: undefined
      };
    }

    var itemTop = 0;
    var startIndex;
    var startOffset;
    var endIndex;
    var dataLen = mergedData.length;

    for (var i = 0; i < dataLen; i += 1) {
      var item = mergedData[i];
      var key = getKey(item);
      var cacheHeight = heights.get(key);
      var currentItemBottom = itemTop + (cacheHeight === undefined ? itemHeight : cacheHeight); // Check item top in the range

      // Check item top in the range
      if (currentItemBottom >= scrollTop && startIndex === undefined) {
        startIndex = i;
        startOffset = itemTop;
      } // Check item bottom in the range. We will render additional one item for motion usage


      // Check item bottom in the range. We will render additional one item for motion usage
      if (currentItemBottom > scrollTop + height && endIndex === undefined) {
        endIndex = i;
      }

      itemTop = currentItemBottom;
    } // Fallback to normal if not match. This code should never reach

    /* istanbul ignore next */


    // Fallback to normal if not match. This code should never reach

    /* istanbul ignore next */
    if (startIndex === undefined) {
      startIndex = 0;
      startOffset = 0;
    }

    if (endIndex === undefined) {
      endIndex = mergedData.length - 1;
    } // Give cache to improve scroll experience


    // Give cache to improve scroll experience
    endIndex = Math.min(endIndex + 1, mergedData.length);
    return {
      scrollHeight: itemTop,
      start: startIndex,
      end: endIndex,
      offset: startOffset
    };
  }, [inVirtual, useVirtual, scrollTop, mergedData, heightUpdatedMark, height]),
      scrollHeight = _React$useMemo.scrollHeight,
      start = _React$useMemo.start,
      end = _React$useMemo.end,
      offset = _React$useMemo.offset;

  rangeRef.current.start = start;
  rangeRef.current.end = end; // =============================== In Range ===============================

  var maxScrollHeight = scrollHeight - height;
  var maxScrollHeightRef = (0,external_React_namespaceObject.useRef)(maxScrollHeight);
  maxScrollHeightRef.current = maxScrollHeight;

  function keepInRange(newScrollTop) {
    var newTop = newScrollTop;

    if (!Number.isNaN(maxScrollHeightRef.current)) {
      newTop = Math.min(newTop, maxScrollHeightRef.current);
    }

    newTop = Math.max(newTop, 0);
    return newTop;
  }

  var isScrollAtTop = scrollTop <= 0;
  var isScrollAtBottom = scrollTop >= maxScrollHeight;
  var originScroll = useOriginScroll(isScrollAtTop, isScrollAtBottom); // ================================ Scroll ================================

  function onScrollBar(newScrollTop) {
    var newTop = newScrollTop;
    syncScrollTop(newTop);
  } // When data size reduce. It may trigger native scroll event back to fit scroll position


  function onFallbackScroll(e) {
    var newScrollTop = e.currentTarget.scrollTop;

    if (newScrollTop !== scrollTop) {
      syncScrollTop(newScrollTop);
    } // Trigger origin onScroll


    onScroll === null || onScroll === void 0 ? void 0 : onScroll(e);
  } // Since this added in global,should use ref to keep update


  var _useFrameWheel = useFrameWheel(useVirtual, isScrollAtTop, isScrollAtBottom, function (offsetY) {
    syncScrollTop(function (top) {
      var newTop = top + offsetY;
      return newTop;
    });
  }),
      _useFrameWheel2 = List_slicedToArray(_useFrameWheel, 2),
      onRawWheel = _useFrameWheel2[0],
      onFireFoxScroll = _useFrameWheel2[1]; // Mobile touch move


  useMobileTouchMove(useVirtual, componentRef, function (deltaY, smoothOffset) {
    if (originScroll(deltaY, smoothOffset)) {
      return false;
    }

    onRawWheel({
      preventDefault: function preventDefault() {},
      deltaY: deltaY
    });
    return true;
  });
  hooks_useLayoutEffect(function () {
    // Firefox only
    function onMozMousePixelScroll(e) {
      if (useVirtual) {
        e.preventDefault();
      }
    }

    componentRef.current.addEventListener('wheel', onRawWheel);
    componentRef.current.addEventListener('DOMMouseScroll', onFireFoxScroll);
    componentRef.current.addEventListener('MozMousePixelScroll', onMozMousePixelScroll);
    return function () {
      if (componentRef.current) {
        componentRef.current.removeEventListener('wheel', onRawWheel);
        componentRef.current.removeEventListener('DOMMouseScroll', onFireFoxScroll);
        componentRef.current.removeEventListener('MozMousePixelScroll', onMozMousePixelScroll);
      }
    };
  }, [useVirtual]); // ================================= Ref ==================================

  var scrollTo = useScrollTo(componentRef, mergedData, heights, itemHeight, getKey, collectHeight, syncScrollTop, function () {
    var _scrollBarRef$current;

    (_scrollBarRef$current = scrollBarRef.current) === null || _scrollBarRef$current === void 0 ? void 0 : _scrollBarRef$current.delayHidden();
  });
  external_React_namespaceObject.useImperativeHandle(ref, function () {
    return {
      scrollTo: scrollTo
    };
  }); // ================================ Effect ================================

  /** We need told outside that some list not rendered */

  hooks_useLayoutEffect(function () {
    if (onVisibleChange) {
      var renderList = mergedData.slice(start, end + 1);
      onVisibleChange(renderList, mergedData);
    }
  }, [start, end, mergedData]); // ================================ Render ================================

  var listChildren = useChildren(mergedData, start, end, setInstanceRef, children, sharedConfig);
  var componentStyle = null;

  if (height) {
    componentStyle = List_objectSpread(List_defineProperty({}, fullHeight ? 'height' : 'maxHeight', height), ScrollStyle);

    if (useVirtual) {
      componentStyle.overflowY = 'hidden';

      if (scrollMoving) {
        componentStyle.pointerEvents = 'none';
      }
    }
  }

  return /*#__PURE__*/external_React_namespaceObject.createElement("div", List_extends({
    style: List_objectSpread(List_objectSpread({}, style), {}, {
      position: 'relative'
    }),
    className: mergedClassName
  }, restProps), /*#__PURE__*/external_React_namespaceObject.createElement(Component, {
    className: "".concat(prefixCls, "-holder"),
    style: componentStyle,
    ref: componentRef,
    onScroll: onFallbackScroll
  }, /*#__PURE__*/external_React_namespaceObject.createElement(es_Filler, {
    prefixCls: prefixCls,
    height: scrollHeight,
    offset: offset,
    onInnerResize: collectHeight,
    ref: fillerInnerRef
  }, listChildren)), useVirtual && /*#__PURE__*/external_React_namespaceObject.createElement(ScrollBar, {
    ref: scrollBarRef,
    prefixCls: prefixCls,
    scrollTop: scrollTop,
    height: height,
    scrollHeight: scrollHeight,
    count: mergedData.length,
    onScroll: onScrollBar,
    onStartMove: function onStartMove() {
      setScrollMoving(true);
    },
    onStopMove: function onStopMove() {
      setScrollMoving(false);
    }
  }));
}
var List_List = /*#__PURE__*/external_React_namespaceObject.forwardRef(RawList);
List_List.displayName = 'List';
/* harmony default export */ const es_List = (List_List);
;// CONCATENATED MODULE: ./node_modules/rc-virtual-list/es/index.js

/* harmony default export */ const rc_virtual_list_es = (es_List);
;// CONCATENATED MODULE: ./node_modules/rc-select/es/utils/platformUtil.js
/* istanbul ignore file */
function isPlatformMac() {
  return /(mac\sos|macintosh)/i.test(navigator.appVersion);
}
;// CONCATENATED MODULE: ./node_modules/rc-select/es/SelectContext.js

var SelectContext = /*#__PURE__*/external_React_namespaceObject.createContext(null);
/* harmony default export */ const es_SelectContext = (SelectContext);
;// CONCATENATED MODULE: ./node_modules/rc-select/es/OptionList.js





var OptionList_excluded = ["disabled", "title", "children", "style", "className"];













function isTitleType(content) {
  return typeof content === 'string' || typeof content === 'number';
}
/**
 * Using virtual list of option display.
 * Will fallback to dom if use customize render.
 */


var OptionList = function OptionList(_, ref) {
  var _useBaseProps = useBaseProps(),
      prefixCls = _useBaseProps.prefixCls,
      id = _useBaseProps.id,
      open = _useBaseProps.open,
      multiple = _useBaseProps.multiple,
      mode = _useBaseProps.mode,
      searchValue = _useBaseProps.searchValue,
      toggleOpen = _useBaseProps.toggleOpen,
      notFoundContent = _useBaseProps.notFoundContent,
      onPopupScroll = _useBaseProps.onPopupScroll;

  var _React$useContext = external_React_namespaceObject.useContext(es_SelectContext),
      flattenOptions = _React$useContext.flattenOptions,
      onActiveValue = _React$useContext.onActiveValue,
      defaultActiveFirstOption = _React$useContext.defaultActiveFirstOption,
      onSelect = _React$useContext.onSelect,
      menuItemSelectedIcon = _React$useContext.menuItemSelectedIcon,
      rawValues = _React$useContext.rawValues,
      fieldNames = _React$useContext.fieldNames,
      virtual = _React$useContext.virtual,
      listHeight = _React$useContext.listHeight,
      listItemHeight = _React$useContext.listItemHeight;

  var itemPrefixCls = "".concat(prefixCls, "-item");
  var memoFlattenOptions = useMemo(function () {
    return flattenOptions;
  }, [open, flattenOptions], function (prev, next) {
    return next[0] && prev[1] !== next[1];
  }); // =========================== List ===========================

  var listRef = external_React_namespaceObject.useRef(null);

  var onListMouseDown = function onListMouseDown(event) {
    event.preventDefault();
  };

  var scrollIntoView = function scrollIntoView(args) {
    if (listRef.current) {
      listRef.current.scrollTo(typeof args === 'number' ? {
        index: args
      } : args);
    }
  }; // ========================== Active ==========================


  var getEnabledActiveIndex = function getEnabledActiveIndex(index) {
    var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
    var len = memoFlattenOptions.length;

    for (var i = 0; i < len; i += 1) {
      var current = (index + i * offset + len) % len;
      var _memoFlattenOptions$c = memoFlattenOptions[current],
          group = _memoFlattenOptions$c.group,
          data = _memoFlattenOptions$c.data;

      if (!group && !data.disabled) {
        return current;
      }
    }

    return -1;
  };

  var _React$useState = external_React_namespaceObject.useState(function () {
    return getEnabledActiveIndex(0);
  }),
      _React$useState2 = slicedToArray_slicedToArray(_React$useState, 2),
      activeIndex = _React$useState2[0],
      setActiveIndex = _React$useState2[1];

  var setActive = function setActive(index) {
    var fromKeyboard = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
    setActiveIndex(index);
    var info = {
      source: fromKeyboard ? 'keyboard' : 'mouse'
    }; // Trigger active event

    var flattenItem = memoFlattenOptions[index];

    if (!flattenItem) {
      onActiveValue(null, -1, info);
      return;
    }

    onActiveValue(flattenItem.value, index, info);
  }; // Auto active first item when list length or searchValue changed


  (0,external_React_namespaceObject.useEffect)(function () {
    setActive(defaultActiveFirstOption !== false ? getEnabledActiveIndex(0) : -1);
  }, [memoFlattenOptions.length, searchValue]); // https://github.com/ant-design/ant-design/issues/34975

  var isSelected = external_React_namespaceObject.useCallback(function (value) {
    return rawValues.has(value) && mode !== 'combobox';
  }, [mode, _toConsumableArray(rawValues).toString()]); // Auto scroll to item position in single mode

  (0,external_React_namespaceObject.useEffect)(function () {
    /**
     * React will skip `onChange` when component update.
     * `setActive` function will call root accessibility state update which makes re-render.
     * So we need to delay to let Input component trigger onChange first.
     */
    var timeoutId = setTimeout(function () {
      if (!multiple && open && rawValues.size === 1) {
        var value = Array.from(rawValues)[0];
        var index = memoFlattenOptions.findIndex(function (_ref) {
          var data = _ref.data;
          return data.value === value;
        });

        if (index !== -1) {
          setActive(index);
          scrollIntoView(index);
        }
      }
    }); // Force trigger scrollbar visible when open

    if (open) {
      var _listRef$current;

      (_listRef$current = listRef.current) === null || _listRef$current === void 0 ? void 0 : _listRef$current.scrollTo(undefined);
    }

    return function () {
      return clearTimeout(timeoutId);
    };
  }, [open, searchValue]); // ========================== Values ==========================

  var onSelectValue = function onSelectValue(value) {
    if (value !== undefined) {
      onSelect(value, {
        selected: !rawValues.has(value)
      });
    } // Single mode should always close by select


    if (!multiple) {
      toggleOpen(false);
    }
  }; // ========================= Keyboard =========================


  external_React_namespaceObject.useImperativeHandle(ref, function () {
    return {
      onKeyDown: function onKeyDown(event) {
        var which = event.which,
            ctrlKey = event.ctrlKey;

        switch (which) {
          // >>> Arrow keys & ctrl + n/p on Mac
          case es_KeyCode.N:
          case es_KeyCode.P:
          case es_KeyCode.UP:
          case es_KeyCode.DOWN:
            {
              var offset = 0;

              if (which === es_KeyCode.UP) {
                offset = -1;
              } else if (which === es_KeyCode.DOWN) {
                offset = 1;
              } else if (isPlatformMac() && ctrlKey) {
                if (which === es_KeyCode.N) {
                  offset = 1;
                } else if (which === es_KeyCode.P) {
                  offset = -1;
                }
              }

              if (offset !== 0) {
                var nextActiveIndex = getEnabledActiveIndex(activeIndex + offset, offset);
                scrollIntoView(nextActiveIndex);
                setActive(nextActiveIndex, true);
              }

              break;
            }
          // >>> Select

          case es_KeyCode.ENTER:
            {
              // value
              var item = memoFlattenOptions[activeIndex];

              if (item && !item.data.disabled) {
                onSelectValue(item.value);
              } else {
                onSelectValue(undefined);
              }

              if (open) {
                event.preventDefault();
              }

              break;
            }
          // >>> Close

          case es_KeyCode.ESC:
            {
              toggleOpen(false);

              if (open) {
                event.stopPropagation();
              }
            }
        }
      },
      onKeyUp: function onKeyUp() {},
      scrollTo: function scrollTo(index) {
        scrollIntoView(index);
      }
    };
  }); // ========================== Render ==========================

  if (memoFlattenOptions.length === 0) {
    return /*#__PURE__*/external_React_namespaceObject.createElement("div", {
      role: "listbox",
      id: "".concat(id, "_list"),
      className: "".concat(itemPrefixCls, "-empty"),
      onMouseDown: onListMouseDown
    }, notFoundContent);
  }

  var omitFieldNameList = Object.keys(fieldNames).map(function (key) {
    return fieldNames[key];
  });

  var getLabel = function getLabel(item) {
    return item.label;
  };

  var renderItem = function renderItem(index) {
    var item = memoFlattenOptions[index];
    if (!item) return null;
    var itemData = item.data || {};
    var value = itemData.value;
    var group = item.group;
    var attrs = pickAttrs(itemData, true);
    var mergedLabel = getLabel(item);
    return item ? /*#__PURE__*/external_React_namespaceObject.createElement("div", _extends({
      "aria-label": typeof mergedLabel === 'string' && !group ? mergedLabel : null
    }, attrs, {
      key: index,
      role: group ? 'presentation' : 'option',
      id: "".concat(id, "_list_").concat(index),
      "aria-selected": isSelected(value)
    }), value) : null;
  };

  return /*#__PURE__*/external_React_namespaceObject.createElement(external_React_namespaceObject.Fragment, null, /*#__PURE__*/external_React_namespaceObject.createElement("div", {
    role: "listbox",
    id: "".concat(id, "_list"),
    style: {
      height: 0,
      width: 0,
      overflow: 'hidden'
    }
  }, renderItem(activeIndex - 1), renderItem(activeIndex), renderItem(activeIndex + 1)), /*#__PURE__*/external_React_namespaceObject.createElement(rc_virtual_list_es, {
    itemKey: "key",
    ref: listRef,
    data: memoFlattenOptions,
    height: listHeight,
    itemHeight: listItemHeight,
    fullHeight: false,
    onMouseDown: onListMouseDown,
    onScroll: onPopupScroll,
    virtual: virtual
  }, function (item, itemIndex) {
    var _classNames;

    var group = item.group,
        groupOption = item.groupOption,
        data = item.data,
        label = item.label,
        value = item.value;
    var key = data.key; // Group

    if (group) {
      var _data$title;

      var groupTitle = (_data$title = data.title) !== null && _data$title !== void 0 ? _data$title : isTitleType(label) ? label.toString() : undefined;
      return /*#__PURE__*/external_React_namespaceObject.createElement("div", {
        className: classnames_default()(itemPrefixCls, "".concat(itemPrefixCls, "-group")),
        title: groupTitle
      }, label !== undefined ? label : key);
    }

    var disabled = data.disabled,
        title = data.title,
        children = data.children,
        style = data.style,
        className = data.className,
        otherProps = _objectWithoutProperties(data, OptionList_excluded);

    var passedProps = omit(otherProps, omitFieldNameList); // Option

    var selected = isSelected(value);
    var optionPrefixCls = "".concat(itemPrefixCls, "-option");
    var optionClassName = classnames_default()(itemPrefixCls, optionPrefixCls, className, (_classNames = {}, _defineProperty(_classNames, "".concat(optionPrefixCls, "-grouped"), groupOption), _defineProperty(_classNames, "".concat(optionPrefixCls, "-active"), activeIndex === itemIndex && !disabled), _defineProperty(_classNames, "".concat(optionPrefixCls, "-disabled"), disabled), _defineProperty(_classNames, "".concat(optionPrefixCls, "-selected"), selected), _classNames));
    var mergedLabel = getLabel(item);
    var iconVisible = !menuItemSelectedIcon || typeof menuItemSelectedIcon === 'function' || selected; // https://github.com/ant-design/ant-design/issues/34145

    var content = typeof mergedLabel === 'number' ? mergedLabel : mergedLabel || value; // https://github.com/ant-design/ant-design/issues/26717

    var optionTitle = isTitleType(content) ? content.toString() : undefined;

    if (title !== undefined) {
      optionTitle = title;
    }

    return /*#__PURE__*/external_React_namespaceObject.createElement("div", _extends({}, pickAttrs(passedProps), {
      "aria-selected": selected,
      className: optionClassName,
      title: optionTitle,
      onMouseMove: function onMouseMove() {
        if (activeIndex === itemIndex || disabled) {
          return;
        }

        setActive(itemIndex);
      },
      onClick: function onClick() {
        if (!disabled) {
          onSelectValue(value);
        }
      },
      style: style
    }), /*#__PURE__*/external_React_namespaceObject.createElement("div", {
      className: "".concat(optionPrefixCls, "-content")
    }, content), /*#__PURE__*/external_React_namespaceObject.isValidElement(menuItemSelectedIcon) || selected, iconVisible && /*#__PURE__*/external_React_namespaceObject.createElement(es_TransBtn, {
      className: "".concat(itemPrefixCls, "-option-state"),
      customizeIcon: menuItemSelectedIcon,
      customizeIconProps: {
        isSelected: selected
      }
    }, selected ? '' : null));
  }));
};

var RefOptionList = /*#__PURE__*/external_React_namespaceObject.forwardRef(OptionList);
RefOptionList.displayName = 'OptionList';
/* harmony default export */ const es_OptionList = (RefOptionList);
;// CONCATENATED MODULE: ./node_modules/rc-select/es/utils/warningPropsUtil.js








function warningProps(props) {
  var mode = props.mode,
      options = props.options,
      children = props.children,
      backfill = props.backfill,
      allowClear = props.allowClear,
      placeholder = props.placeholder,
      getInputElement = props.getInputElement,
      showSearch = props.showSearch,
      onSearch = props.onSearch,
      defaultOpen = props.defaultOpen,
      autoFocus = props.autoFocus,
      labelInValue = props.labelInValue,
      value = props.value,
      inputValue = props.inputValue,
      optionLabelProp = props.optionLabelProp;
  var multiple = isMultiple(mode);
  var mergedShowSearch = showSearch !== undefined ? showSearch : multiple || mode === 'combobox';
  var mergedOptions = options || convertChildrenToData(children); // `tags` should not set option as disabled

  warning(mode !== 'tags' || mergedOptions.every(function (opt) {
    return !opt.disabled;
  }), 'Please avoid setting option to disabled in tags mode since user can always type text as tag.'); // `combobox` & `tags` should option be `string` type

  if (mode === 'tags' || mode === 'combobox') {
    var hasNumberValue = mergedOptions.some(function (item) {
      if (item.options) {
        return item.options.some(function (opt) {
          return typeof ('value' in opt ? opt.value : opt.key) === 'number';
        });
      }

      return typeof ('value' in item ? item.value : item.key) === 'number';
    });
    warning(!hasNumberValue, '`value` of Option should not use number type when `mode` is `tags` or `combobox`.');
  } // `combobox` should not use `optionLabelProp`


  warning(mode !== 'combobox' || !optionLabelProp, '`combobox` mode not support `optionLabelProp`. Please set `value` on Option directly.'); // Only `combobox` support `backfill`

  warning(mode === 'combobox' || !backfill, '`backfill` only works with `combobox` mode.'); // Only `combobox` support `getInputElement`

  warning(mode === 'combobox' || !getInputElement, '`getInputElement` only work with `combobox` mode.'); // Customize `getInputElement` should not use `allowClear` & `placeholder`

  noteOnce(mode !== 'combobox' || !getInputElement || !allowClear || !placeholder, 'Customize `getInputElement` should customize clear and placeholder logic instead of configuring `allowClear` and `placeholder`.'); // `onSearch` should use in `combobox` or `showSearch`

  if (onSearch && !mergedShowSearch && mode !== 'combobox' && mode !== 'tags') {
    warning(false, '`onSearch` should work with `showSearch` instead of use alone.');
  }

  noteOnce(!defaultOpen || autoFocus, '`defaultOpen` makes Select open without focus which means it will not close by click outside. You can set `autoFocus` if needed.');

  if (value !== undefined && value !== null) {
    var values = toArray(value);
    warning(!labelInValue || values.every(function (val) {
      return _typeof(val) === 'object' && ('key' in val || 'value' in val);
    }), '`value` should in shape of `{ value: string | number, label?: ReactNode }` when you set `labelInValue` to `true`');
    warning(!multiple || Array.isArray(value), '`value` should be array when `mode` is `multiple` or `tags`');
  } // Syntactic sugar should use correct children type


  if (children) {
    var invalidateChildType = null;
    toNodeArray(children).some(function (node) {
      if (! /*#__PURE__*/React.isValidElement(node) || !node.type) {
        return false;
      }

      var type = node.type;

      if (type.isSelectOption) {
        return false;
      }

      if (type.isSelectOptGroup) {
        var allChildrenValid = toNodeArray(node.props.children).every(function (subNode) {
          if (! /*#__PURE__*/React.isValidElement(subNode) || !node.type || subNode.type.isSelectOption) {
            return true;
          }

          invalidateChildType = subNode.type;
          return false;
        });

        if (allChildrenValid) {
          return false;
        }

        return true;
      }

      invalidateChildType = type;
      return true;
    });

    if (invalidateChildType) {
      warning(false, "`children` should be `Select.Option` or `Select.OptGroup` instead of `".concat(invalidateChildType.displayName || invalidateChildType.name || invalidateChildType, "`."));
    }

    warning(inputValue === undefined, '`inputValue` is deprecated, please use `searchValue` instead.');
  }
} // value in Select option should not be null
// note: OptGroup has options too


function warningNullOptions(options, fieldNames) {
  if (options) {
    var recursiveOptions = function recursiveOptions(optionsList) {
      var inGroup = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

      for (var i = 0; i < optionsList.length; i++) {
        var option = optionsList[i];

        if (option[fieldNames === null || fieldNames === void 0 ? void 0 : fieldNames.value] === null) {
          warning(false, '`value` in Select options should not be `null`.');
          return true;
        }

        if (!inGroup && Array.isArray(option[fieldNames === null || fieldNames === void 0 ? void 0 : fieldNames.options]) && recursiveOptions(option[fieldNames === null || fieldNames === void 0 ? void 0 : fieldNames.options], true)) {
          break;
        }
      }
    };

    recursiveOptions(options);
  }
}
/* harmony default export */ const warningPropsUtil = ((/* unused pure expression or super */ null && (warningProps)));
;// CONCATENATED MODULE: ./node_modules/rc-select/es/Select.js







var Select_excluded = ["id", "mode", "prefixCls", "backfill", "fieldNames", "inputValue", "searchValue", "onSearch", "autoClearSearchValue", "onSelect", "onDeselect", "dropdownMatchSelectWidth", "filterOption", "filterSort", "optionFilterProp", "optionLabelProp", "options", "children", "defaultActiveFirstOption", "menuItemSelectedIcon", "virtual", "listHeight", "listItemHeight", "value", "defaultValue", "labelInValue", "onChange"];

/**
 * To match accessibility requirement, we always provide an input in the component.
 * Other element will not set `tabIndex` to avoid `onBlur` sequence problem.
 * For focused select, we set `aria-live="polite"` to update the accessibility content.
 *
 * ref:
 * - keyboard: https://developer.mozilla.org/en-US/docs/Web/Accessibility/ARIA/Roles/listbox_role#Keyboard_interactions
 *
 * New api:
 * - listHeight
 * - listItemHeight
 * - component
 *
 * Remove deprecated api:
 * - multiple
 * - tags
 * - combobox
 * - firstActiveValue
 * - dropdownMenuStyle
 * - openClassName (Not list in api)
 *
 * Update:
 * - `backfill` only support `combobox` mode
 * - `combobox` mode not support `labelInValue` since it's meaningless
 * - `getInputElement` only support `combobox` mode
 * - `onChange` return OptionData instead of ReactNode
 * - `filterOption` `onChange` `onSelect` accept OptionData instead of ReactNode
 * - `combobox` mode trigger `onChange` will get `undefined` if no `value` match in Option
 * - `combobox` mode not support `optionLabelProp`
 */
















var OMIT_DOM_PROPS = ['inputValue'];

function isRawValue(value) {
  return !value || typeof_typeof(value) !== 'object';
}

var Select = /*#__PURE__*/external_React_namespaceObject.forwardRef(function (props, ref) {
  var id = props.id,
      mode = props.mode,
      _props$prefixCls = props.prefixCls,
      prefixCls = _props$prefixCls === void 0 ? 'rc-select' : _props$prefixCls,
      backfill = props.backfill,
      fieldNames = props.fieldNames,
      inputValue = props.inputValue,
      searchValue = props.searchValue,
      onSearch = props.onSearch,
      _props$autoClearSearc = props.autoClearSearchValue,
      autoClearSearchValue = _props$autoClearSearc === void 0 ? true : _props$autoClearSearc,
      onSelect = props.onSelect,
      onDeselect = props.onDeselect,
      _props$dropdownMatchS = props.dropdownMatchSelectWidth,
      dropdownMatchSelectWidth = _props$dropdownMatchS === void 0 ? true : _props$dropdownMatchS,
      filterOption = props.filterOption,
      filterSort = props.filterSort,
      optionFilterProp = props.optionFilterProp,
      optionLabelProp = props.optionLabelProp,
      options = props.options,
      children = props.children,
      defaultActiveFirstOption = props.defaultActiveFirstOption,
      menuItemSelectedIcon = props.menuItemSelectedIcon,
      virtual = props.virtual,
      _props$listHeight = props.listHeight,
      listHeight = _props$listHeight === void 0 ? 200 : _props$listHeight,
      _props$listItemHeight = props.listItemHeight,
      listItemHeight = _props$listItemHeight === void 0 ? 20 : _props$listItemHeight,
      value = props.value,
      defaultValue = props.defaultValue,
      labelInValue = props.labelInValue,
      onChange = props.onChange,
      restProps = _objectWithoutProperties(props, Select_excluded);

  var mergedId = useId(id);
  var multiple = BaseSelect_isMultiple(mode);
  var childrenAsData = !!(!options && children);
  var mergedFilterOption = external_React_namespaceObject.useMemo(function () {
    if (filterOption === undefined && mode === 'combobox') {
      return false;
    }

    return filterOption;
  }, [filterOption, mode]); // ========================= FieldNames =========================

  var mergedFieldNames = external_React_namespaceObject.useMemo(function () {
    return fillFieldNames(fieldNames, childrenAsData);
  },
  /* eslint-disable react-hooks/exhaustive-deps */
  [// We stringify fieldNames to avoid unnecessary re-renders.
  JSON.stringify(fieldNames), childrenAsData]); // =========================== Search ===========================

  var _useMergedState = useMergedState('', {
    value: searchValue !== undefined ? searchValue : inputValue,
    postState: function postState(search) {
      return search || '';
    }
  }),
      _useMergedState2 = slicedToArray_slicedToArray(_useMergedState, 2),
      mergedSearchValue = _useMergedState2[0],
      setSearchValue = _useMergedState2[1]; // =========================== Option ===========================


  var parsedOptions = useOptions(options, children, mergedFieldNames, optionFilterProp, optionLabelProp);
  var valueOptions = parsedOptions.valueOptions,
      labelOptions = parsedOptions.labelOptions,
      mergedOptions = parsedOptions.options; // ========================= Wrap Value =========================

  var convert2LabelValues = external_React_namespaceObject.useCallback(function (draftValues) {
    // Convert to array
    var valueList = commonUtil_toArray(draftValues); // Convert to labelInValue type

    return valueList.map(function (val) {
      var rawValue;
      var rawLabel;
      var rawKey;
      var rawDisabled; // Fill label & value

      if (isRawValue(val)) {
        rawValue = val;
      } else {
        var _val$value;

        rawKey = val.key;
        rawLabel = val.label;
        rawValue = (_val$value = val.value) !== null && _val$value !== void 0 ? _val$value : rawKey;
      }

      var option = valueOptions.get(rawValue);

      if (option) {
        var _option$key;

        // Fill missing props
        if (rawLabel === undefined) rawLabel = option === null || option === void 0 ? void 0 : option[optionLabelProp || mergedFieldNames.label];
        if (rawKey === undefined) rawKey = (_option$key = option === null || option === void 0 ? void 0 : option.key) !== null && _option$key !== void 0 ? _option$key : rawValue;
        rawDisabled = option === null || option === void 0 ? void 0 : option.disabled; // Warning if label not same as provided

        if (false) { var optionLabel; }
      }

      return {
        label: rawLabel,
        value: rawValue,
        key: rawKey,
        disabled: rawDisabled
      };
    });
  }, [mergedFieldNames, optionLabelProp, valueOptions]); // =========================== Values ===========================

  var _useMergedState3 = useMergedState(defaultValue, {
    value: value
  }),
      _useMergedState4 = slicedToArray_slicedToArray(_useMergedState3, 2),
      internalValue = _useMergedState4[0],
      setInternalValue = _useMergedState4[1]; // Merged value with LabelValueType


  var rawLabeledValues = external_React_namespaceObject.useMemo(function () {
    var _values$;

    var values = convert2LabelValues(internalValue); // combobox no need save value when it's empty

    if (mode === 'combobox' && !((_values$ = values[0]) === null || _values$ === void 0 ? void 0 : _values$.value)) {
      return [];
    }

    return values;
  }, [internalValue, convert2LabelValues, mode]); // Fill label with cache to avoid option remove

  var _useCache = useCache(rawLabeledValues, valueOptions),
      _useCache2 = slicedToArray_slicedToArray(_useCache, 2),
      mergedValues = _useCache2[0],
      getMixedOption = _useCache2[1];

  var displayValues = external_React_namespaceObject.useMemo(function () {
    // `null` need show as placeholder instead
    // https://github.com/ant-design/ant-design/issues/25057
    if (!mode && mergedValues.length === 1) {
      var firstValue = mergedValues[0];

      if (firstValue.value === null && (firstValue.label === null || firstValue.label === undefined)) {
        return [];
      }
    }

    return mergedValues.map(function (item) {
      var _item$label;

      return _objectSpread2(_objectSpread2({}, item), {}, {
        label: (_item$label = item.label) !== null && _item$label !== void 0 ? _item$label : item.value
      });
    });
  }, [mode, mergedValues]);
  /** Convert `displayValues` to raw value type set */

  var rawValues = external_React_namespaceObject.useMemo(function () {
    return new Set(mergedValues.map(function (val) {
      return val.value;
    }));
  }, [mergedValues]);
  external_React_namespaceObject.useEffect(function () {
    if (mode === 'combobox') {
      var _mergedValues$;

      var strValue = (_mergedValues$ = mergedValues[0]) === null || _mergedValues$ === void 0 ? void 0 : _mergedValues$.value;

      if (strValue !== undefined && strValue !== null) {
        setSearchValue(String(strValue));
      }
    }
  }, [mergedValues]); // ======================= Display Option =======================
  // Create a placeholder item if not exist in `options`

  var createTagOption = useRefFunc(function (val, label) {
    var _ref;

    var mergedLabel = label !== null && label !== void 0 ? label : val;
    return _ref = {}, _defineProperty(_ref, mergedFieldNames.value, val), _defineProperty(_ref, mergedFieldNames.label, mergedLabel), _ref;
  }); // Fill tag as option if mode is `tags`

  var filledTagOptions = external_React_namespaceObject.useMemo(function () {
    if (mode !== 'tags') {
      return mergedOptions;
    } // >>> Tag mode


    var cloneOptions = _toConsumableArray(mergedOptions); // Check if value exist in options (include new patch item)


    var existOptions = function existOptions(val) {
      return valueOptions.has(val);
    }; // Fill current value as option


    _toConsumableArray(mergedValues).sort(function (a, b) {
      return a.value < b.value ? -1 : 1;
    }).forEach(function (item) {
      var val = item.value;

      if (!existOptions(val)) {
        cloneOptions.push(createTagOption(val, item.label));
      }
    });

    return cloneOptions;
  }, [createTagOption, mergedOptions, valueOptions, mergedValues, mode]);
  var filteredOptions = useFilterOptions(filledTagOptions, mergedFieldNames, mergedSearchValue, mergedFilterOption, optionFilterProp); // Fill options with search value if needed

  var filledSearchOptions = external_React_namespaceObject.useMemo(function () {
    if (mode !== 'tags' || !mergedSearchValue || filteredOptions.some(function (item) {
      return item[optionFilterProp || 'value'] === mergedSearchValue;
    })) {
      return filteredOptions;
    } // Fill search value as option


    return [createTagOption(mergedSearchValue)].concat(_toConsumableArray(filteredOptions));
  }, [createTagOption, optionFilterProp, mode, filteredOptions, mergedSearchValue]);
  var orderedFilteredOptions = external_React_namespaceObject.useMemo(function () {
    if (!filterSort) {
      return filledSearchOptions;
    }

    return _toConsumableArray(filledSearchOptions).sort(function (a, b) {
      return filterSort(a, b);
    });
  }, [filledSearchOptions, filterSort]);
  var displayOptions = external_React_namespaceObject.useMemo(function () {
    return flattenOptions(orderedFilteredOptions, {
      fieldNames: mergedFieldNames,
      childrenAsData: childrenAsData
    });
  }, [orderedFilteredOptions, mergedFieldNames, childrenAsData]); // =========================== Change ===========================

  var triggerChange = function triggerChange(values) {
    var labeledValues = convert2LabelValues(values);
    setInternalValue(labeledValues);

    if (onChange && ( // Trigger event only when value changed
    labeledValues.length !== mergedValues.length || labeledValues.some(function (newVal, index) {
      var _mergedValues$index;

      return ((_mergedValues$index = mergedValues[index]) === null || _mergedValues$index === void 0 ? void 0 : _mergedValues$index.value) !== (newVal === null || newVal === void 0 ? void 0 : newVal.value);
    }))) {
      var returnValues = labelInValue ? labeledValues : labeledValues.map(function (v) {
        return v.value;
      });
      var returnOptions = labeledValues.map(function (v) {
        return injectPropsWithOption(getMixedOption(v.value));
      });
      onChange( // Value
      multiple ? returnValues : returnValues[0], // Option
      multiple ? returnOptions : returnOptions[0]);
    }
  }; // ======================= Accessibility ========================


  var _React$useState = external_React_namespaceObject.useState(null),
      _React$useState2 = slicedToArray_slicedToArray(_React$useState, 2),
      activeValue = _React$useState2[0],
      setActiveValue = _React$useState2[1];

  var _React$useState3 = external_React_namespaceObject.useState(0),
      _React$useState4 = slicedToArray_slicedToArray(_React$useState3, 2),
      accessibilityIndex = _React$useState4[0],
      setAccessibilityIndex = _React$useState4[1];

  var mergedDefaultActiveFirstOption = defaultActiveFirstOption !== undefined ? defaultActiveFirstOption : mode !== 'combobox';
  var onActiveValue = external_React_namespaceObject.useCallback(function (active, index) {
    var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},
        _ref2$source = _ref2.source,
        source = _ref2$source === void 0 ? 'keyboard' : _ref2$source;

    setAccessibilityIndex(index);

    if (backfill && mode === 'combobox' && active !== null && source === 'keyboard') {
      setActiveValue(String(active));
    }
  }, [backfill, mode]); // ========================= OptionList =========================

  var triggerSelect = function triggerSelect(val, selected) {
    var getSelectEnt = function getSelectEnt() {
      var _option$key2;

      var option = getMixedOption(val);
      return [labelInValue ? {
        label: option === null || option === void 0 ? void 0 : option[mergedFieldNames.label],
        value: val,
        key: (_option$key2 = option === null || option === void 0 ? void 0 : option.key) !== null && _option$key2 !== void 0 ? _option$key2 : val
      } : val, injectPropsWithOption(option)];
    };

    if (selected && onSelect) {
      var _getSelectEnt = getSelectEnt(),
          _getSelectEnt2 = slicedToArray_slicedToArray(_getSelectEnt, 2),
          wrappedValue = _getSelectEnt2[0],
          option = _getSelectEnt2[1];

      onSelect(wrappedValue, option);
    } else if (!selected && onDeselect) {
      var _getSelectEnt3 = getSelectEnt(),
          _getSelectEnt4 = slicedToArray_slicedToArray(_getSelectEnt3, 2),
          _wrappedValue = _getSelectEnt4[0],
          _option = _getSelectEnt4[1];

      onDeselect(_wrappedValue, _option);
    }
  }; // Used for OptionList selection


  var onInternalSelect = useRefFunc(function (val, info) {
    var cloneValues; // Single mode always trigger select only with option list

    var mergedSelect = multiple ? info.selected : true;

    if (mergedSelect) {
      cloneValues = multiple ? [].concat(_toConsumableArray(mergedValues), [val]) : [val];
    } else {
      cloneValues = mergedValues.filter(function (v) {
        return v.value !== val;
      });
    }

    triggerChange(cloneValues);
    triggerSelect(val, mergedSelect); // Clean search value if single or configured

    if (mode === 'combobox') {
      // setSearchValue(String(val));
      setActiveValue('');
    } else if (!BaseSelect_isMultiple || autoClearSearchValue) {
      setSearchValue('');
      setActiveValue('');
    }
  }); // ======================= Display Change =======================
  // BaseSelect display values change

  var onDisplayValuesChange = function onDisplayValuesChange(nextValues, info) {
    triggerChange(nextValues);

    if (info.type === 'remove' || info.type === 'clear') {
      info.values.forEach(function (item) {
        triggerSelect(item.value, false);
      });
    }
  }; // =========================== Search ===========================


  var onInternalSearch = function onInternalSearch(searchText, info) {
    setSearchValue(searchText);
    setActiveValue(null); // [Submit] Tag mode should flush input

    if (info.source === 'submit') {
      var formatted = (searchText || '').trim(); // prevent empty tags from appearing when you click the Enter button

      if (formatted) {
        var newRawValues = Array.from(new Set([].concat(_toConsumableArray(rawValues), [formatted])));
        triggerChange(newRawValues);
        triggerSelect(formatted, true);
        setSearchValue('');
      }

      return;
    }

    if (info.source !== 'blur') {
      if (mode === 'combobox') {
        triggerChange(searchText);
      }

      onSearch === null || onSearch === void 0 ? void 0 : onSearch(searchText);
    }
  };

  var onInternalSearchSplit = function onInternalSearchSplit(words) {
    var patchValues = words;

    if (mode !== 'tags') {
      patchValues = words.map(function (word) {
        var opt = labelOptions.get(word);
        return opt === null || opt === void 0 ? void 0 : opt.value;
      }).filter(function (val) {
        return val !== undefined;
      });
    }

    var newRawValues = Array.from(new Set([].concat(_toConsumableArray(rawValues), _toConsumableArray(patchValues))));
    triggerChange(newRawValues);
    newRawValues.forEach(function (newRawValue) {
      triggerSelect(newRawValue, true);
    });
  }; // ========================== Context ===========================


  var selectContext = external_React_namespaceObject.useMemo(function () {
    var realVirtual = virtual !== false && dropdownMatchSelectWidth !== false;
    return _objectSpread2(_objectSpread2({}, parsedOptions), {}, {
      flattenOptions: displayOptions,
      onActiveValue: onActiveValue,
      defaultActiveFirstOption: mergedDefaultActiveFirstOption,
      onSelect: onInternalSelect,
      menuItemSelectedIcon: menuItemSelectedIcon,
      rawValues: rawValues,
      fieldNames: mergedFieldNames,
      virtual: realVirtual,
      listHeight: listHeight,
      listItemHeight: listItemHeight,
      childrenAsData: childrenAsData
    });
  }, [parsedOptions, displayOptions, onActiveValue, mergedDefaultActiveFirstOption, onInternalSelect, menuItemSelectedIcon, rawValues, mergedFieldNames, virtual, dropdownMatchSelectWidth, listHeight, listItemHeight, childrenAsData]); // ========================== Warning ===========================

  if (false) {} // ==============================================================
  // ==                          Render                          ==
  // ==============================================================


  return /*#__PURE__*/external_React_namespaceObject.createElement(es_SelectContext.Provider, {
    value: selectContext
  }, /*#__PURE__*/external_React_namespaceObject.createElement(es_BaseSelect, _extends({}, restProps, {
    // >>> MISC
    id: mergedId,
    prefixCls: prefixCls,
    ref: ref,
    omitDomProps: OMIT_DOM_PROPS,
    mode: mode // >>> Values
    ,
    displayValues: displayValues,
    onDisplayValuesChange: onDisplayValuesChange // >>> Search
    ,
    searchValue: mergedSearchValue,
    onSearch: onInternalSearch,
    onSearchSplit: onInternalSearchSplit,
    dropdownMatchSelectWidth: dropdownMatchSelectWidth // >>> OptionList
    ,
    OptionList: es_OptionList,
    emptyOptions: !displayOptions.length // >>> Accessibility
    ,
    activeValue: activeValue,
    activeDescendantId: "".concat(mergedId, "_list_").concat(accessibilityIndex)
  })));
});

if (false) {}

var TypedSelect = Select;
TypedSelect.Option = es_Option;
TypedSelect.OptGroup = es_OptGroup;
/* harmony default export */ const es_Select = (TypedSelect);
;// CONCATENATED MODULE: ./node_modules/rc-select/es/index.js






/* harmony default export */ const rc_select_es = (es_Select);
;// CONCATENATED MODULE: ./src/blocks/components/select/index.js


function select_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function select_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? select_ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : select_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }






/* harmony default export */ const components_select = ((0,external_wp_compose_namespaceObject.compose)([external_wp_compose_namespaceObject.withInstanceId, with_device_type])(function (_ref) {
  var value = _ref.value,
      _ref$onChange = _ref.onChange,
      _onChange = _ref$onChange === void 0 ? function () {} : _ref$onChange,
      label = _ref.label,
      _ref$options = _ref.options,
      options = _ref$options === void 0 ? [] : _ref$options,
      _ref$inline = _ref.inline,
      inline = _ref$inline === void 0 ? false : _ref$inline,
      _ref$responsive = _ref.responsive,
      responsive = _ref$responsive === void 0 ? false : _ref$responsive,
      _ref$search = _ref.search,
      search = _ref$search === void 0 ? false : _ref$search,
      id = _ref.instanceId,
      DeviceSelector = _ref.deviceSelector,
      deviceType = _ref.deviceType;

  return /*#__PURE__*/React.createElement("div", {
    className: classnames_default()('blockart-control', 'blockart-select', {
      'blockart-responsive': responsive
    }, {
      'blockart-inline': inline && !responsive
    })
  }, /*#__PURE__*/React.createElement("div", {
    className: "blockart-control-head blockart-select-head"
  }, label && /*#__PURE__*/React.createElement("label", {
    htmlFor: "blockart-select-button-".concat(id),
    className: "blockart-control-label blockart-select-label"
  }, label), responsive && /*#__PURE__*/React.createElement(DeviceSelector, null)), /*#__PURE__*/React.createElement("div", {
    className: "blockart-control-body blockart-select-body"
  }, responsive ? ['desktop', 'tablet', 'mobile'].map(function (deviceKey) {
    var _value$deviceKey;

    return deviceKey === deviceType && /*#__PURE__*/React.createElement(rc_select_es, {
      key: deviceKey,
      dropdownClassName: "blockart-select-dropdown",
      className: "blockart-options",
      value: (_value$deviceKey = value === null || value === void 0 ? void 0 : value[deviceKey]) !== null && _value$deviceKey !== void 0 ? _value$deviceKey : '',
      showSearch: search,
      onChange: function onChange(val) {
        return _onChange(select_objectSpread(select_objectSpread({}, value), {}, _defineProperty({}, deviceKey, val)));
      }
    }, (options === null || options === void 0 ? void 0 : options.length) > 1 && options.map(function (option) {
      var _option$value, _option$value2, _option$label;

      return /*#__PURE__*/React.createElement(es_Option, {
        className: "blockart-option-item",
        value: (_option$value = option === null || option === void 0 ? void 0 : option.value) !== null && _option$value !== void 0 ? _option$value : '',
        key: (_option$value2 = option === null || option === void 0 ? void 0 : option.value) !== null && _option$value2 !== void 0 ? _option$value2 : ''
      }, (_option$label = option === null || option === void 0 ? void 0 : option.label) !== null && _option$label !== void 0 ? _option$label : '');
    }));
  }) : /*#__PURE__*/React.createElement(rc_select_es, {
    dropdownClassName: "blockart-select-dropdown",
    className: "blockart-options",
    value: value !== null && value !== void 0 ? value : '',
    showSearch: search,
    onChange: function onChange(val) {
      return _onChange(val);
    }
  }, (options === null || options === void 0 ? void 0 : options.length) > 1 && options.map(function (option) {
    var _option$value3, _option$value4, _option$label2;

    return /*#__PURE__*/React.createElement(es_Option, {
      className: "blockart-option-item",
      value: (_option$value3 = option === null || option === void 0 ? void 0 : option.value) !== null && _option$value3 !== void 0 ? _option$value3 : '',
      key: (_option$value4 = option === null || option === void 0 ? void 0 : option.value) !== null && _option$value4 !== void 0 ? _option$value4 : ''
    }, (_option$label2 = option === null || option === void 0 ? void 0 : option.label) !== null && _option$label2 !== void 0 ? _option$label2 : '');
  }))));
}));
;// CONCATENATED MODULE: ./src/blocks/components/slider/index.js










/* eslint-disable no-nested-ternary */

/* harmony default export */ const slider = ((0,external_wp_compose_namespaceObject.compose)([with_device_type, external_wp_compose_namespaceObject.withInstanceId])(function (_ref) {
  var total = _ref.value,
      _ref$onChange = _ref.onChange,
      onChange = _ref$onChange === void 0 ? function () {} : _ref$onChange,
      _ref$responsive = _ref.responsive,
      responsive = _ref$responsive === void 0 ? false : _ref$responsive,
      label = _ref.label,
      _ref$units = _ref.units,
      units = _ref$units === void 0 ? [] : _ref$units,
      _ref$min = _ref.min,
      min = _ref$min === void 0 ? -Infinity : _ref$min,
      _ref$max = _ref.max,
      max = _ref$max === void 0 ? Infinity : _ref$max,
      _ref$step = _ref.step,
      step = _ref$step === void 0 ? 0.01 : _ref$step,
      _ref$inline = _ref.inline,
      inline = _ref$inline === void 0 ? false : _ref$inline,
      _ref$defaultUnit = _ref.defaultUnit,
      defaultUnit = _ref$defaultUnit === void 0 ? 'px' : _ref$defaultUnit,
      _ref$showUnit = _ref.showUnit,
      showUnit = _ref$showUnit === void 0 ? false : _ref$showUnit,
      id = _ref.instanceId,
      deviceType = _ref.deviceType,
      DeviceSelector = _ref.deviceSelector;

  var _useState = (0,external_wp_element_namespaceObject.useState)(false),
      _useState2 = slicedToArray_slicedToArray(_useState, 2),
      isOpen = _useState2[0],
      setIsOpen = _useState2[1];

  var unitSelectRef = (0,external_wp_element_namespaceObject.useRef)();
  use_click_outside(unitSelectRef, function () {
    return setIsOpen(false);
  });
  var currentUnit = (0,external_wp_element_namespaceObject.useMemo)(function () {
    if (total) {
      if (responsive) {
        return total[deviceType] ? total[deviceType].unit ? total[deviceType].unit : defaultUnit : defaultUnit;
      }

      return total.unit || defaultUnit;
    }

    return defaultUnit;
  }, [total, deviceType]);
  var currentValue = (0,external_wp_element_namespaceObject.useMemo)(function () {
    if (total && Object.keys(total).length > 0) {
      if (responsive) {
        if (units.length > 0) {
          return total[deviceType] ? total[deviceType].value || 0 === total[deviceType].value ? total[deviceType].value : '' : '';
        }

        return total[deviceType] || 0 === total[deviceType] ? total[deviceType] : '';
      }

      return total.value || 0 === total.value ? total.value : '';
    }

    return total || 0 === total ? total : '';
  }, [total, deviceType]);
  var inputAttrs = (0,external_wp_element_namespaceObject.useMemo)(function () {
    var inputMin = min,
        inputMax = max,
        inputStep = step;

    if ('%' === currentUnit || 'vh' === currentUnit || 'vw' === currentUnit) {
      inputMin = 0;
      inputMax = 100;
    }

    if ('em' === currentUnit || 'rem' === currentUnit) {
      inputMin = 0;
      inputMax = 20;
      inputStep = 0.01;
    }

    if (units.length > 0 && 'px' === currentUnit) {
      inputStep = 1;
    }

    return {
      min: inputMin,
      max: inputMax,
      step: inputStep
    };
  }, [currentUnit]);

  var setSettings = function setSettings(val, prop) {
    var _total$deviceType;

    val = Number.isNaN(val) ? undefined : val;
    val = val < inputAttrs.min ? inputAttrs.min : val;
    val = val > inputAttrs.max ? inputAttrs.max : val;
    var data = units.length > 0 ? _defineProperty({}, prop, val) : val;

    if (units.length > 0 && 'unit' === prop) {
      data.value = '';
    }

    data = units.length > 0 ? Object.assign({}, responsive ? (_total$deviceType = total === null || total === void 0 ? void 0 : total[deviceType]) !== null && _total$deviceType !== void 0 ? _total$deviceType : {} : total, data) : val;

    if (units.length > 0 && (!data.unit || !total[deviceType] || !total[deviceType].unit)) {
      data.unit = data.unit || defaultUnit;
    }

    onChange(data.unit || responsive ? Object.assign({}, total, responsive ? _defineProperty({}, deviceType, data) : data) : data);
    setIsOpen(false);
  };

  return /*#__PURE__*/React.createElement("div", {
    className: classnames_default()('blockart-control', 'blockart-slider', {
      'blockart-responsive': responsive,
      'blockart-inline': !responsive && !units && inline
    })
  }, /*#__PURE__*/React.createElement("div", {
    className: "blockart-control-head blockart-slider-head"
  }, label && /*#__PURE__*/React.createElement("label", {
    htmlFor: "blockart-range-".concat(id),
    className: "blockart-control-label blockart-slider-label"
  }, label), responsive && /*#__PURE__*/React.createElement(DeviceSelector, null), units.length > 0 && /*#__PURE__*/React.createElement("div", {
    className: "blockart-units",
    ref: unitSelectRef
  }, /*#__PURE__*/React.createElement("button", {
    className: "blockart-units-btn",
    onClick: function onClick() {
      return setIsOpen(!isOpen);
    },
    "aria-expanded": isOpen
  }, currentUnit), units && units.length > 1 && isOpen && /*#__PURE__*/React.createElement("ul", {
    className: "blockart-units-menu",
    "aria-hidden": !isOpen
  }, units.filter(function (unit) {
    return unit !== currentUnit;
  }).map(function (unit) {
    return /*#__PURE__*/React.createElement("li", {
      className: "blockart-unit",
      key: unit
    }, /*#__PURE__*/React.createElement("button", {
      onClick: function onClick() {
        return setSettings(unit, 'unit');
      }
    }, unit));
  }))), units.length === 0 && showUnit && /*#__PURE__*/React.createElement("div", {
    className: "blockart-units",
    ref: unitSelectRef
  }, /*#__PURE__*/React.createElement("button", {
    className: "blockart-units-btn",
    onClick: function onClick() {
      return setIsOpen(!isOpen);
    },
    "aria-expanded": isOpen,
    "data-test": "one"
  }, currentUnit))), /*#__PURE__*/React.createElement("div", {
    className: "blockart-control-body blockart-slider-body"
  }, responsive ? ['desktop', 'tablet', 'mobile'].map(function (deviceKey) {
    return deviceKey === deviceType && /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.RangeControl, _extends({
      key: deviceKey,
      value: currentValue,
      onChange: function onChange(val) {
        return setSettings(val, 'value');
      }
    }, inputAttrs, {
      className: "blockart-range",
      allowReset: false
    }));
  }) : /*#__PURE__*/React.createElement("div", {
    className: "blockart-slider-container"
  }, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.RangeControl, _extends({
    value: currentValue,
    onChange: function onChange(val) {
      return setSettings(val, 'value');
    }
  }, inputAttrs, {
    className: "blockart-range",
    allowReset: false
  })))));
}));
;// CONCATENATED MODULE: ./src/blocks/components/pop-over/index.js







/* harmony default export */ const pop_over = ((0,external_wp_compose_namespaceObject.withInstanceId)(function (_ref) {
  var label = _ref.label,
      children = _ref.children,
      id = _ref.instanceId;

  var _useState = (0,external_wp_element_namespaceObject.useState)(false),
      _useState2 = slicedToArray_slicedToArray(_useState, 2),
      isOpen = _useState2[0],
      setIsOpen = _useState2[1];

  var toggleRef = (0,external_wp_element_namespaceObject.useRef)();
  return /*#__PURE__*/React.createElement("div", {
    className: "blockart-control blockart-pop-over"
  }, /*#__PURE__*/React.createElement("div", {
    className: "blockart-control-head blockart-pop-over-head"
  }, label && /*#__PURE__*/React.createElement("label", {
    htmlFor: "blockart-pop-over-".concat(id),
    className: "blockart-control-label blockart-pop-over-label"
  }, label), /*#__PURE__*/React.createElement("button", {
    ref: toggleRef,
    id: "blockart-pop-over-".concat(id),
    onClick: function onClick() {
      return setIsOpen(!isOpen);
    },
    className: "blockart-pop-over-toggle-button"
  }, /*#__PURE__*/React.createElement(components_icon, {
    type: "controlIcon",
    name: "pencil",
    size: 15
  }))), isOpen && /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Popover, {
    position: "bottom center",
    onFocusOutside: function onFocusOutside(e) {
      if (e.relatedTarget !== toggleRef.current) {
        setIsOpen(false);
      }
    },
    focusOnMount: "container"
  }, /*#__PURE__*/React.createElement("div", {
    className: classnames_default()('blockart-control-body', 'blockart-pop-over-body', {
      'is-open': isOpen
    })
  }, children || '')));
}));
;// CONCATENATED MODULE: ./src/blocks/components/panel/index.js
function panel_createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = panel_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function panel_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return panel_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return panel_arrayLikeToArray(o, minLen); }

function panel_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }







/* harmony default export */ const panel = ((0,external_wp_data_namespaceObject.withSelect)(function (select) {
  return {
    block: select('core/block-editor').getSelectedBlock()
  };
})(function (_ref) {
  var children = _ref.children,
      title = _ref.title,
      _ref$block = _ref.block,
      _ref$block$name = _ref$block.name,
      name = _ref$block$name === void 0 ? '' : _ref$block$name,
      _ref$block$attributes = _ref$block.attributes.clientId,
      clientId = _ref$block$attributes === void 0 ? '' : _ref$block$attributes,
      _ref$initialOpen = _ref.initialOpen,
      initialOpen = _ref$initialOpen === void 0 ? false : _ref$initialOpen;
  var panel = (0,external_wp_element_namespaceObject.useRef)();
  var id = name + '/' + clientId;

  var onToggle = function onToggle() {
    var _panel$current, _parent$dataset;

    var siblings = getSiblings(panel.current);

    if (siblings !== null && siblings !== void 0 && siblings.length) {
      var _iterator = panel_createForOfIteratorHelper(siblings),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _body$classList;

          var sibling = _step.value;
          var body = sibling.querySelector('.blockart-panel-body');

          if (body !== null && body !== void 0 && (_body$classList = body.classList) !== null && _body$classList !== void 0 && _body$classList.contains('is-opened')) {
            var _sibling$querySelecto;

            (_sibling$querySelecto = sibling.querySelector('.components-panel__body-toggle')) === null || _sibling$querySelecto === void 0 ? void 0 : _sibling$querySelecto.click();
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }

    var parent = (_panel$current = panel.current) === null || _panel$current === void 0 ? void 0 : _panel$current.closest('[data-inspector-tab]');

    if (parent !== null && parent !== void 0 && (_parent$dataset = parent.dataset) !== null && _parent$dataset !== void 0 && _parent$dataset.inspectorTab) {
      inspectorTabState.set(id, {
        tab: parent.dataset.inspectorTab,
        panel: title
      });
    }
  };

  (0,external_wp_element_namespaceObject.useEffect)(function () {
    var _inspectorTabState$ge, _panel$current2, _panel$current2$close, _panel$current2$close2, _inspectorTabState$ge2;

    if (((_inspectorTabState$ge = inspectorTabState.get(id)) === null || _inspectorTabState$ge === void 0 ? void 0 : _inspectorTabState$ge.tab) === ((_panel$current2 = panel.current) === null || _panel$current2 === void 0 ? void 0 : (_panel$current2$close = _panel$current2.closest('[data-inspector-tab]')) === null || _panel$current2$close === void 0 ? void 0 : (_panel$current2$close2 = _panel$current2$close.dataset) === null || _panel$current2$close2 === void 0 ? void 0 : _panel$current2$close2.inspectorTab) && ((_inspectorTabState$ge2 = inspectorTabState.get(id)) === null || _inspectorTabState$ge2 === void 0 ? void 0 : _inspectorTabState$ge2.panel) === title) {
      var _panel$current3, _panel$current3$query;

      (_panel$current3 = panel.current) === null || _panel$current3 === void 0 ? void 0 : (_panel$current3$query = _panel$current3.querySelector('.components-panel__body-toggle')) === null || _panel$current3$query === void 0 ? void 0 : _panel$current3$query.click();
    }
  }, []);
  return /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Panel, {
    className: "blockart-panel",
    ref: panel
  }, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.PanelBody, {
    className: "blockart-panel-body",
    title: title !== null && title !== void 0 ? title : 'Panel',
    onToggle: onToggle,
    initialOpen: initialOpen
  }, children));
}));
;// CONCATENATED MODULE: ./src/blocks/components/dimensions/index.js












/* harmony default export */ const dimensions = ((0,external_wp_compose_namespaceObject.compose)([with_device_type, external_wp_compose_namespaceObject.withInstanceId])(function (_ref) {
  var _ref$value = _ref.value,
      total = _ref$value === void 0 ? {} : _ref$value,
      _ref$onChange = _ref.onChange,
      onChange = _ref$onChange === void 0 ? function () {} : _ref$onChange,
      _ref$responsive = _ref.responsive,
      responsive = _ref$responsive === void 0 ? false : _ref$responsive,
      label = _ref.label,
      _ref$units = _ref.units,
      units = _ref$units === void 0 ? [] : _ref$units,
      _ref$min = _ref.min,
      min = _ref$min === void 0 ? -Infinity : _ref$min,
      _ref$max = _ref.max,
      max = _ref$max === void 0 ? Infinity : _ref$max,
      _ref$step = _ref.step,
      step = _ref$step === void 0 ? 0.01 : _ref$step,
      _ref$defaultUnit = _ref.defaultUnit,
      defaultUnit = _ref$defaultUnit === void 0 ? 'px' : _ref$defaultUnit,
      _ref$type = _ref.type,
      type = _ref$type === void 0 ? '' : _ref$type,
      id = _ref.instanceId,
      deviceType = _ref.deviceType,
      DeviceSelector = _ref.deviceSelector;

  var _useState = (0,external_wp_element_namespaceObject.useState)(false),
      _useState2 = slicedToArray_slicedToArray(_useState, 2),
      isOpen = _useState2[0],
      setIsOpen = _useState2[1];

  var unitSelectRef = (0,external_wp_element_namespaceObject.useRef)();
  use_click_outside(unitSelectRef, function () {
    return setIsOpen(false);
  });
  var currentUnit = (0,external_wp_element_namespaceObject.useMemo)(function () {
    if (total) {
      if (responsive) {
        return total[deviceType] ? total[deviceType].unit ? total[deviceType].unit : defaultUnit : defaultUnit;
      }

      return total.unit || defaultUnit;
    }

    return defaultUnit;
  }, [total, deviceType]);

  var getValue = function getValue(val) {
    if (Object.keys(total).length > 0) {
      if (responsive) {
        return total[deviceType] ? total[deviceType][val] || 0 === total[deviceType][val] ? total[deviceType][val] : '' : '';
      }

      return total[val] || 0 === total[val] ? total[val] : '';
    }

    return '';
  };

  var inputAttrs = (0,external_wp_element_namespaceObject.useMemo)(function () {
    var inputMin = min,
        inputMax = max,
        inputStep = step;

    if ('%' === currentUnit || 'vh' === currentUnit || 'vw' === currentUnit) {
      inputMin = 'margin' === type ? -100 : 0;
      inputMax = 100;
    }

    if ('em' === currentUnit || 'rem' === currentUnit) {
      inputMin = 'margin' === type ? -20 : 0;
      inputMax = 20;
    }

    if ('px' === currentUnit) {
      inputMin = 'margin' === type ? -inputMax : 0;
      inputStep = 1;
    }

    return {
      min: inputMin,
      max: inputMax,
      step: inputStep
    };
  });

  var setSettings = function setSettings(val) {
    var _total$deviceType, _total$deviceType2;

    var prop = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';
    val = Number.isNaN(val) ? Boolean(getValue('lock')) ? undefined : 0 : val;
    val = val < inputAttrs.min ? inputAttrs.min : val;
    val = val > inputAttrs.max ? inputAttrs.max : val;
    var data = Boolean(getValue('lock')) && 'unit' !== prop && 'lock' !== prop ? {
      top: val,
      right: val,
      bottom: val,
      left: val
    } : _defineProperty({}, prop, val);

    if ('unit' === prop) {
      data.top = undefined;
      data.right = undefined;
      data.bottom = undefined;
      data.left = undefined;
    }

    data = Object.assign({}, responsive ? total[deviceType] || {} : total, data);

    if (!data.unit || !(total !== null && total !== void 0 && (_total$deviceType = total[deviceType]) !== null && _total$deviceType !== void 0 && _total$deviceType.unit)) {
      data.unit = data.unit || defaultUnit;
    }

    if (!data.lock || !(total !== null && total !== void 0 && (_total$deviceType2 = total[deviceType]) !== null && _total$deviceType2 !== void 0 && _total$deviceType2.lock)) {
      data.lock = data.lock || false;
    }

    onChange(Object.assign({}, total, responsive ? _defineProperty({}, deviceType, data) : data));
    setIsOpen(false);
  };

  var prevLockVal = (0,external_wp_element_namespaceObject.useRef)(getValue('lock'));
  (0,external_wp_element_namespaceObject.useEffect)(function () {
    if (prevLockVal.current === getValue('lock')) {
      return;
    }

    prevLockVal.current = getValue('lock');

    if (!getValue('lock')) {
      return;
    }

    if (!responsive) {
      var allProp = [];
      var maxProp;

      for (var _i = 0, _Object$keys = Object.keys(DIMENSIONS_PROPERTIES); _i < _Object$keys.length; _i++) {
        var prop = _Object$keys[_i];
        allProp = [].concat(_toConsumableArray(allProp), [total[prop] || '']);

        if (allProp.length === 4) {
          maxProp = allProp.every(function (v) {
            return '' === v;
          }) ? undefined : Math.max.apply(Math, _toConsumableArray(allProp));
          total.top = maxProp;
          total.right = maxProp;
          total.bottom = maxProp;
          total.left = maxProp;
        }
      }

      onChange(Object.assign({}, total));
    } else {
      var _allProp = [];

      var _maxProp;

      if (total[deviceType]) {
        for (var _i2 = 0, _Object$keys2 = Object.keys(DIMENSIONS_PROPERTIES); _i2 < _Object$keys2.length; _i2++) {
          var _prop = _Object$keys2[_i2];
          _allProp = [].concat(_toConsumableArray(_allProp), [total[deviceType][_prop] || '']);

          if (_allProp.length === 4) {
            _maxProp = _allProp.every(function (v) {
              return '' === v;
            }) ? undefined : Math.max.apply(Math, _toConsumableArray(_allProp));
            total[deviceType].top = _maxProp;
            total[deviceType].right = _maxProp;
            total[deviceType].bottom = _maxProp;
            total[deviceType].left = _maxProp;
          }
        }
      }

      onChange(Object.assign({}, total));
    }
  }, [getValue('lock')]);
  return /*#__PURE__*/React.createElement("div", {
    className: classnames_default()('blockart-control', 'blockart-dimensions', {
      'blockart-responsive': responsive
    })
  }, /*#__PURE__*/React.createElement("div", {
    className: "blockart-control-head blockart-dimensions-head"
  }, label && /*#__PURE__*/React.createElement("label", {
    htmlFor: "blockart-dimension-top-".concat(id),
    className: "blockart-control-label blockart-dimensions-label"
  }, label), responsive && /*#__PURE__*/React.createElement(DeviceSelector, null), units && /*#__PURE__*/React.createElement("div", {
    className: "blockart-units",
    ref: unitSelectRef
  }, /*#__PURE__*/React.createElement("button", {
    className: "blockart-units-btn",
    onClick: function onClick() {
      return setIsOpen(!isOpen);
    },
    "aria-expanded": isOpen
  }, currentUnit), units && units.length > 1 && isOpen && /*#__PURE__*/React.createElement("ul", {
    className: "blockart-units-menu",
    "aria-hidden": !isOpen
  }, units.filter(function (unit) {
    return unit !== currentUnit;
  }).map(function (unit) {
    return /*#__PURE__*/React.createElement("li", {
      className: "blockart-unit",
      key: unit
    }, /*#__PURE__*/React.createElement("button", {
      onClick: function onClick() {
        return setSettings(unit, 'unit');
      }
    }, unit));
  })))), /*#__PURE__*/React.createElement("div", {
    className: "blockart-control-body blockart-dimension-body"
  }, responsive ? ['desktop', 'tablet', 'mobile'].map(function (deviceKey) {
    return deviceKey === deviceType && /*#__PURE__*/React.createElement("div", {
      key: deviceKey,
      className: "blockart-dimensions-container"
    }, Object.keys(DIMENSIONS_PROPERTIES).map(function (dimensionProp) {
      return /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.TextControl, {
        autoComplete: "off",
        key: dimensionProp,
        className: "blockart-dimension",
        label: DIMENSIONS_PROPERTIES[dimensionProp],
        value: getValue(dimensionProp),
        type: "number",
        onChange: function onChange(val) {
          return setSettings(parseFloat(val), dimensionProp);
        }
      });
    }), /*#__PURE__*/React.createElement("button", {
      className: classnames_default()('blockart-dimensions-lock', {
        'is-lock': Boolean(getValue('lock'))
      }),
      onClick: function onClick() {
        return setSettings(!Boolean(getValue('lock')), 'lock');
      }
    }, /*#__PURE__*/React.createElement(components_icon, {
      type: "controlIcon",
      name: Boolean(getValue('lock')) ? 'lock' : 'un-link',
      size: 16
    })));
  }) : /*#__PURE__*/React.createElement("div", {
    className: "blockart-dimensions-container"
  }, Object.keys(DIMENSIONS_PROPERTIES).map(function (dimensionProp) {
    return /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.TextControl, {
      autoComplete: "off",
      key: dimensionProp,
      className: "blockart-dimension",
      label: DIMENSIONS_PROPERTIES[dimensionProp],
      value: getValue(dimensionProp),
      type: "number",
      onChange: function onChange(val) {
        return setSettings(parseFloat(val), dimensionProp);
      }
    });
  }), /*#__PURE__*/React.createElement("button", {
    className: classnames_default()('blockart-dimensions-lock', {
      'is-lock': Boolean(getValue('lock'))
    }),
    onClick: function onClick() {
      return setSettings(!Boolean(getValue('lock')), 'lock');
    }
  }, /*#__PURE__*/React.createElement(components_icon, {
    type: "controlIcon",
    name: Boolean(getValue('lock')) ? 'lock' : 'un-link',
    size: 16
  })))));
}));
;// CONCATENATED MODULE: external ["wp","blockEditor"]
const external_wp_blockEditor_namespaceObject = window["wp"]["blockEditor"];
;// CONCATENATED MODULE: ./src/blocks/components/url-input/index.js



var url_input_excluded = ["value", "label", "onChange", "newTab", "noFollow", "instanceId"];






/* harmony default export */ const url_input = ((0,external_wp_compose_namespaceObject.withInstanceId)(function (_ref) {
  var _value$url, _value$newTab, _value$noFollow;

  var value = _ref.value,
      _ref$label = _ref.label,
      label = _ref$label === void 0 ? (0,external_wp_i18n_namespaceObject.__)('URL', 'blockart') : _ref$label,
      _ref$onChange = _ref.onChange,
      onChange = _ref$onChange === void 0 ? function () {} : _ref$onChange,
      _ref$newTab = _ref.newTab,
      newTab = _ref$newTab === void 0 ? false : _ref$newTab,
      _ref$noFollow = _ref.noFollow,
      noFollow = _ref$noFollow === void 0 ? false : _ref$noFollow,
      id = _ref.instanceId,
      otherProps = _objectWithoutProperties(_ref, url_input_excluded);

  var setSettings = function setSettings(type) {
    var val = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;
    var data = 'newTab' === type || 'noFollow' === type ? _defineProperty({}, type, !value[type]) : _defineProperty({}, type, val);
    onChange(Object.assign({}, value, data));
  };

  return /*#__PURE__*/React.createElement("div", {
    className: "blockart-control blockart-url-input"
  }, /*#__PURE__*/React.createElement("div", {
    className: "blockart-control-head blockart-url-input-head"
  }, /*#__PURE__*/React.createElement("label", {
    htmlFor: "blockart-url-input-".concat(id),
    className: "blockart-control-label blockart-control-label"
  }, label)), /*#__PURE__*/React.createElement("div", {
    className: "blockart-control-body blockart-url-input-body"
  }, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.BaseControl, {
    id: "blockart-url-input-".concat(id)
  }, /*#__PURE__*/React.createElement(external_wp_blockEditor_namespaceObject.URLInput, _extends({
    value: (_value$url = value === null || value === void 0 ? void 0 : value.url) !== null && _value$url !== void 0 ? _value$url : '',
    onChange: function onChange(val) {
      return setSettings('url', val);
    },
    autoFocus: false // eslint-disable-line jsx-a11y/no-autofocus
    ,
    disableSuggestions: true
  }, otherProps))), newTab && /*#__PURE__*/React.createElement(toggle, {
    checked: (_value$newTab = value === null || value === void 0 ? void 0 : value.newTab) !== null && _value$newTab !== void 0 ? _value$newTab : false,
    onChange: function onChange() {
      return setSettings('newTab');
    },
    label: (0,external_wp_i18n_namespaceObject.__)('Open Link in a New Tab', 'blockart')
  }), noFollow && /*#__PURE__*/React.createElement(toggle, {
    checked: (_value$noFollow = value === null || value === void 0 ? void 0 : value.noFollow) !== null && _value$noFollow !== void 0 ? _value$noFollow : false,
    onChange: function onChange() {
      return setSettings('noFollow');
    },
    label: (0,external_wp_i18n_namespaceObject.__)('Nofollow Link', 'blockart')
  })));
}));
;// CONCATENATED MODULE: ./src/blocks/components/typography/fonts.js
/* harmony default export */ const fonts = ([{
  f: 'Default',
  v: ['100', '200', '300', '400', '500', '600', '700']
}, {
  f: 'Abril Fatface',
  v: ['regular']
}, {
  f: 'Almendra SC',
  v: ['regular']
}, {
  f: 'Anton',
  v: ['regular']
}, {
  f: 'Arvo',
  v: ['regular', 'italic', '700', '700italic']
}, {
  f: 'Bebas Neue',
  v: ['regular']
}, {
  f: 'Bitter',
  v: ['100', '200', '300', 'regular', '500', '600', '700', '800', '900', '100italic', '200italic', '300italic', 'italic', '500italic', '600italic', '700italic', '800italic', '900italic']
}, {
  f: 'Coda Caption',
  v: ['800']
}, {
  f: 'Creepster',
  v: ['regular']
}, {
  f: 'Domine',
  v: ['regular', '500', '600', '700']
}, {
  f: 'Finger Paint',
  v: ['regular']
}, {
  f: 'Fredoka One',
  v: ['regular']
}, {
  f: 'Lato',
  v: ['100', '100italic', '300', '300italic', 'regular', 'italic', '700', '700italic', '900', '900italic']
}, {
  f: 'Lobster',
  v: ['regular']
}, {
  f: 'Lora',
  v: ['regular', '500', '600', '700', 'italic', '500italic', '600italic', '700italic']
}, {
  f: 'Montserrat',
  v: ['100', '100italic', '200', '200italic', '300', '300italic', 'regular', 'italic', '500', '500italic', '600', '600italic', '700', '700italic', '800', '800italic', '900', '900italic']
}, {
  f: 'Nobile',
  v: ['regular', 'italic', '500', '500italic', '700', '700italic']
}, {
  f: 'Nunito',
  v: ['200', '200italic', '300', '300italic', 'regular', 'italic', '600', '600italic', '700', '700italic', '800', '800italic', '900', '900italic']
}, {
  f: 'Open Sans',
  v: ['300', '300italic', 'regular', 'italic', '600', '600italic', '700', '700italic', '800', '800italic']
}, {
  f: 'Oswald',
  v: ['200', '300', 'regular', '500', '600', '700']
}, {
  f: 'Pattaya',
  v: ['regular']
}, {
  f: 'Peddana',
  v: ['regular']
}, {
  f: 'Playfair Display',
  v: ['regular', '500', '600', '700', '800', '900', 'italic', '500italic', '600italic', '700italic', '800italic', '900italic']
}, {
  f: 'Poppins',
  v: ['100', '100italic', '200', '200italic', '300', '300italic', 'regular', 'italic', '500', '500italic', '600', '600italic', '700', '700italic', '800', '800italic', '900', '900italic']
}, {
  f: 'Quicksand',
  v: ['300', 'regular', '500', '600', '700']
}, {
  f: 'Raleway',
  v: ['100', '200', '300', 'regular', '500', '600', '700', '800', '900', '100italic', '200italic', '300italic', 'italic', '500italic', '600italic', '700italic', '800italic', '900italic']
}, {
  f: 'Roboto',
  v: ['100', '100italic', '300', '300italic', 'regular', 'italic', '500', '500italic', '700', '700italic', '900', '900italic']
}, {
  f: 'Rufina',
  v: ['regular', '700']
}, {
  f: 'Seaweed Script',
  v: ['regular']
}, {
  f: 'Teko',
  v: ['300', 'regular', '500', '600', '700']
}, {
  f: 'Ultra',
  v: ['regular']
}, {
  f: 'Zilla Slab',
  v: ['300', '300italic', 'regular', 'italic', '500', '500italic', '600', '600italic', '700', '700italic']
}, {
  f: 'Noto Serif',
  v: ['regular', '700', '700italic']
}, {
  f: 'Work Sans',
  v: ['100', '200', '300', 'regular', '500', '600', '700', '800', '900', '100italic', '200italic', '300italic', 'italic', '500italic', '600italic', '700italic', '800italic', '900italic']
}, {
  f: 'Quattrocento',
  v: ['regular', '700']
}, {
  f: 'Cinzel Decorative',
  v: ['regular', '700', '900']
}, {
  f: 'Be Vietnam Pro',
  v: ['100', '200', '300', 'regular', '500', '600', '700', '800', '900']
}]);
;// CONCATENATED MODULE: ./src/blocks/components/typography/index.js

var __ = wp.i18n.__;




/* harmony default export */ const components_typography = (function (_ref) {
  var _ref$value = _ref.value,
      family = _ref$value.family,
      size = _ref$value.size,
      weight = _ref$value.weight,
      lineHeight = _ref$value.lineHeight,
      transform = _ref$value.transform,
      decoration = _ref$value.decoration,
      letterSpacing = _ref$value.letterSpacing,
      _ref$value2 = _ref.value,
      value = _ref$value2 === void 0 ? {} : _ref$value2,
      _ref$onChange = _ref.onChange,
      onChange = _ref$onChange === void 0 ? function () {} : _ref$onChange,
      label = _ref.label;
  var familyOptions = (0,external_wp_element_namespaceObject.useMemo)(function () {
    return fonts.map(function (font) {
      return {
        value: font.f,
        label: font.f
      };
    });
  }, []);
  var weightOptions = (0,external_wp_element_namespaceObject.useMemo)(function () {
    if (!family) {
      return [100, 200, 300, 400, 500, 600, 700].map(function (w) {
        return {
          label: w,
          value: w
        };
      });
    }

    var weights = fonts.filter(function (f) {
      return family === f.f;
    })[0].v.map(function (w) {
      if (w === 'regular') w = 400;
      return parseInt(w);
    }).filter(function (w, i, arr) {
      return !Number.isNaN(w) && arr.indexOf(w) === i;
    });
    return weights.map(function (w) {
      return {
        label: w,
        value: w
      };
    });
  }, [family]);

  var setSetting = function setSetting(type, val) {
    var data = _defineProperty({}, type, val);

    onChange(Object.assign({}, value, data));
  };

  (0,external_wp_element_namespaceObject.useEffect)(function () {
    if (!weightOptions.some(function (w) {
      return w.value === weight;
    })) {
      setSetting('weight', Object.keys(weightOptions).includes('400') || 'undefined' === typeof weight ? 400 : weightOptions[0].value);
    }
  }, [weightOptions]);
  return /*#__PURE__*/React.createElement("div", {
    className: "blockart-control blockart-typography"
  }, /*#__PURE__*/React.createElement("div", {
    className: "blockart-control-head blockart-typography-head"
  }, label && /*#__PURE__*/React.createElement("label", {
    htmlFor: "blockart-typography",
    className: "blockart-control-label blockart-typography-label"
  }, label)), /*#__PURE__*/React.createElement("div", {
    className: "blockart-control-body blockart-typography-body"
  }, /*#__PURE__*/React.createElement(components_select, {
    label: __('Font Family', 'blockart'),
    onChange: function onChange(val) {
      return setSetting('family', val);
    },
    value: family !== null && family !== void 0 ? family : 'Default',
    options: familyOptions,
    search: true
  }), /*#__PURE__*/React.createElement(slider, {
    value: size || {},
    onChange: function onChange(val) {
      return setSetting('size', val);
    },
    responsive: true,
    min: 0,
    max: 100,
    inline: true,
    units: ['px', 'em', 'rem'],
    defaultUnit: "px",
    label: __('Size', 'blockart')
  }), /*#__PURE__*/React.createElement(components_select, {
    label: __('Weight', 'blockart'),
    onChange: function onChange(val) {
      return setSetting('weight', val);
    },
    value: weight !== null && weight !== void 0 ? weight : 400,
    options: weightOptions
  }), /*#__PURE__*/React.createElement(slider, {
    value: lineHeight || {},
    onChange: function onChange(val) {
      return setSetting('lineHeight', val);
    },
    responsive: true,
    min: 0,
    max: 100,
    inline: true,
    units: ['px', 'em', 'rem'],
    defaultUnit: "px",
    label: __('Line Height', 'blockart')
  }), /*#__PURE__*/React.createElement(pop_over, {
    label: __('Advanced Typography', 'blockart')
  }, /*#__PURE__*/React.createElement(components_select, {
    label: __('Transformation', 'blockart'),
    onChange: function onChange(val) {
      return setSetting('transform', val);
    },
    value: transform !== null && transform !== void 0 ? transform : '',
    options: [{
      label: __('Default', 'blockart'),
      value: 'default'
    }, {
      label: __('Capitalize', 'blockart'),
      value: 'capitalize'
    }, {
      label: __('Uppercase', 'blockart'),
      value: 'uppercase'
    }, {
      label: __('Lowercase', 'blockart'),
      value: 'lowercase'
    }]
  }), /*#__PURE__*/React.createElement(components_select, {
    label: __('Decoration', 'blockart'),
    onChange: function onChange(val) {
      return setSetting('decoration', val);
    },
    value: decoration !== null && decoration !== void 0 ? decoration : '',
    options: [{
      label: __('Default', 'blockart'),
      value: 'default'
    }, {
      label: __('Overline', 'blockart'),
      value: 'overline'
    }, {
      label: __('Underline', 'blockart'),
      value: 'underline'
    }, {
      label: __('Line Through', 'blockart'),
      value: 'line-through'
    }]
  }), /*#__PURE__*/React.createElement(slider, {
    value: letterSpacing !== null && letterSpacing !== void 0 ? letterSpacing : {},
    onChange: function onChange(val) {
      return setSetting('letterSpacing', val);
    },
    responsive: true,
    min: 0,
    max: 100,
    inline: true,
    units: ['px', 'em', 'rem'],
    defaultUnit: "px",
    label: __('Letter Spacing', 'blockart')
  }))));
});
;// CONCATENATED MODULE: ./src/blocks/components/size/index.js









/* harmony default export */ const components_size = ((0,external_wp_compose_namespaceObject.withInstanceId)(function (_ref) {
  var _ref$value = _ref.value,
      value = _ref$value === void 0 ? '' : _ref$value,
      _ref$onChange = _ref.onChange,
      _onChange = _ref$onChange === void 0 ? function () {} : _ref$onChange,
      label = _ref.label,
      _ref$sizes = _ref.sizes,
      sizes = _ref$sizes === void 0 ? [{
    label: (0,external_wp_i18n_namespaceObject.__)('S', 'blockart'),
    value: 'small'
  }, {
    label: (0,external_wp_i18n_namespaceObject.__)('M', 'blockart'),
    value: 'medium'
  }, {
    label: (0,external_wp_i18n_namespaceObject.__)('L', 'blockart'),
    value: 'large'
  }] : _ref$sizes,
      _ref$defaultKey = _ref.defaultKey,
      defaultKey = _ref$defaultKey === void 0 ? 'size' : _ref$defaultKey,
      _ref$custom = _ref.custom,
      custom = _ref$custom === void 0 ? false : _ref$custom,
      _ref$customValue = _ref.customValue,
      customValue = _ref$customValue === void 0 ? {} : _ref$customValue,
      _ref$customKey = _ref.customKey,
      customKey = _ref$customKey === void 0 ? 'padding' : _ref$customKey,
      _ref$customMax = _ref.customMax,
      customMax = _ref$customMax === void 0 ? 500 : _ref$customMax,
      _ref$customUnits = _ref.customUnits,
      customUnits = _ref$customUnits === void 0 ? ['rem', 'em', 'px', '%'] : _ref$customUnits,
      _ref$customMin = _ref.customMin,
      customMin = _ref$customMin === void 0 ? 0 : _ref$customMin,
      _ref$customLabel = _ref.customLabel,
      customLabel = _ref$customLabel === void 0 ? (0,external_wp_i18n_namespaceObject.__)('Padding', 'blockart') : _ref$customLabel,
      _ref$customDefaultUni = _ref.customDefaultUnit,
      customDefaultUnit = _ref$customDefaultUni === void 0 ? 'px' : _ref$customDefaultUni,
      id = _ref.instanceId;

  var _useState = (0,external_wp_element_namespaceObject.useState)(false),
      _useState2 = slicedToArray_slicedToArray(_useState, 2),
      isOpen = _useState2[0],
      setIsOpen = _useState2[1];

  var popoverRef = (0,external_wp_element_namespaceObject.useRef)();
  var popoverToggleRef = (0,external_wp_element_namespaceObject.useRef)();
  use_click_outside(popoverRef, function () {
    return setIsOpen(false);
  }, popoverToggleRef);
  return /*#__PURE__*/React.createElement("div", {
    className: "blockart-control blockart-size"
  }, /*#__PURE__*/React.createElement("div", {
    className: "blockart-control-head blockart-size-head"
  }, /*#__PURE__*/React.createElement("label", {
    htmlFor: "blockart-size-".concat(id),
    className: "blockart-control-label blockart-size-label"
  }, label)), /*#__PURE__*/React.createElement("div", {
    className: "blockart-control-body blockart-size-body"
  }, /*#__PURE__*/React.createElement("div", {
    className: "blockart-size-buttons"
  }, sizes.length > 0 && sizes.map(function (size, idx) {
    return /*#__PURE__*/React.createElement("button", {
      key: idx,
      className: classnames_default()('blockart-size-button', {
        'is-active': value && size.value === value
      }),
      onClick: function onClick() {
        return _onChange(defaultKey, value === size.value ? '' : size.value);
      }
    }, /*#__PURE__*/React.createElement("span", {
      className: "blockart-size-button-text"
    }, size.label.toUpperCase()));
  }), custom && /*#__PURE__*/React.createElement("button", {
    ref: popoverToggleRef,
    className: classnames_default()('blockart-size-button', 'blockart-size-advance-button', {
      'is-active': value && 'custom' === value
    }),
    onClick: function onClick() {
      setIsOpen(!isOpen);

      _onChange(defaultKey, value === 'custom' ? '' : 'custom');
    }
  }, /*#__PURE__*/React.createElement(components_icon, {
    type: "controlIcon",
    name: "cog",
    size: 20
  }))), value && 'custom' === value && /*#__PURE__*/React.createElement("div", {
    ref: popoverRef,
    className: "blockart-size-popover"
  }, /*#__PURE__*/React.createElement(dimensions, {
    units: customUnits,
    value: customValue || {},
    label: customLabel,
    responsive: true,
    min: customMin,
    max: customMax,
    defaultUnit: customDefaultUnit,
    onChange: function onChange(val) {
      _onChange(customKey, val);
    }
  }))));
}));
;// CONCATENATED MODULE: ./src/blocks/components/media/index.js





/* harmony default export */ const components_media = ((0,external_wp_compose_namespaceObject.withInstanceId)(function (_ref) {
  var _ref$onChange = _ref.onChange,
      onChange = _ref$onChange === void 0 ? function () {} : _ref$onChange,
      _ref$type = _ref.type,
      type = _ref$type === void 0 ? 'image' : _ref$type,
      _ref$value = _ref.value,
      value = _ref$value === void 0 ? {} : _ref$value,
      label = _ref.label;
  var buttonString = value !== null && value !== void 0 && value.url ? (0,external_wp_i18n_namespaceObject.__)('Replace', 'blockart') + ' ' + ('image' === type ? 'Image' : 'Video') : (0,external_wp_i18n_namespaceObject.__)('Add', 'blockart') + ' ' + ('image' === type ? 'Image' : 'Video');

  var onSelect = function onSelect(media) {
    if (!(media !== null && media !== void 0 && media.url)) {
      return;
    }

    var url = media.url,
        id = media.id,
        height = media.height,
        width = media.width,
        alt = media.alt;
    onChange({
      url: url,
      id: id,
      height: height,
      width: width,
      alt: alt
    });
  };

  return /*#__PURE__*/React.createElement("div", {
    className: "blockart-control blockart-media"
  }, /*#__PURE__*/React.createElement("div", {
    className: "blockart-control-head blockart-media-head"
  }, /*#__PURE__*/React.createElement("label", {
    htmlFor: "blockart-media-head"
  }, label)), /*#__PURE__*/React.createElement("div", {
    className: "blockart-control-body blockart-media-body"
  }, /*#__PURE__*/React.createElement(external_wp_blockEditor_namespaceObject.MediaUploadCheck, null, /*#__PURE__*/React.createElement(external_wp_blockEditor_namespaceObject.MediaUpload, {
    onSelect: onSelect,
    allowedTypes: [type],
    title: 'Upload Image',
    render: function render(_ref2) {
      var open = _ref2.open;
      return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("div", {
        className: "blockart-media-placeholder blockart-media-preview",
        onClick: open,
        onKeyDown: function onKeyDown(e) {
          return 'Enter' === e.key && open;
        },
        role: "button",
        tabIndex: 0,
        title: buttonString
      }, /*#__PURE__*/React.createElement("img", {
        src: (value === null || value === void 0 ? void 0 : value.url) || _BLOCKART_.placeholderImage,
        alt: (0,external_wp_i18n_namespaceObject.__)('blockart preview image', 'blockart')
      })), /*#__PURE__*/React.createElement("button", {
        className: "blockart-media-button",
        onClick: open
      }, /*#__PURE__*/React.createElement(components_icon, {
        type: "controlIcon",
        name: "image",
        size: 20
      }), /*#__PURE__*/React.createElement("span", {
        className: "blockart-media-button-text"
      }, buttonString)), value && /*#__PURE__*/React.createElement("button", {
        className: "blockart-media-delete",
        onClick: function onClick() {
          return onChange('');
        }
      }, /*#__PURE__*/React.createElement(components_icon, {
        type: "controlIcon",
        name: "trash",
        size: 20
      })));
    }
  }))));
}));
;// CONCATENATED MODULE: ./src/blocks/components/color/index.js










/* harmony default export */ const components_color = ((0,external_wp_compose_namespaceObject.withInstanceId)(function (_ref) {
  var label = _ref.label,
      value = _ref.value,
      _ref$onChange = _ref.onChange,
      _onChange = _ref$onChange === void 0 ? function () {} : _ref$onChange,
      id = _ref.instanceId;

  var _useState = (0,external_wp_element_namespaceObject.useState)(false),
      _useState2 = slicedToArray_slicedToArray(_useState, 2),
      isOpen = _useState2[0],
      setIsOpen = _useState2[1];

  var toggleRef = (0,external_wp_element_namespaceObject.useRef)();
  var colorPickerRef = (0,external_wp_element_namespaceObject.useRef)(null);

  var setSetting = function setSetting(val) {
    var newVal = val.rgb.a !== 1 ? 'rgba(' + val.rgb.r + ',' + val.rgb.g + ',' + val.rgb.b + ',' + val.rgb.a + ')' : val.hex;

    _onChange(newVal);
  };

  return /*#__PURE__*/React.createElement("div", {
    className: "blockart-control blockart-color"
  }, /*#__PURE__*/React.createElement("div", {
    className: "blockart-control-head blockart-color-head"
  }, label && /*#__PURE__*/React.createElement("label", {
    htmlFor: "blockart-color-".concat(id),
    className: "blockart-control-label blockart-color-label"
  }, label), /*#__PURE__*/React.createElement("div", {
    className: "blockart-color-buttons"
  }, value && /*#__PURE__*/React.createElement("button", {
    className: "blockart-color-clear-button",
    onClick: function onClick() {
      return _onChange('');
    }
  }, /*#__PURE__*/React.createElement(components_icon, {
    type: "controlIcon",
    name: "reset",
    size: 20
  })), /*#__PURE__*/React.createElement("button", {
    id: "blockart-color-".concat(id),
    className: "blockart-color-toggle-button",
    onClick: function onClick() {
      return setIsOpen(!isOpen);
    },
    ref: toggleRef
  }, /*#__PURE__*/React.createElement("span", {
    className: classnames_default()('blockart-color-indicator', {
      'is-empty': !value
    }),
    style: {
      width: '24px',
      height: '24px',
      background: value || 'repeating-conic-gradient(#999 0% 25%, #eee 0% 50%) center center / 8px 8px',
      display: 'inline-block',
      borderRadius: '50%'
    }
  }), value && /*#__PURE__*/React.createElement("span", {
    className: "blockart-color-text"
  }, value)))), isOpen && /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Popover, {
    position: "bottom center",
    onFocusOutside: function onFocusOutside(e) {
      if (e.relatedTarget !== toggleRef.current) {
        setIsOpen(false);
      }
    },
    focusOnMount: "container"
  }, /*#__PURE__*/React.createElement("div", {
    className: "blockart-control-body blockart-color-body"
  }, /*#__PURE__*/React.createElement("div", {
    className: "blockart-color-picker"
  }, /*#__PURE__*/React.createElement("div", {
    className: "blockart-color-palette"
  }, /*#__PURE__*/React.createElement(external_wp_blockEditor_namespaceObject.ColorPalette, {
    value: value !== null && value !== void 0 ? value : '',
    onChange: function onChange(color) {
      var _ref2 = (colorPickerRef === null || colorPickerRef === void 0 ? void 0 : colorPickerRef.current) || false,
          commitValues = _ref2.commitValues;

      if (color && commitValues) {
        commitValues({
          hex: color,
          source: 'hex'
        });
      }

      _onChange(color);
    },
    disableCustomColors: true,
    clearable: false,
    colors: [{
      name: (0,external_wp_i18n_namespaceObject.__)('Blue', 'blockart'),
      color: '#2871ff'
    }, {
      name: (0,external_wp_i18n_namespaceObject.__)('Dark Golden', 'blockart'),
      color: '#e89623'
    }, {
      name: (0,external_wp_i18n_namespaceObject.__)('Black', 'blockart'),
      color: '#000000'
    }, {
      name: (0,external_wp_i18n_namespaceObject.__)('White', 'blockart'),
      color: '#ffffff'
    }]
  })), /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.ColorPicker, _extends({
    color: value !== null && value !== void 0 ? value : '',
    onChangeComplete: function onChangeComplete(color) {
      setSetting(color);
    }
  }, !_BLOCKART_.isWP59OrAbove && {
    ref: colorPickerRef
  }))))));
}));
;// CONCATENATED MODULE: ./src/blocks/components/toggle/index.js


var toggle_excluded = ["checked", "onChange", "label", "instanceId"];



/* harmony default export */ const toggle = ((0,external_wp_compose_namespaceObject.withInstanceId)(function (_ref) {
  var _ref$checked = _ref.checked,
      checked = _ref$checked === void 0 ? false : _ref$checked,
      _ref$onChange = _ref.onChange,
      onChange = _ref$onChange === void 0 ? function () {} : _ref$onChange,
      _ref$label = _ref.label,
      label = _ref$label === void 0 ? '' : _ref$label,
      id = _ref.instanceId,
      props = _objectWithoutProperties(_ref, toggle_excluded);

  return /*#__PURE__*/React.createElement("div", {
    className: classnames_default()('blockart-control', 'blockart-toggle', 'blockart-inline', {
      'is-checked': checked
    })
  }, /*#__PURE__*/React.createElement("div", {
    className: "blockart-toggle-head"
  }, label && /*#__PURE__*/React.createElement("label", {
    htmlFor: "blockart-toggle-".concat(id),
    className: "blockart-control-label blockart-toggle-label"
  }, label)), /*#__PURE__*/React.createElement("div", {
    className: "blockart-control-body blockart-toggle-body"
  }, /*#__PURE__*/React.createElement("input", _extends({
    id: "blockart-toggle-".concat(id),
    type: "checkbox",
    className: "blockart-toggle-checkbox",
    onChange: onChange
  }, props)), /*#__PURE__*/React.createElement("span", {
    className: "blockart-toggle-track"
  }), /*#__PURE__*/React.createElement("span", {
    className: "blockart-toggle-thumb"
  })));
}));
;// CONCATENATED MODULE: ./src/blocks/components/box-shadow/index.js


function box_shadow_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function box_shadow_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? box_shadow_ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : box_shadow_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }






/* harmony default export */ const box_shadow = (function (_ref) {
  var _ref$value = _ref.value,
      enable = _ref$value.enable,
      color = _ref$value.color,
      verticalY = _ref$value.verticalY,
      horizontalX = _ref$value.horizontalX,
      blur = _ref$value.blur,
      spread = _ref$value.spread,
      position = _ref$value.position,
      _ref$value2 = _ref.value,
      value = _ref$value2 === void 0 ? {} : _ref$value2,
      _ref$onChange = _ref.onChange,
      onChange = _ref$onChange === void 0 ? function () {} : _ref$onChange;

  var setSetting = function setSetting(type, val) {
    var data = _defineProperty({}, type, val);

    onChange(box_shadow_objectSpread(box_shadow_objectSpread({}, value), data));
  };

  return /*#__PURE__*/React.createElement("div", {
    className: "blockart-control blockart-border"
  }, /*#__PURE__*/React.createElement("div", {
    className: "blockart-control-body blockart-border-body"
  }, /*#__PURE__*/React.createElement(toggle, {
    label: (0,external_wp_i18n_namespaceObject.__)('Box Shadow', 'blockart'),
    checked: enable || false,
    onChange: function onChange() {
      return setSetting('enable', !enable);
    }
  }), enable && /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(components_color, {
    onChange: function onChange(val) {
      return setSetting('color', val);
    },
    value: color || '',
    label: (0,external_wp_i18n_namespaceObject.__)('Color', 'blockart')
  }), /*#__PURE__*/React.createElement(slider, {
    min: -100,
    max: 100,
    label: (0,external_wp_i18n_namespaceObject.__)('Horizontal-X', 'blockart'),
    value: horizontalX || 0,
    onChange: function onChange(val) {
      return setSetting('horizontalX', val);
    },
    step: 1
  }), /*#__PURE__*/React.createElement(slider, {
    min: -100,
    max: 100,
    label: (0,external_wp_i18n_namespaceObject.__)('Horizontal-Y', 'blockart'),
    value: verticalY || 0,
    onChange: function onChange(val) {
      return setSetting('verticalY', val);
    },
    step: 1
  }), /*#__PURE__*/React.createElement(slider, {
    min: 0,
    max: 100,
    label: (0,external_wp_i18n_namespaceObject.__)('Blur', 'blockart'),
    value: blur || 0,
    onChange: function onChange(val) {
      return setSetting('blur', val);
    },
    step: 1
  }), /*#__PURE__*/React.createElement(slider, {
    min: 0,
    max: 100,
    label: (0,external_wp_i18n_namespaceObject.__)('Spread', 'blockart'),
    value: spread || 0,
    onChange: function onChange(val) {
      return setSetting('spread', val);
    },
    step: 1
  }), /*#__PURE__*/React.createElement(components_select, {
    label: (0,external_wp_i18n_namespaceObject.__)('Position', 'blockart'),
    onChange: function onChange(val) {
      return setSetting('position', val);
    },
    value: position || 'outline',
    options: [{
      label: (0,external_wp_i18n_namespaceObject.__)('Outline', 'blockart'),
      value: 'outline'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Inset', 'blockart'),
      value: 'inset'
    }]
  }))));
});
;// CONCATENATED MODULE: ./src/blocks/components/border/index.js


function border_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function border_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? border_ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : border_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }





/* harmony default export */ const components_border = (function (_ref) {
  var _ref$value = _ref.value,
      type = _ref$value.type,
      size = _ref$value.size,
      radius = _ref$value.radius,
      color = _ref$value.color,
      _ref$onChange = _ref.onChange,
      onChange = _ref$onChange === void 0 ? function () {} : _ref$onChange,
      _ref$value2 = _ref.value,
      value = _ref$value2 === void 0 ? {} : _ref$value2;

  var setSetting = function setSetting(genre, val) {
    var data = _defineProperty({}, genre, val);

    onChange(border_objectSpread(border_objectSpread({}, value), data));
  };

  return /*#__PURE__*/React.createElement("div", {
    className: "blockart-control blockart-border"
  }, /*#__PURE__*/React.createElement("div", {
    className: "blockart-control-body blockart-border-body"
  }, /*#__PURE__*/React.createElement(components_select, {
    label: (0,external_wp_i18n_namespaceObject.__)('Type', 'blockart'),
    onChange: function onChange(val) {
      return setSetting('type', val);
    },
    value: type || 'none',
    options: [{
      label: (0,external_wp_i18n_namespaceObject.__)('None', 'blockart'),
      value: 'none'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Solid', 'blockart'),
      value: 'solid'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Double', 'blockart'),
      value: 'double'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Dashed', 'blockart'),
      value: 'dashed'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Dotted', 'blockart'),
      value: 'dotted'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Groove', 'blockart'),
      value: 'groove'
    }]
  }), 'undefined' !== typeof type && 'none' !== type && /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(components_color, {
    onChange: function onChange(val) {
      return setSetting('color', val);
    },
    value: color || '',
    label: (0,external_wp_i18n_namespaceObject.__)('Border Color', 'blockart')
  }), /*#__PURE__*/React.createElement(dimensions, {
    label: (0,external_wp_i18n_namespaceObject.__)('Size', 'blockart'),
    value: size || {},
    responsive: true,
    units: ['px', 'rem', 'em'],
    defaultUnit: "px",
    min: 0,
    onChange: function onChange(val) {
      return setSetting('size', val);
    },
    isLinked: true
  })), /*#__PURE__*/React.createElement(dimensions, {
    label: (0,external_wp_i18n_namespaceObject.__)('Radius', 'blockart'),
    value: radius || {},
    responsive: true,
    units: ['px', 'em', '%'],
    defaultUnit: "px",
    min: 0,
    onChange: function onChange(val) {
      return setSetting('radius', val);
    },
    isLinked: true
  })));
});
;// CONCATENATED MODULE: external ["wp","hooks"]
const external_wp_hooks_namespaceObject = window["wp"]["hooks"];
;// CONCATENATED MODULE: ./src/blocks/components/gradient/index.js



/* harmony default export */ const components_gradient = (function (_ref) {
  var _ref$value = _ref.value,
      color1 = _ref$value.color1,
      location1 = _ref$value.location1,
      color2 = _ref$value.color2,
      location2 = _ref$value.location2,
      gradientType = _ref$value.type,
      angle = _ref$value.angle,
      value = _ref.value,
      _ref$onChange = _ref.onChange,
      onChange = _ref$onChange === void 0 ? function () {} : _ref$onChange;

  var setSetting = function setSetting(type, val) {
    var data = _defineProperty({}, type, val);

    onChange(Object.assign({}, value, data));
  };

  return /*#__PURE__*/React.createElement("div", {
    className: "blockart-control blockart-gradient"
  }, /*#__PURE__*/React.createElement("div", {
    className: "blockart-control-body blockart-gradient-body"
  }, /*#__PURE__*/React.createElement(components_color, {
    value: color1 || '',
    label: "Color 1",
    onChange: function onChange(val) {
      return setSetting('color1', val);
    }
  }), /*#__PURE__*/React.createElement(slider, {
    value: location1 || 0,
    onChange: function onChange(val) {
      return setSetting('location1', val);
    },
    min: 0,
    max: 100,
    inline: true,
    label: (0,external_wp_i18n_namespaceObject.__)('Location', 'blockart')
  }), /*#__PURE__*/React.createElement(components_color, {
    value: color2 || '',
    label: "Color 2",
    onChange: function onChange(val) {
      return setSetting('color2', val);
    }
  }), /*#__PURE__*/React.createElement(slider, {
    value: location2 || 0,
    onChange: function onChange(val) {
      return setSetting('location2', val);
    },
    min: 0,
    max: 100,
    inline: true,
    label: (0,external_wp_i18n_namespaceObject.__)('Location', 'blockart')
  }), /*#__PURE__*/React.createElement(components_select, {
    label: (0,external_wp_i18n_namespaceObject.__)('Type', 'blockart'),
    value: gradientType || 'linear',
    onChange: function onChange(val) {
      return setSetting('type', val);
    },
    options: [{
      label: (0,external_wp_i18n_namespaceObject.__)('Linear', 'blockart'),
      value: 'linear'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Radial', 'blockart'),
      value: 'radial'
    }]
  }), /*#__PURE__*/React.createElement(slider, {
    value: angle || 0,
    onChange: function onChange(val) {
      return setSetting('angle', val);
    },
    min: 0,
    max: 365,
    inline: true,
    label: (0,external_wp_i18n_namespaceObject.__)('Angle', 'blockart')
  })));
});
;// CONCATENATED MODULE: ./src/blocks/components/background-image/index.js


function background_image_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function background_image_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? background_image_ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : background_image_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }




/* harmony default export */ const background_image = (with_device_type(function (_ref) {
  var _ref$value = _ref.value,
      _ref$value$image = _ref$value.image,
      image = _ref$value$image === void 0 ? {} : _ref$value$image,
      _ref$value$position = _ref$value.position,
      position = _ref$value$position === void 0 ? {} : _ref$value$position,
      _ref$value$size = _ref$value.size,
      size = _ref$value$size === void 0 ? {} : _ref$value$size,
      _ref$value$repeat = _ref$value.repeat,
      repeat = _ref$value$repeat === void 0 ? {} : _ref$value$repeat,
      _ref$value$attachment = _ref$value.attachment,
      attachment = _ref$value$attachment === void 0 ? 'scroll' : _ref$value$attachment,
      _ref$value$customSize = _ref$value.customSizeDesktop,
      customSizeDesktop = _ref$value$customSize === void 0 ? '' : _ref$value$customSize,
      _ref$value$customSize2 = _ref$value.customSizeTablet,
      customSizeTablet = _ref$value$customSize2 === void 0 ? '' : _ref$value$customSize2,
      _ref$value$customSize3 = _ref$value.customSizeMobile,
      customSizeMobile = _ref$value$customSize3 === void 0 ? '' : _ref$value$customSize3,
      _ref$value2 = _ref.value,
      value = _ref$value2 === void 0 ? {} : _ref$value2,
      _ref$onChange = _ref.onChange,
      onChange = _ref$onChange === void 0 ? function () {} : _ref$onChange,
      deviceType = _ref.deviceType;

  var setSetting = function setSetting(type, val) {
    var data = _defineProperty({}, type, val);

    onChange(background_image_objectSpread(background_image_objectSpread({}, value), data));
  };

  var setCustomSize = function setCustomSize(val) {
    if ('desktop' === deviceType) {
      onChange(Object.assign({}, value, {
        customSizeDesktop: val
      }));
    } else if ('tablet' === deviceType) {
      onChange(Object.assign({}, value, {
        customSizeTablet: val
      }));
    } else {
      onChange(Object.assign({}, value, {
        customSizeMobile: val
      }));
    }
  };

  return /*#__PURE__*/React.createElement("div", {
    className: "blockart-control blockart-background-image"
  }, /*#__PURE__*/React.createElement("div", {
    className: "blockart-control-body blockart-background-image-body"
  }, /*#__PURE__*/React.createElement(components_media, {
    value: image,
    onChange: function onChange(val) {
      return setSetting('image', val);
    }
  }), (image === null || image === void 0 ? void 0 : image.url) && /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(components_select, {
    label: (0,external_wp_i18n_namespaceObject.__)('Position', 'blockart'),
    value: position || {},
    onChange: function onChange(val) {
      return setSetting('position', val);
    },
    options: [{
      label: (0,external_wp_i18n_namespaceObject.__)('Default', 'blockart'),
      value: 'default'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Left Top', 'blockart'),
      value: 'left top'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Left Center', 'blockart'),
      value: 'left center'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Left Bottom', 'blockart'),
      value: 'left bottom'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Right Top', 'blockart'),
      value: 'right top'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Right Center', 'blockart'),
      value: 'right center'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Right Bottom', 'blockart'),
      value: 'right bottom'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Center Top', 'blockart'),
      value: 'center top'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Center Center', 'blockart'),
      value: 'center center'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Center Bottom', 'blockart'),
      value: 'center bottom'
    }],
    responsive: true,
    placeholder: (0,external_wp_i18n_namespaceObject.__)('Default', 'blockart')
  }), /*#__PURE__*/React.createElement(components_select, {
    label: (0,external_wp_i18n_namespaceObject.__)('Size', 'blockart'),
    value: size || {},
    onChange: function onChange(val) {
      return setSetting('size', val);
    },
    options: [{
      label: (0,external_wp_i18n_namespaceObject.__)('Default', 'blockart'),
      value: 'default'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Cover', 'blockart'),
      value: 'cover'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Contain', 'blockart'),
      value: 'contain'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Auto', 'blockart'),
      value: 'auto'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Custom', 'blockart'),
      value: 'custom'
    }],
    responsive: true,
    placeholder: (0,external_wp_i18n_namespaceObject.__)('Default', 'blockart')
  }), size && size[deviceType] && 'custom' === size[deviceType] && /*#__PURE__*/React.createElement(slider, {
    value: 'desktop' === deviceType ? customSizeDesktop || '' : 'tablet' === deviceType ? customSizeTablet || '' : customSizeMobile || '' // eslint-disable-line no-nested-ternary
    ,
    label: (0,external_wp_i18n_namespaceObject.__)('Width', 'blockart'),
    min: 0,
    max: 1000,
    defaultUnit: "%",
    units: ['px', '%', 'em', 'vw'],
    onChange: function onChange(val) {
      return setCustomSize(val);
    }
  }), /*#__PURE__*/React.createElement(components_select, {
    label: (0,external_wp_i18n_namespaceObject.__)('Repeat', 'blockart'),
    value: repeat || {},
    onChange: function onChange(val) {
      return setSetting('repeat', val);
    },
    options: [{
      label: (0,external_wp_i18n_namespaceObject.__)('Default', 'blockart'),
      value: 'default'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('No Repeat', 'blockart'),
      value: 'no-repeat'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Repeat', 'blockart'),
      value: 'repeat'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Repeat Vertically', 'blockart'),
      value: 'repeat-y'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Repeat Horizontally', 'blockart'),
      value: 'repeat-x'
    }],
    responsive: true,
    placeholder: (0,external_wp_i18n_namespaceObject.__)('Default', 'blockart')
  }), /*#__PURE__*/React.createElement(components_select, {
    label: (0,external_wp_i18n_namespaceObject.__)('Attachment', 'blockart'),
    value: attachment || '',
    onChange: function onChange(val) {
      return setSetting('attachment', val);
    },
    options: [{
      label: (0,external_wp_i18n_namespaceObject.__)('Default', 'blockart'),
      value: 'default'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Scroll', 'blockart'),
      value: 'scroll'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Fixed', 'blockart'),
      value: 'fixed'
    }],
    placeholder: (0,external_wp_i18n_namespaceObject.__)('Default', 'blockart')
  }))));
}));
;// CONCATENATED MODULE: ./src/blocks/components/background-video/index.js


function background_video_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function background_video_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? background_video_ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : background_video_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }



/* harmony default export */ const background_video = (function (_ref) {
  var _ref$value = _ref.value,
      video = _ref$value.video,
      loop = _ref$value.loop,
      mute = _ref$value.mute,
      image = _ref$value.image,
      position = _ref$value.position,
      size = _ref$value.size,
      repeat = _ref$value.repeat,
      attachment = _ref$value.attachment,
      _ref$value2 = _ref.value,
      value = _ref$value2 === void 0 ? {} : _ref$value2,
      _ref$onChange = _ref.onChange,
      onChange = _ref$onChange === void 0 ? function () {} : _ref$onChange;

  var setSetting = function setSetting(type, val) {
    var data = _defineProperty({}, type, val);

    onChange(background_video_objectSpread(background_video_objectSpread({}, value), data));
  };

  return /*#__PURE__*/React.createElement("div", {
    className: "blockart-control blockart-background-video"
  }, /*#__PURE__*/React.createElement("div", {
    className: "blockart-control-body blockart-background-video-body"
  }, /*#__PURE__*/React.createElement(components_media, {
    value: video || '',
    onChange: function onChange(val) {
      return setSetting('video', val);
    },
    label: (0,external_wp_i18n_namespaceObject.__)('Upload your Video', 'blockart'),
    type: "video"
  }), /*#__PURE__*/React.createElement(toggle, {
    label: (0,external_wp_i18n_namespaceObject.__)('Loop Video', 'blockart'),
    checked: loop || false,
    onChange: function onChange() {
      return setSetting('loop', !loop);
    }
  }), /*#__PURE__*/React.createElement(toggle, {
    label: (0,external_wp_i18n_namespaceObject.__)('Mute Video', 'blockart'),
    checked: mute || false,
    onChange: function onChange() {
      return setSetting('mute', !mute);
    }
  }), /*#__PURE__*/React.createElement(components_media, {
    value: image || '',
    onChange: function onChange(val) {
      return setSetting('image', val);
    },
    label: (0,external_wp_i18n_namespaceObject.__)('Background Image', 'blockart')
  }), /*#__PURE__*/React.createElement(components_select, {
    label: (0,external_wp_i18n_namespaceObject.__)('Position', 'blockart'),
    value: position || 'center center',
    onChange: function onChange(val) {
      return setSetting('position', val);
    },
    options: [{
      label: (0,external_wp_i18n_namespaceObject.__)('Left Top', 'blockart'),
      value: 'left top'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Left Center', 'blockart'),
      value: 'left center'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Left Bottom', 'blockart'),
      value: 'left bottom'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Right Top', 'blockart'),
      value: 'right top'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Right Center', 'blockart'),
      value: 'right center'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Right Bottom', 'blockart'),
      value: 'right bottom'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Center Top', 'blockart'),
      value: 'center top'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Center Center', 'blockart'),
      value: 'center center'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Center Bottom', 'blockart'),
      value: 'center bottom'
    }]
  }), /*#__PURE__*/React.createElement(components_select, {
    label: (0,external_wp_i18n_namespaceObject.__)('Size', 'blockart'),
    value: size || 'auto',
    onChange: function onChange(val) {
      return setSetting('size', val);
    },
    options: [{
      label: (0,external_wp_i18n_namespaceObject.__)('Cover', 'blockart'),
      value: 'cover'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Contain', 'blockart'),
      value: 'contain'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Auto', 'blockart'),
      value: 'auto'
    }]
  }), /*#__PURE__*/React.createElement(components_select, {
    label: (0,external_wp_i18n_namespaceObject.__)('Repeat', 'blockart'),
    value: repeat || 'repeat',
    onChange: function onChange(val) {
      return setSetting('repeat', val);
    },
    options: [{
      label: (0,external_wp_i18n_namespaceObject.__)('No Repeat', 'blockart'),
      value: 'no-repeat'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Repeat', 'blockart'),
      value: 'repeat'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Repeat Vertically', 'blockart'),
      value: 'repeat-y'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Repeat Horizontally', 'blockart'),
      value: 'repeat-x'
    }]
  }), /*#__PURE__*/React.createElement(components_select, {
    label: (0,external_wp_i18n_namespaceObject.__)('Attachment', 'blockart'),
    value: attachment || 'scroll',
    onChange: function onChange(val) {
      return setSetting('attachment', val);
    },
    options: [{
      label: (0,external_wp_i18n_namespaceObject.__)('Scroll', 'blockart'),
      value: 'scroll'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Fixed', 'blockart'),
      value: 'fixed'
    }]
  })));
});
;// CONCATENATED MODULE: ./src/blocks/components/background/index.js


function background_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function background_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? background_ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : background_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }










/* harmony default export */ const components_background = (function (_ref) {
  var _ref$value = _ref.value,
      type = _ref$value.type,
      color = _ref$value.color,
      gradient = _ref$value.gradient,
      image = _ref$value.image,
      video = _ref$value.video,
      _ref$value2 = _ref.value,
      value = _ref$value2 === void 0 ? {} : _ref$value2,
      _ref$label = _ref.label,
      label = _ref$label === void 0 ? '' : _ref$label,
      _ref$onChange = _ref.onChange,
      onChange = _ref$onChange === void 0 ? function () {} : _ref$onChange;
  var bgTypes = (0,external_wp_hooks_namespaceObject.applyFilters)('blockart.background.type', ['color', 'image']);

  var setSetting = function setSetting(genre, val) {
    var data = _defineProperty({}, genre, val);

    onChange(background_objectSpread(background_objectSpread({}, value), data));
  };

  return /*#__PURE__*/React.createElement("div", {
    className: "blockart-control blockart-background"
  }, /*#__PURE__*/React.createElement("div", {
    className: "blockart-control-head blockart-background-head"
  }, /*#__PURE__*/React.createElement("label", {
    htmlFor: "blockart-background",
    className: "blockart-control-label"
  }, label || ''), /*#__PURE__*/React.createElement("div", {
    className: "blockart-background-types"
  }, bgTypes.map(function (bgType) {
    return /*#__PURE__*/React.createElement("button", {
      key: bgType,
      className: classnames_default()('blockart-background-type', {
        'is-active': (type || '') === bgType
      }),
      onClick: function onClick() {
        return setSetting('type', bgType);
      }
    }, /*#__PURE__*/React.createElement(components_icon, {
      type: "controlIcon",
      name: bgType,
      size: 22
    }));
  }))), /*#__PURE__*/React.createElement("div", {
    className: "blockart-control-body blockart-background-body"
  }, 'color' === (type || 'color') && /*#__PURE__*/React.createElement(components_color, {
    label: (0,external_wp_i18n_namespaceObject.__)('Color', 'blockart'),
    onChange: function onChange(val) {
      return setSetting('color', val);
    },
    value: color || ''
  }), 'gradient' === (type || 'color') && /*#__PURE__*/React.createElement(components_gradient, {
    onChange: function onChange(val) {
      return setSetting('gradient', val);
    },
    value: gradient || {}
  }), 'image' === (type || 'color') && /*#__PURE__*/React.createElement(background_image, {
    onChange: function onChange(val) {
      return setSetting('image', val);
    },
    value: image || {}
  }), 'video' === (type || 'color') && /*#__PURE__*/React.createElement(background_video, {
    onChange: function onChange(val) {
      return setSetting('video', val);
    },
    value: video || {}
  })));
});
;// CONCATENATED MODULE: ./src/blocks/components/icon-selector/index.js



function icon_selector_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function icon_selector_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? icon_selector_ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : icon_selector_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }







/* harmony default export */ const icon_selector = (function (_ref) {
  var _ref$value = _ref.value,
      enable = _ref$value.enable,
      icon = _ref$value.icon,
      value = _ref.value,
      _ref$onChange = _ref.onChange,
      _onChange = _ref$onChange === void 0 ? function () {} : _ref$onChange,
      label = _ref.label,
      _ref$search = _ref.search,
      search = _ref$search === void 0 ? true : _ref$search;

  var _useState = (0,external_wp_element_namespaceObject.useState)(''),
      _useState2 = slicedToArray_slicedToArray(_useState, 2),
      searchTerm = _useState2[0],
      setSearchTerm = _useState2[1];

  var finalIcons = (0,external_wp_element_namespaceObject.useMemo)(function () {
    return frontendIcons.map(function (key) {
      return {
        id: key,
        title: key.replace(/-/g, ' ').replace(/ o/g, '').replace(/(^\w|\s\w)/g, function (t) {
          return t.toUpperCase();
        })
      };
    }).filter(function (_ref2) {
      var title = _ref2.title;
      return title.toLowerCase().includes(searchTerm.toLowerCase());
    });
  }, [searchTerm]);
  return /*#__PURE__*/React.createElement("div", {
    className: "blockart-control blockart-icon-selector"
  }, /*#__PURE__*/React.createElement("div", {
    className: "blockart-control-head blockart-icon-selector-head"
  }, label && /*#__PURE__*/React.createElement("label", {
    htmlFor: "blockart-icon-selector",
    className: "blockart-control-label blockart-icon-selector-label"
  }, label), /*#__PURE__*/React.createElement(toggle, {
    checked: enable || false,
    onChange: function onChange() {
      return _onChange(icon_selector_objectSpread(icon_selector_objectSpread({}, value), {}, {
        enable: !enable
      }));
    }
  })), enable && /*#__PURE__*/React.createElement("div", {
    className: "blockart-control blockart-icon-selector-body"
  }, search && /*#__PURE__*/React.createElement("input", {
    type: "text",
    value: searchTerm,
    placeholder: (0,external_wp_i18n_namespaceObject.__)('Search', 'blockart'),
    onChange: function onChange(e) {
      return setSearchTerm(e.target.value);
    },
    autoComplete: "off"
  }), /*#__PURE__*/React.createElement("div", {
    className: "blockart-icon-list-icons"
  }, (finalIcons === null || finalIcons === void 0 ? void 0 : finalIcons.length) > 0 ? finalIcons.map(function (_ref3) {
    var id = _ref3.id,
        title = _ref3.title;
    return /*#__PURE__*/React.createElement("span", {
      onKeyDown: function onKeyDown() {},
      key: id,
      className: classnames_default()('blockart-icon-btn', {
        'is-active': icon === id
      }),
      role: "button",
      tabIndex: 0,
      onClick: function onClick() {
        return _onChange(icon_selector_objectSpread(icon_selector_objectSpread({}, value), {}, {
          icon: id
        }));
      },
      title: title
    }, /*#__PURE__*/React.createElement(components_icon, {
      type: "frontendIcon",
      name: id
    }));
  }) : /*#__PURE__*/React.createElement("p", {
    className: "blockart-icon-list-no-icons",
    style: {
      gridColumn: '1/-1',
      margin: 0
    }
  }, (0,external_wp_i18n_namespaceObject.__)('Icons not found!', 'blockart')))));
});
;// CONCATENATED MODULE: ./src/blocks/components/library-modal/single-item/index.js



function single_item_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function single_item_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? single_item_ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : single_item_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }









/* harmony default export */ const single_item = ((0,external_wp_compose_namespaceObject.compose)([(0,external_wp_data_namespaceObject.withDispatch)(function (dispatch) {
  return {
    insertBlocks: dispatch('core/block-editor').insertBlocks
  };
})])(function (props) {
  var _useState = (0,external_wp_element_namespaceObject.useState)({
    isImporting: false,
    isImported: false,
    error: false
  }),
      _useState2 = slicedToArray_slicedToArray(_useState, 2),
      state = _useState2[0],
      setState = _useState2[1];

  var insertBlocks = props.insertBlocks,
      name = props.name,
      id = props.id,
      image = props.image,
      type = props.type;

  var importSection = function importSection() {
    setState(single_item_objectSpread(single_item_objectSpread({}, state), {}, {
      isImporting: true
    }));
    var args = new FormData();
    args.append('action', 'blockart_import_content');
    args.append('security', _BLOCKART_.nonce);
    args.append('id', id);
    external_wp_apiFetch_default()({
      url: _BLOCKART_.ajaxUrl,
      method: 'POST',
      credentials: 'same-origin',
      body: args
    }).then(function (res) {
      if (res.success) {
        window._BLOCKART_.mediaItems = res.data.media_items;
        insertBlocks((0,external_wp_blocks_namespaceObject.parse)(res.data.content));
        setState(single_item_objectSpread(single_item_objectSpread({}, state), {}, {
          isImporting: false,
          isImported: true
        }));
      } else {
        setState(single_item_objectSpread(single_item_objectSpread({}, state), {}, {
          isImporting: false,
          error: true
        }));
      }
    })["catch"](function () {
      setState(single_item_objectSpread(single_item_objectSpread({}, state), {}, {
        isImporting: false,
        error: true
      }));
    });
  };

  return /*#__PURE__*/React.createElement("div", {
    className: classnames_default()("blockart-template", {
      'is-importing': state.isImporting
    })
  }, /*#__PURE__*/React.createElement("div", {
    className: "blockart-template-media loading"
  }, /*#__PURE__*/React.createElement("img", {
    onLoad: function onLoad(e) {
      return e.currentTarget.parentElement.classList.remove('loading');
    },
    width: "290",
    height: 'sections' === type ? '150' : '350',
    src: image.toString(),
    alt: name
  })), /*#__PURE__*/React.createElement("div", {
    className: "blockart-template-info"
  }, /*#__PURE__*/React.createElement("h4", null, name), /*#__PURE__*/React.createElement("button", {
    onClick: importSection,
    style: {
      opacity: state.isImporting ? 1 : undefined
    }
  }, // eslint-disable-next-line no-nested-ternary
  state.isImporting ? (0,external_wp_i18n_namespaceObject.__)('Importing', 'blockart') : // eslint-disable-next-line no-nested-ternary
  state.isImported ? (0,external_wp_i18n_namespaceObject.__)('Imported', 'blockart') : state.error ? (0,external_wp_i18n_namespaceObject.__)('Failed', 'blockart') : (0,external_wp_i18n_namespaceObject.__)('Import', 'blockart'))), state.isImporting && /*#__PURE__*/React.createElement("div", {
    className: "blockart-template-overlay"
  }, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Spinner, null)));
}));
;// CONCATENATED MODULE: ./src/blocks/components/layout/index.js








/* harmony default export */ const layout = (with_library_data(function (_ref) {
  var _libraryData$get, _libraryData$get2;

  var block = _ref.block,
      libraryData = _ref.libraryData,
      initLibraryData = _ref.initLibraryData;

  if (!Array.isArray(block)) {
    block = [block];
  }

  var sections = (_libraryData$get = libraryData.get('sections')) !== null && _libraryData$get !== void 0 ? _libraryData$get : [];

  var _useState = (0,external_wp_element_namespaceObject.useState)((_libraryData$get2 = libraryData.get('status')) !== null && _libraryData$get2 !== void 0 ? _libraryData$get2 : ''),
      _useState2 = slicedToArray_slicedToArray(_useState, 2),
      status = _useState2[0],
      setStatus = _useState2[1];

  (0,external_wp_element_namespaceObject.useEffect)(function () {
    var update = function update() {
      var _libraryData$get3;

      setStatus((_libraryData$get3 = libraryData.get('status')) !== null && _libraryData$get3 !== void 0 ? _libraryData$get3 : '');
    };

    window.addEventListener('_blockart_library_data', update);
    return function () {
      window.removeEventListener('_blockart_library_data', update);
    };
  });
  return /*#__PURE__*/React.createElement("div", {
    className: "blockart-layout"
  }, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Tooltip, {
    text: (0,external_wp_i18n_namespaceObject.__)('Refresh', 'blockart')
  }, /*#__PURE__*/React.createElement("button", {
    onClick: function onClick() {
      setStatus('fetching');
      initLibraryData(true);
    },
    className: "blockart-refresh-btn"
  }, /*#__PURE__*/React.createElement(components_icon, {
    type: "controlIcon",
    name: "reset"
  }))), 'success' === status ? (sections || []).filter(function (section) {
    return ((section === null || section === void 0 ? void 0 : section['included_blocks']) || []).some(function (i) {
      return block.includes(i.value);
    });
  }).map(function (_ref2, idx) {
    var id = _ref2.ID,
        name = _ref2.post_title,
        image = _ref2.post_thumbnail;
    return /*#__PURE__*/React.createElement(single_item, {
      key: idx,
      id: id,
      image: image,
      name: name,
      type: "sections"
    });
  }) : '' === status || 'fetching' === status ? /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Spinner, null) : /*#__PURE__*/React.createElement("p", {
    style: {
      gridColumn: '1/-1'
    }
  }, (0,external_wp_i18n_namespaceObject.__)('There is connection issue with wpblockart.com. This connection is required for importing templates and sections. Please contact your hosting provider to whitelist our server address wpblockart.com.', 'blockart')));
}));
;// CONCATENATED MODULE: ./src/blocks/components/input/index.js



/* harmony default export */ const input = ((0,external_wp_compose_namespaceObject.withInstanceId)(function (_ref) {
  var _ref$labelPosition = _ref.labelPosition,
      labelPosition = _ref$labelPosition === void 0 ? 'top' : _ref$labelPosition,
      label = _ref.label,
      _ref$onChange = _ref.onChange,
      _onChange = _ref$onChange === void 0 ? function () {} : _ref$onChange,
      id = _ref.instanceId,
      value = _ref.value,
      _ref$type = _ref.type,
      type = _ref$type === void 0 ? 'text' : _ref$type;

  return /*#__PURE__*/React.createElement("div", {
    className: "blockart-control blockart-input blockart-input-".concat(labelPosition)
  }, label && /*#__PURE__*/React.createElement("div", {
    className: "blockart-control-head"
  }, /*#__PURE__*/React.createElement("label", {
    htmlFor: "blockart-input-".concat(id)
  }, label)), /*#__PURE__*/React.createElement("div", {
    className: "blockart-control-body"
  }, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.TextControl, {
    id: "blockart-input-".concat(id),
    value: value !== null && value !== void 0 ? value : '',
    onChange: function onChange(val) {
      return _onChange(val);
    },
    type: type
  })));
}));
;// CONCATENATED MODULE: ./src/blocks/components/library-modal/index.js




function library_modal_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function library_modal_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? library_modal_ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : library_modal_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }











/* harmony default export */ const library_modal = ((0,external_wp_compose_namespaceObject.compose)([with_library_data, (0,external_wp_data_namespaceObject.withDispatch)(function (dispatch) {
  return {
    removeBlock: dispatch('core/block-editor').removeBlock
  };
})])(function (props) {
  var _libraryData$get, _data$type$length, _data$type, _data$templates;

  var _props$modalOnly = props.modalOnly,
      modalOnly = _props$modalOnly === void 0 ? false : _props$modalOnly,
      _props$hasModal = props.hasModal,
      isOpen = _props$hasModal === void 0 ? false : _props$hasModal,
      closeModal = props.closeModal,
      blockId = props.blockId,
      removeBlock = props.removeBlock,
      libraryData = props.libraryData,
      initLibraryData = props.initLibraryData;

  var _useState = (0,external_wp_element_namespaceObject.useState)({
    type: 'sections',
    search: '',
    category: '',
    starterPackId: '',
    isModalOpen: false,
    isModalOnly: false,
    status: (_libraryData$get = libraryData.get('status')) !== null && _libraryData$get !== void 0 ? _libraryData$get : ''
  }),
      _useState2 = slicedToArray_slicedToArray(_useState, 2),
      state = _useState2[0],
      setState = _useState2[1];

  var contentRef = (0,external_wp_element_namespaceObject.useRef)();
  var data = {
    sections: libraryData.get('sections'),
    templates: libraryData.get('templates'),
    'starter-packs': libraryData.get('starter-packs')
  };
  var type = state.type,
      search = state.search,
      category = state.category,
      starterPackId = state.starterPackId,
      isModalOpen = state.isModalOpen,
      isModalOnly = state.isModalOnly,
      status = state.status;
  (0,external_wp_element_namespaceObject.useEffect)(function () {
    var update = function update() {
      setState(function (prev) {
        var _libraryData$get2;

        return library_modal_objectSpread(library_modal_objectSpread({}, prev), {}, {
          status: (_libraryData$get2 = libraryData.get('status')) !== null && _libraryData$get2 !== void 0 ? _libraryData$get2 : ''
        });
      });
    };

    window.addEventListener('_blockart_library_data', update);
    return function () {
      window.removeEventListener('_blockart_library_data', update);
    };
  }, []);
  var titles = {
    sections: (0,external_wp_i18n_namespaceObject.__)('Sections', 'blockart'),
    'starter-packs': (0,external_wp_i18n_namespaceObject.__)('Starter Packs', 'blockart'),
    templates: (0,external_wp_i18n_namespaceObject.__)('Templates', 'blockart')
  };
  var currentCategories = (0,external_wp_element_namespaceObject.useMemo)(function () {
    if ('' !== starterPackId && 'starter-packs' === type) {
      return [];
    }

    return ((data === null || data === void 0 ? void 0 : data[type]) || []).reduce(function (acc, _ref) {
      var cat = _ref.category;
      acc = [].concat(_toConsumableArray(acc), _toConsumableArray(cat)).filter(function (c, idx, arr) {
        return idx === arr.findIndex(function (a) {
          return a.slug === c.slug;
        });
      });
      return acc;
    }, []) // eslint-disable-next-line no-nested-ternary
    .sort(function (a, b) {
      return a.name.toUpperCase() < b.name.toUpperCase() ? -1 : a.name.toUpperCase() > b.name.toUpperCase() ? 1 : 0;
    }).map(function (_, index, arr) {
      var _filter;

      return library_modal_objectSpread(library_modal_objectSpread({}, arr[index]), {}, {
        count: ((_filter = ((data === null || data === void 0 ? void 0 : data[type]) || []).filter(function (t) {
          return t.category.some(function (tc) {
            return tc.slug === arr[index].slug;
          });
        })) === null || _filter === void 0 ? void 0 : _filter.length) || 0
      });
    });
  }, [type, starterPackId, status]);
  var currentContent = (0,external_wp_element_namespaceObject.useMemo)(function () {
    return ((data === null || data === void 0 ? void 0 : data[type]) || []).filter(function (t) {
      return '' !== category ? t.category.some(function (tc) {
        return tc.slug === category;
      }) : true;
    }).filter(function (t) {
      return '' !== search ? t.post_title.toLowerCase().includes(search) : true;
    });
  }, [type, category, search, status]);

  var onModalClose = function onModalClose() {
    closeModal();
    setState(library_modal_objectSpread(library_modal_objectSpread({}, state), {}, {
      isModalOpen: false
    }));

    if (isModalOnly) {
      removeBlock(blockId);
    }
  };

  (0,external_wp_element_namespaceObject.useEffect)(function () {
    if (!isOpen || !contentRef.current) return;
    contentRef.current.scrollTop = 0;
  }, [search, category, type, starterPackId]);
  (0,external_wp_element_namespaceObject.useEffect)(function () {
    setState(library_modal_objectSpread(library_modal_objectSpread({}, state), {}, {
      isModalOnly: modalOnly,
      isModalOpen: isOpen
    }));
  }, []);

  if (!isModalOpen) {
    return null;
  }

  return /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Modal, {
    __experimentalHideHeader: true,
    className: "blockart-library-modal",
    overlayClassName: "blockart-library-modal-overlay",
    title: (0,external_wp_i18n_namespaceObject.__)('Blockart Library', 'blockart'),
    onRequestClose: onModalClose
  }, /*#__PURE__*/React.createElement("div", {
    className: "blockart-library-modal-head"
  }, /*#__PURE__*/React.createElement("div", {
    className: "blockart-library-modal-logo"
  }, /*#__PURE__*/React.createElement("h2", null, "BlockArt")), /*#__PURE__*/React.createElement("div", {
    className: "blockart-library-modal-actions"
  }, /*#__PURE__*/React.createElement("button", {
    onClick: function onClick() {
      return setState(library_modal_objectSpread(library_modal_objectSpread({}, state), {}, {
        type: 'sections',
        search: '',
        category: ''
      }));
    },
    className: classnames_default()({
      active: 'sections' === type
    })
  }, (0,external_wp_i18n_namespaceObject.__)('Sections', 'blockart')), /*#__PURE__*/React.createElement("button", {
    onClick: function onClick() {
      return setState(library_modal_objectSpread(library_modal_objectSpread({}, state), {}, {
        type: 'starter-packs',
        search: '',
        category: ''
      }));
    },
    className: classnames_default()({
      active: 'starter-packs' === type
    })
  }, (0,external_wp_i18n_namespaceObject.__)('Starter Packs', 'blockart')), /*#__PURE__*/React.createElement("button", {
    onClick: function onClick() {
      return setState(library_modal_objectSpread(library_modal_objectSpread({}, state), {}, {
        type: 'templates',
        search: '',
        category: ''
      }));
    },
    className: classnames_default()({
      active: 'templates' === type
    })
  }, (0,external_wp_i18n_namespaceObject.__)('Templates', 'blockart'))), /*#__PURE__*/React.createElement("div", {
    className: "blockart-library-modal-close"
  }, /*#__PURE__*/React.createElement("button", {
    onClick: onModalClose
  }, /*#__PURE__*/React.createElement(components_icon, {
    type: "frontendIcon",
    name: "close"
  })))), /*#__PURE__*/React.createElement("div", {
    className: "blockart-library-modal-body"
  }, /*#__PURE__*/React.createElement("div", {
    className: "blockart-library-modal-sidebar"
  }, /*#__PURE__*/React.createElement("div", {
    className: "blockart-library-modal-search"
  }, /*#__PURE__*/React.createElement("input", {
    type: "text",
    defaultValue: search,
    placeholder: (0,external_wp_i18n_namespaceObject.__)('Search Block', 'blockart'),
    onChange: function onChange(e) {
      return setState(library_modal_objectSpread(library_modal_objectSpread({}, state), {}, {
        search: e.currentTarget.value
      }));
    }
  }), /*#__PURE__*/React.createElement(components_icon, {
    type: "frontendIcon",
    name: "search-o"
  })), /*#__PURE__*/React.createElement("h3", null, (0,external_wp_i18n_namespaceObject.__)('CATEGORIES', 'blockart')), /*#__PURE__*/React.createElement("ul", {
    className: "blockart-library-modal-category-filter"
  }, /*#__PURE__*/React.createElement("li", null, /*#__PURE__*/React.createElement("button", {
    disabled: 'fetching' === status,
    className: classnames_default()({
      'is-active': '' === category
    }),
    onClick: function onClick() {
      return setState(library_modal_objectSpread(library_modal_objectSpread({}, state), {}, {
        category: ''
      }));
    }
  }, /*#__PURE__*/React.createElement("span", {
    className: "title"
  }, (0,external_wp_i18n_namespaceObject.__)('All ', 'blockart') + titles[type]), /*#__PURE__*/React.createElement("span", {
    className: "count"
  }, 'success' === status ? (_data$type$length = data === null || data === void 0 ? void 0 : (_data$type = data[type]) === null || _data$type === void 0 ? void 0 : _data$type.length) !== null && _data$type$length !== void 0 ? _data$type$length : 0 : 0))), 'success' === status && (currentCategories || []).map(function (_ref2, idx) {
    var slug = _ref2.slug,
        name = _ref2.name,
        count = _ref2.count;
    return /*#__PURE__*/React.createElement("li", {
      key: idx
    }, /*#__PURE__*/React.createElement("button", {
      className: classnames_default()({
        'is-active': slug === category
      }),
      onClick: function onClick() {
        return setState(library_modal_objectSpread(library_modal_objectSpread({}, state), {}, {
          category: slug
        }));
      }
    }, /*#__PURE__*/React.createElement("span", {
      className: "title"
    }, name), /*#__PURE__*/React.createElement("span", {
      className: "count"
    }, count)));
  }))), /*#__PURE__*/React.createElement("div", {
    ref: contentRef,
    className: "blockart-library-modal-content"
  }, /*#__PURE__*/React.createElement("div", {
    className: "blockart-library-modal-content-area"
  }, /*#__PURE__*/React.createElement("div", {
    className: "blockart-library-modal-sub-header"
  }, /*#__PURE__*/React.createElement("h3", {
    style: {
      display: 'flex',
      justifyContent: 'space-between',
      alignItems: 'center'
    }
  }, '' !== starterPackId && 'starter-packs' === type ? /*#__PURE__*/React.createElement("button", {
    className: "blockart-library-modal-back-button",
    onClick: function onClick() {
      return setState(library_modal_objectSpread(library_modal_objectSpread({}, state), {}, {
        starterPackId: ''
      }));
    }
  }, /*#__PURE__*/React.createElement(components_icon, {
    type: "frontendIcon",
    name: "arrow-left"
  }), " ", (0,external_wp_i18n_namespaceObject.__)('Return', 'blockart')) : /*#__PURE__*/React.createElement("span", null, (0,external_wp_i18n_namespaceObject.__)('All ', 'blockart') + titles[type]), /*#__PURE__*/React.createElement("button", {
    disabled: 'fetching' === status,
    onClick: function onClick() {
      setState(function (prev) {
        return library_modal_objectSpread(library_modal_objectSpread({}, prev), {}, {
          status: 'fetching'
        });
      });
      initLibraryData(true);
    }
  }, (0,external_wp_i18n_namespaceObject.__)('Refresh', 'blockart')))), /*#__PURE__*/React.createElement("div", {
    className: classnames_default()('blockart-templates', {
      'has-layer': 'starter-packs' === type && '' === starterPackId
    })
  }, 'success' === status ? /*#__PURE__*/React.createElement(React.Fragment, null, ('sections' === type || 'templates' === type) && (currentContent || []).map(function (_ref3) {
    var id = _ref3.ID,
        name = _ref3.post_title,
        image = _ref3.post_thumbnail;
    return /*#__PURE__*/React.createElement(single_item, {
      key: id,
      name: name,
      id: id,
      image: image,
      type: type
    });
  }), 'starter-packs' === type && ('' !== starterPackId ? ((_data$templates = data.templates) !== null && _data$templates !== void 0 ? _data$templates : []).filter(function (t) {
    return parseInt(t.post_parent) === parseInt(starterPackId);
  }).filter(function (t) {
    return '' !== search ? t.post_title.toLowerCase().includes(search) : true;
  }).map(function (_ref4) {
    var id = _ref4.ID,
        name = _ref4.post_title,
        image = _ref4.post_thumbnail;
    return /*#__PURE__*/React.createElement(single_item, {
      key: id,
      name: name,
      id: id,
      image: image,
      type: 'templates'
    });
  }) : (currentContent || []).map(function (_ref5) {
    var id = _ref5.ID,
        name = _ref5.post_title,
        image = _ref5.post_thumbnail;
    return /*#__PURE__*/React.createElement("div", {
      key: id,
      tabIndex: "0",
      onKeyDown: function onKeyDown(e) {
        return 'Enter' === e.key && setState(library_modal_objectSpread(library_modal_objectSpread({}, state), {}, {
          starterPackId: id
        }));
      },
      role: "button",
      onClick: function onClick() {
        return setState(library_modal_objectSpread(library_modal_objectSpread({}, state), {}, {
          starterPackId: id
        }));
      },
      className: "blockart-template"
    }, /*#__PURE__*/React.createElement("div", {
      className: "blockart-template-media loading"
    }, /*#__PURE__*/React.createElement("img", {
      width: "290",
      height: "350",
      src: image,
      alt: name,
      className: "loading",
      onLoad: function onLoad(e) {
        return e.currentTarget.parentElement.classList.remove('loading');
      }
    })), /*#__PURE__*/React.createElement("div", {
      className: "blockart-template-info"
    }, /*#__PURE__*/React.createElement("h4", null, name)));
  })), 0 === (currentContent === null || currentContent === void 0 ? void 0 : currentContent.length) && /*#__PURE__*/React.createElement("p", null, "No results")) : 'fetching' === status || '' === status ? /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Spinner, null) : /*#__PURE__*/React.createElement("p", {
    style: {
      gridColumn: '1/-1'
    }
  }, (0,external_wp_i18n_namespaceObject.__)('There is connection issue with wpblockart.com. This connection is required for importing templates and sections. Please contact your hosting provider to whitelist our server address wpblockart.com.', 'blockart')))))));
}));
;// CONCATENATED MODULE: ./src/blocks/components/tooltip/index.js



/* harmony default export */ const tooltip = (function (props) {
  var _useState = useState(false),
      _useState2 = _slicedToArray(_useState, 2),
      open = _useState2[0],
      setOpen = _useState2[1];

  var ref = useRef();
  var children = props.children,
      _props$position = props.position,
      position = _props$position === void 0 ? 'top right' : _props$position,
      content = props.content;
  useEffect(function () {
    var el = ref.current;
    if (!el) return;
    el === null || el === void 0 ? void 0 : el.addEventListener('mouseenter', function () {
      return setOpen(true);
    });
    el === null || el === void 0 ? void 0 : el.addEventListener('mouseleave', function () {
      return setOpen(false);
    });
    return function () {
      el === null || el === void 0 ? void 0 : el.removeEventListener('mouseenter', function () {
        return setOpen(true);
      });
      el === null || el === void 0 ? void 0 : el.removeEventListener('mouseleave', function () {
        return setOpen(false);
      });
    };
  }, []);

  if (!content || !isValidElement(children)) {
    return children;
  }

  return /*#__PURE__*/React.createElement("div", {
    style: {
      display: 'inline-block'
    },
    ref: ref
  }, children, open && /*#__PURE__*/React.createElement(Popover, {
    focusOnMount: false,
    className: "blockart-tooltip components-tooltip",
    position: position,
    onClose: function onClose() {
      return setOpen(false);
    },
    onFocusOutside: function onFocusOutside() {
      return setOpen(false);
    }
  }, /*#__PURE__*/React.createElement("div", {
    className: "blockart-tooltip-content"
  }, content)));
});
;// CONCATENATED MODULE: ./src/blocks/components/toolbar-dropdown-control/index.js



function toolbar_dropdown_control_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function toolbar_dropdown_control_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? toolbar_dropdown_control_ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : toolbar_dropdown_control_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }


/* harmony default export */ const toolbar_dropdown_control = (function (_ref) {
  var _options$find, _options$0$icon, _options$;

  var _ref$isCollapsed = _ref.isCollapsed,
      isCollapsed = _ref$isCollapsed === void 0 ? true : _ref$isCollapsed,
      onChange = _ref.onChange,
      value = _ref.value,
      popoverProps = _ref.popoverProps,
      isToolbar = _ref.isToolbar,
      _ref$options = _ref.options,
      options = _ref$options === void 0 ? [] : _ref$options,
      label = _ref.label;

  var handleClick = function handleClick(next) {
    if (next === value) {
      onChange(undefined);
    } else {
      onChange(next);
    }
  };

  var icon = value ? (_options$find = options.find(function (option) {
    return option.value === value;
  })) === null || _options$find === void 0 ? void 0 : _options$find.icon : (_options$0$icon = options === null || options === void 0 ? void 0 : (_options$ = options[0]) === null || _options$ === void 0 ? void 0 : _options$.icon) !== null && _options$0$icon !== void 0 ? _options$0$icon : null;
  var UIComponent = isToolbar ? external_wp_components_namespaceObject.ToolbarGroup : external_wp_components_namespaceObject.ToolbarDropdownMenu;
  var extraProps = isToolbar ? {
    isCollapsed: isCollapsed
  } : {};
  return /*#__PURE__*/React.createElement(UIComponent, _extends({
    icon: icon,
    popoverProps: popoverProps,
    label: label !== null && label !== void 0 ? label : undefined,
    controls: options.map(function (option) {
      return toolbar_dropdown_control_objectSpread(toolbar_dropdown_control_objectSpread({}, option), {}, {
        isActive: option.value === value,
        onClick: function onClick() {
          return handleClick(option.value);
        }
      });
    })
  }, extraProps));
});
;// CONCATENATED MODULE: ./src/blocks/components/block-settings/index.js







var blockAttributes = {
  blockMargin: {
    type: 'object',
    "default": {
      dimension: 1,
      desktop: {
        lock: true
      }
    },
    style: [{
      selector: '{{WRAPPER}} { margin: {{VALUE}}; }'
    }]
  },
  blockPadding: {
    type: 'object',
    "default": {
      dimension: 1,
      desktop: {
        lock: true
      }
    },
    style: [{
      selector: '{{WRAPPER}} { padding: {{VALUE}}; }'
    }]
  },
  blockZIndex: {
    type: 'number',
    style: [{
      selector: '{{WRAPPER}} { z-index: {{VALUE}}; }'
    }]
  },
  cssID: {
    type: 'string'
  },
  animation: {
    type: 'string'
  },
  interaction: {
    type: 'object'
  },
  position: {
    type: 'object'
  },
  hideOnDesktop: {
    type: 'boolean',
    style: [{
      selector: '@media (min-width:62em) { {{WRAPPER}} { display: none; } }'
    }]
  },
  hideOnTablet: {
    type: 'boolean',
    style: [{
      selector: '@media (min-width:48em) and (max-width:62em) { {{WRAPPER}} { display: none; } }'
    }]
  },
  hideOnMobile: {
    type: 'boolean',
    style: [{
      selector: '@media (max-width:48em) { {{WRAPPER}} { display: none; } }'
    }]
  },
  colReverseOnTablet: {
    type: 'boolean',
    style: [{
      selector: '@media (max-width:62em) { {{WRAPPER}} > .blockart-container > .blockart-section-inner { flex-direction:column-reverse; } }'
    }]
  },
  colReverseOnMobile: {
    type: 'boolean',
    style: [{
      selector: '@media (max-width:48em) { {{WRAPPER}} > .blockart-container > .blockart-section-inner { flex-direction:column-reverse; } }'
    }]
  },
  blockCSS: {
    type: 'string'
  },
  className: {
    type: 'string'
  }
};
var BlockAdvanceSettings = function BlockAdvanceSettings(_ref) {
  var blockMargin = _ref.blockMargin,
      blockPadding = _ref.blockPadding,
      blockZIndex = _ref.blockZIndex,
      cssID = _ref.cssID,
      setAttributes = _ref.setAttributes;
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(panel, {
    title: (0,external_wp_i18n_namespaceObject.__)('Advanced', 'blockart'),
    initialOpen: true
  }, /*#__PURE__*/React.createElement(dimensions, {
    value: blockMargin || {},
    responsive: true,
    label: (0,external_wp_i18n_namespaceObject.__)('Block Margin', 'blockart'),
    defaultUnit: "px",
    units: ['px', 'rem', 'em', '%'],
    onChange: function onChange(val) {
      return setAttributes({
        blockMargin: val
      });
    },
    type: "margin"
  }), /*#__PURE__*/React.createElement(dimensions, {
    value: blockPadding || {},
    responsive: true,
    label: (0,external_wp_i18n_namespaceObject.__)('Block Padding', 'blockart'),
    defaultUnit: "px",
    units: ['px', 'rem', 'em', '%'],
    onChange: function onChange(val) {
      return setAttributes({
        blockPadding: val
      });
    }
  }), /*#__PURE__*/React.createElement(slider, {
    label: (0,external_wp_i18n_namespaceObject.__)('Z-Index', 'blockart'),
    value: blockZIndex || 0,
    min: 0,
    max: 10000,
    step: 1,
    onChange: function onChange(val) {
      return setAttributes({
        blockZIndex: val
      });
    }
  }), /*#__PURE__*/React.createElement(input, {
    onChange: function onChange(val) {
      return setAttributes({
        cssID: val
      });
    },
    labelPosition: "side",
    label: (0,external_wp_i18n_namespaceObject.__)('CSS ID', 'blockart'),
    value: cssID || ''
  })));
};
var BlockResponsiveSettings = function BlockResponsiveSettings(_ref2) {
  var hideOnDesktop = _ref2.hideOnDesktop,
      hideOnTablet = _ref2.hideOnTablet,
      hideOnMobile = _ref2.hideOnMobile,
      setAttributes = _ref2.setAttributes,
      _ref2$hasColReverse = _ref2.hasColReverse,
      hasColReverse = _ref2$hasColReverse === void 0 ? false : _ref2$hasColReverse,
      colReverseOnTablet = _ref2.colReverseOnTablet,
      colReverseOnMobile = _ref2.colReverseOnMobile;
  return /*#__PURE__*/React.createElement(panel, {
    title: (0,external_wp_i18n_namespaceObject.__)('Responsive', 'blockart')
  }, hasColReverse && /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement("label", {
    className: "blockart-control-label",
    htmlFor: "blockart-column-reverse"
  }, (0,external_wp_i18n_namespaceObject.__)('Column Reverse', 'blockart')), /*#__PURE__*/React.createElement(toggle, {
    checked: colReverseOnTablet || false,
    onChange: function onChange() {
      return setAttributes({
        colReverseOnTablet: !colReverseOnTablet
      });
    },
    label: (0,external_wp_i18n_namespaceObject.__)('Tablet', 'blockart')
  }), /*#__PURE__*/React.createElement(toggle, {
    checked: colReverseOnMobile || false,
    onChange: function onChange() {
      return setAttributes({
        colReverseOnMobile: !colReverseOnMobile
      });
    },
    label: (0,external_wp_i18n_namespaceObject.__)('Mobile', 'blockart')
  })), /*#__PURE__*/React.createElement("label", {
    className: "blockart-control-label",
    htmlFor: "blockart-responsive"
  }, (0,external_wp_i18n_namespaceObject.__)('Responsive', 'blockart')), /*#__PURE__*/React.createElement(toggle, {
    checked: hideOnDesktop || false,
    onChange: function onChange() {
      return setAttributes({
        hideOnDesktop: !hideOnDesktop
      });
    },
    label: (0,external_wp_i18n_namespaceObject.__)('Hide on Desktop', 'blockart')
  }), /*#__PURE__*/React.createElement(toggle, {
    checked: hideOnTablet || false,
    onChange: function onChange() {
      return setAttributes({
        hideOnTablet: !hideOnTablet
      });
    },
    label: (0,external_wp_i18n_namespaceObject.__)('Hide on Tablet', 'blockart')
  }), /*#__PURE__*/React.createElement(toggle, {
    checked: hideOnMobile || false,
    onChange: function onChange() {
      return setAttributes({
        hideOnMobile: !hideOnMobile
      });
    },
    label: (0,external_wp_i18n_namespaceObject.__)('Hide on Mobile', 'blockart')
  }));
};
var BlockCSSSettings = function BlockCSSSettings(_ref3) {
  var className = _ref3.className,
      setAttributes = _ref3.setAttributes,
      _ref3$hasBlockCSS = _ref3.hasBlockCSS,
      hasBlockCSS = _ref3$hasBlockCSS === void 0 ? false : _ref3$hasBlockCSS,
      blockCSS = _ref3.blockCSS;
  return /*#__PURE__*/React.createElement(panel, {
    title: (0,external_wp_i18n_namespaceObject.__)('CSS', 'blockart')
  }, hasBlockCSS && /*#__PURE__*/React.createElement(input, {
    value: blockCSS || '',
    label: (0,external_wp_i18n_namespaceObject.__)('Custom CSS', 'blockart'),
    onChange: function onChange(val) {
      return setAttributes({
        blockCSS: val
      });
    },
    labelPosition: "top"
  }), /*#__PURE__*/React.createElement(input, {
    value: className || '',
    label: (0,external_wp_i18n_namespaceObject.__)('Additional CSS Class(es)', 'blockart'),
    onChange: function onChange(val) {
      return setAttributes({
        className: val
      });
    },
    labelPosition: "top"
  }), /*#__PURE__*/React.createElement("p", null, (0,external_wp_i18n_namespaceObject.__)('Separate multiple classes with spaces.', 'blockart')));
};
;// CONCATENATED MODULE: ./src/blocks/components/index.js





























;// CONCATENATED MODULE: external ["wp","primitives"]
const external_wp_primitives_namespaceObject = window["wp"]["primitives"];
;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/arrow-right.js


/**
 * WordPress dependencies
 */

const arrow_right_arrowRight = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M14.3 6.7l-1.1 1.1 4 4H4v1.5h13.3l-4.1 4.4 1.1 1.1 5.8-6.3z"
}));
/* harmony default export */ const arrow_right = (arrow_right_arrowRight);
//# sourceMappingURL=arrow-right.js.map
;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/arrow-down.js


/**
 * WordPress dependencies
 */

const arrow_down_arrowDown = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M16.2 13.2l-4 4V4h-1.5v13.3l-4.5-4.1-1 1.1 6.2 5.8 5.8-5.8-1-1.1z"
}));
/* harmony default export */ const arrow_down = (arrow_down_arrowDown);
//# sourceMappingURL=arrow-down.js.map
;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/justify-left.js


/**
 * WordPress dependencies
 */

const justifyLeft = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M9 9v6h11V9H9zM4 20h1.5V4H4v16z"
}));
/* harmony default export */ const justify_left = (justifyLeft);
//# sourceMappingURL=justify-left.js.map
;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/justify-center.js


/**
 * WordPress dependencies
 */

const justifyCenter = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M20 9h-7.2V4h-1.6v5H4v6h7.2v5h1.6v-5H20z"
}));
/* harmony default export */ const justify_center = (justifyCenter);
//# sourceMappingURL=justify-center.js.map
;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/justify-right.js


/**
 * WordPress dependencies
 */

const justifyRight = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M4 15h11V9H4v6zM18.5 4v16H20V4h-1.5z"
}));
/* harmony default export */ const justify_right = (justifyRight);
//# sourceMappingURL=justify-right.js.map
;// CONCATENATED MODULE: ./node_modules/@wordpress/icons/build-module/library/justify-space-between.js


/**
 * WordPress dependencies
 */

const justifySpaceBetween = (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, (0,external_wp_element_namespaceObject.createElement)(external_wp_primitives_namespaceObject.Path, {
  d: "M9 15h6V9H9v6zm-5 5h1.5V4H4v16zM18.5 4v16H20V4h-1.5z"
}));
/* harmony default export */ const justify_space_between = (justifySpaceBetween);
//# sourceMappingURL=justify-space-between.js.map
;// CONCATENATED MODULE: ./src/blocks/blocks/buttons/edit.js










var edit_alignBottom = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M15 4H9v11h6V4zM4 18.5V20h16v-1.5H4z"
}));
var edit_alignCenter = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M20 11h-5V4H9v7H4v1.5h5V20h6v-7.5h5z"
}));
var edit_alignTop = /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.SVG, {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 24 24"
}, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Path, {
  d: "M9 20h6V9H9v11zM4 4v1.5h16V4H4z"
}));
var ALLOWED_BLOCK = 'blockart/button-inner';
/* harmony default export */ const edit = ((0,external_wp_compose_namespaceObject.compose)([with_client_id, with_copy_paste_styles])(function (props) {
  var _classnames, _flexGap$value, _flexGap$unit;

  var _props$attributes = props.attributes,
      clientId = _props$attributes.clientId,
      justification = _props$attributes.justification,
      verticalAlignment = _props$attributes.verticalAlignment,
      _props$attributes$ori = _props$attributes.orientation,
      orientation = _props$attributes$ori === void 0 ? 'horizontal' : _props$attributes$ori,
      flexGap = _props$attributes.flexGap,
      flexWrap = _props$attributes.flexWrap,
      blockMargin = _props$attributes.blockMargin,
      blockPadding = _props$attributes.blockPadding,
      blockZIndex = _props$attributes.blockZIndex,
      cssID = _props$attributes.cssID,
      hideOnDesktop = _props$attributes.hideOnDesktop,
      hideOnTablet = _props$attributes.hideOnTablet,
      hideOnMobile = _props$attributes.hideOnMobile,
      className = _props$attributes.className,
      attributes = props.attributes,
      setAttributes = props.setAttributes,
      CopyPasteStylesBlockControl = props.copyPasteStylesBlockControl;
  var Style = use_block_style({
    blockName: 'buttons',
    clientId: clientId,
    attributes: attributes
  });
  var classNames = classnames_default()("blockart-buttons blockart-buttons-".concat(clientId), (_classnames = {}, _defineProperty(_classnames, "is-justification-".concat(justification), !!justification), _defineProperty(_classnames, "is-vertical-alignment-".concat(verticalAlignment), !!verticalAlignment && 'horizontal' === orientation), _defineProperty(_classnames, "is-".concat(orientation), !!orientation), _defineProperty(_classnames, "is-wrap", flexWrap), _classnames), className);
  var style = ".blockart-buttons-".concat(clientId, " .block-editor-block-list__layout{ gap: ").concat((_flexGap$value = flexGap === null || flexGap === void 0 ? void 0 : flexGap.value) !== null && _flexGap$value !== void 0 ? _flexGap$value : 0).concat((_flexGap$unit = flexGap === null || flexGap === void 0 ? void 0 : flexGap.unit) !== null && _flexGap$unit !== void 0 ? _flexGap$unit : 'px', "; }");
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(external_wp_blockEditor_namespaceObject.InspectorControls, null, /*#__PURE__*/React.createElement(tab_panel, {
    root: true
  }, /*#__PURE__*/React.createElement(tab, {
    tabTitle: (0,external_wp_i18n_namespaceObject.__)('Layout', 'blockart')
  }, /*#__PURE__*/React.createElement(layout, {
    block: ['button', 'buttons']
  })), /*#__PURE__*/React.createElement(tab, {
    tabTitle: (0,external_wp_i18n_namespaceObject.__)('Settings', 'blockart')
  }, /*#__PURE__*/React.createElement(panel, {
    title: (0,external_wp_i18n_namespaceObject.__)('General', 'blockart'),
    initialOpen: true
  }, /*#__PURE__*/React.createElement(advance_select, {
    label: (0,external_wp_i18n_namespaceObject.__)('Orientation', 'blockart'),
    value: orientation,
    onChange: function onChange(value) {
      return setAttributes({
        orientation: value
      });
    },
    options: [{
      label: (0,external_wp_i18n_namespaceObject.__)('Horizontal', 'blockart'),
      value: 'horizontal',
      icon: 'arrow-right'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Vertical', 'blockart'),
      value: 'vertical',
      icon: 'arrow-down'
    }]
  }), /*#__PURE__*/React.createElement(toggle, {
    checked: flexWrap !== null && flexWrap !== void 0 ? flexWrap : false,
    label: (0,external_wp_i18n_namespaceObject.__)('Wrap to multiple lines', 'blockart'),
    onChange: function onChange() {
      return setAttributes({
        flexWrap: !flexWrap
      });
    }
  }), /*#__PURE__*/React.createElement(advance_select, {
    label: (0,external_wp_i18n_namespaceObject.__)('Justification', 'blockart'),
    value: justification,
    onChange: function onChange(value) {
      return setAttributes({
        justification: value
      });
    },
    options: [{
      label: (0,external_wp_i18n_namespaceObject.__)('Justify items left', 'blockart'),
      value: 'left',
      icon: 'align-left'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Justify items center', 'blockart'),
      value: 'center',
      icon: 'align-center'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Justify items right', 'blockart'),
      value: 'right',
      icon: 'align-right'
    }].concat('horizontal' === orientation ? [{
      label: (0,external_wp_i18n_namespaceObject.__)('Space between items', 'blockart'),
      value: 'space-between',
      icon: 'align-space-between'
    }] : [])
  }), 'horizontal' === orientation && /*#__PURE__*/React.createElement(advance_select, {
    label: (0,external_wp_i18n_namespaceObject.__)('Vertical Alignment', 'blockart'),
    value: verticalAlignment,
    onChange: function onChange(value) {
      return setAttributes({
        verticalAlignment: value
      });
    },
    options: [{
      label: (0,external_wp_i18n_namespaceObject.__)('Align top', 'blockart'),
      value: 'top',
      icon: 'align-top'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Align middle', 'blockart'),
      value: 'center',
      icon: 'align-middle'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Align bottom', 'blockart'),
      value: 'bottom',
      icon: 'align-bottom'
    }]
  }), /*#__PURE__*/React.createElement(slider, {
    label: (0,external_wp_i18n_namespaceObject.__)('Gap', 'blockart'),
    value: flexGap,
    onChange: function onChange(value) {
      return setAttributes({
        flexGap: value
      });
    },
    min: 0,
    max: 100,
    step: 1,
    units: ['px', 'em', 'rem', '%']
  }))), /*#__PURE__*/React.createElement(tab, {
    tabTitle: (0,external_wp_i18n_namespaceObject.__)('Advanced', 'blockart')
  }, /*#__PURE__*/React.createElement(BlockAdvanceSettings, {
    blockMargin: blockMargin,
    blockPadding: blockPadding,
    blockZIndex: blockZIndex,
    cssID: cssID,
    setAttributes: setAttributes
  }), /*#__PURE__*/React.createElement(BlockResponsiveSettings, {
    hideOnDesktop: hideOnDesktop,
    hideOnTablet: hideOnTablet,
    hideOnMobile: hideOnMobile,
    setAttributes: setAttributes
  }), /*#__PURE__*/React.createElement(BlockCSSSettings, {
    className: className,
    setAttributes: setAttributes,
    hasBlockCSS: false
  })))), /*#__PURE__*/React.createElement(external_wp_blockEditor_namespaceObject.BlockControls, {
    group: "block"
  }, /*#__PURE__*/React.createElement(toolbar_dropdown_control, {
    label: (0,external_wp_i18n_namespaceObject.__)('Change items orientation', 'blockart'),
    value: orientation,
    onChange: function onChange(val) {
      return setAttributes({
        orientation: val
      });
    },
    options: [{
      icon: arrow_right,
      title: (0,external_wp_i18n_namespaceObject.__)('Horizontal', 'blockart'),
      value: 'horizontal'
    }, {
      icon: arrow_down,
      title: (0,external_wp_i18n_namespaceObject.__)('Vertical', 'blockart'),
      value: 'vertical'
    }]
  }), /*#__PURE__*/React.createElement(toolbar_dropdown_control, {
    label: (0,external_wp_i18n_namespaceObject.__)('Change items justification', 'blockart'),
    value: justification,
    onChange: function onChange(val) {
      return setAttributes({
        justification: val
      });
    },
    options: [{
      icon: justify_left,
      title: (0,external_wp_i18n_namespaceObject.__)('Justify items left', 'blockart'),
      value: 'left'
    }, {
      icon: justify_center,
      title: (0,external_wp_i18n_namespaceObject.__)('Justify items center', 'blockart'),
      value: 'center'
    }, {
      icon: justify_right,
      title: (0,external_wp_i18n_namespaceObject.__)('Justify items right', 'blockart'),
      value: 'right'
    }].concat('horizontal' === orientation ? [{
      icon: justify_space_between,
      title: (0,external_wp_i18n_namespaceObject.__)('Space between items', 'blockart'),
      value: 'space-between'
    }] : [])
  }), 'horizontal' === orientation && /*#__PURE__*/React.createElement(toolbar_dropdown_control, {
    label: (0,external_wp_i18n_namespaceObject.__)('Change items alignment', 'blockart'),
    value: verticalAlignment,
    onChange: function onChange(val) {
      return setAttributes({
        verticalAlignment: val
      });
    },
    options: [{
      icon: edit_alignTop,
      title: (0,external_wp_i18n_namespaceObject._x)('Align top', 'Block vertical alignment setting', 'blockart'),
      value: 'top'
    }, {
      icon: edit_alignCenter,
      title: (0,external_wp_i18n_namespaceObject._x)('Align middle', 'Block vertical alignment setting', 'blockart'),
      value: 'center'
    }, {
      icon: edit_alignBottom,
      title: (0,external_wp_i18n_namespaceObject._x)('Align bottom', 'Block vertical alignment setting', 'blockart'),
      value: 'bottom'
    }]
  })), /*#__PURE__*/React.createElement(external_wp_blockEditor_namespaceObject.BlockControls, null, /*#__PURE__*/React.createElement(CopyPasteStylesBlockControl, null)), /*#__PURE__*/React.createElement(Style, null), /*#__PURE__*/React.createElement("style", null, style), /*#__PURE__*/React.createElement("div", {
    className: classNames
  }, /*#__PURE__*/React.createElement(external_wp_blockEditor_namespaceObject.InnerBlocks, {
    allowedBlocks: [ALLOWED_BLOCK],
    template: [[ALLOWED_BLOCK]],
    templateLock: false,
    templateInsertUpdatesSelection: true
  })));
}));
;// CONCATENATED MODULE: ./src/blocks/blocks/buttons/button/edit.js













/* harmony default export */ const button_edit = ((0,external_wp_compose_namespaceObject.compose)([with_client_id, with_device_type, with_copy_paste_styles, (0,external_wp_data_namespaceObject.withSelect)(function (select, ownProps) {
  var _select = select('core/block-editor'),
      getBlockRootClientId = _select.getBlockRootClientId,
      getBlockAttributes = _select.getBlockAttributes;

  var rootClientId = getBlockRootClientId(ownProps.clientId);
  return {
    rootClientId: rootClientId,
    rootBlockAttributes: getBlockAttributes(rootClientId)
  };
}), (0,external_wp_data_namespaceObject.withDispatch)(function (dispatch) {
  var _dispatch = dispatch('core/block-editor'),
      updateBlockAttributes = _dispatch.updateBlockAttributes;

  return {
    updateBlockAttributes: updateBlockAttributes
  };
})])(function (props) {
  var _props$attributes = props.attributes,
      clientId = _props$attributes.clientId,
      link = _props$attributes.link,
      text = _props$attributes.text,
      style = _props$attributes.style,
      size = _props$attributes.size,
      padding = _props$attributes.padding,
      typography = _props$attributes.typography,
      icon = _props$attributes.icon,
      iconPosition = _props$attributes.iconPosition,
      iconGap = _props$attributes.iconGap,
      iconSize = _props$attributes.iconSize,
      color1 = _props$attributes.color1,
      color2 = _props$attributes.color2,
      hoverColor1 = _props$attributes.hoverColor1,
      hoverColor2 = _props$attributes.hoverColor2,
      background1 = _props$attributes.background1,
      background2 = _props$attributes.background2,
      hoverBackground1 = _props$attributes.hoverBackground1,
      hoverBackground2 = _props$attributes.hoverBackground2,
      border1 = _props$attributes.border1,
      hoverBorder1 = _props$attributes.hoverBorder1,
      border2 = _props$attributes.border2,
      hoverBorder2 = _props$attributes.hoverBorder2,
      boxShadow = _props$attributes.boxShadow,
      boxShadowHover = _props$attributes.boxShadowHover,
      blockMargin = _props$attributes.blockMargin,
      blockPadding = _props$attributes.blockPadding,
      blockZIndex = _props$attributes.blockZIndex,
      cssID = _props$attributes.cssID,
      hideOnDesktop = _props$attributes.hideOnDesktop,
      hideOnTablet = _props$attributes.hideOnTablet,
      hideOnMobile = _props$attributes.hideOnMobile,
      className = _props$attributes.className,
      setAttributes = props.setAttributes,
      CopyPasteStylesBlockControl = props.copyPasteStylesBlockControl,
      deviceType = props.deviceType,
      updateBlockAttributes = props.updateBlockAttributes,
      _props$rootBlockAttri = props.rootBlockAttributes,
      _props$rootBlockAttri2 = _props$rootBlockAttri.justification,
      justification = _props$rootBlockAttri2 === void 0 ? undefined : _props$rootBlockAttri2,
      _props$rootBlockAttri3 = _props$rootBlockAttri.verticalAlignment,
      verticalAlignment = _props$rootBlockAttri3 === void 0 ? undefined : _props$rootBlockAttri3,
      _props$rootBlockAttri4 = _props$rootBlockAttri.orientation,
      orientation = _props$rootBlockAttri4 === void 0 ? 'horizontal' : _props$rootBlockAttri4,
      rootClientId = props.rootClientId;
  var Style = use_block_style({
    blockName: 'button',
    clientId: clientId,
    attributes: props.attributes,
    deviceType: deviceType
  });
  var classNames = classnames_default()('blockart-button-link', size && ('filled' === style || 'outline' === style) && "is-".concat(size), style && "is-style-".concat(style));
  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(external_wp_blockEditor_namespaceObject.InspectorControls, null, /*#__PURE__*/React.createElement(tab_panel, {
    root: true
  }, /*#__PURE__*/React.createElement(tab, {
    tabTitle: (0,external_wp_i18n_namespaceObject.__)('Settings', 'blockart')
  }, /*#__PURE__*/React.createElement(panel, {
    title: (0,external_wp_i18n_namespaceObject.__)('General', 'blockart'),
    initialOpen: true
  }, /*#__PURE__*/React.createElement(url_input, {
    label: (0,external_wp_i18n_namespaceObject.__)('URL', 'blockart'),
    onChange: function onChange(val) {
      return setAttributes({
        link: val
      });
    },
    value: link,
    placeholder: "https://",
    newTab: true
  })), /*#__PURE__*/React.createElement(panel, {
    title: (0,external_wp_i18n_namespaceObject.__)('Layout', 'blockart')
  }, ('filled' === style || 'outline' === style) && /*#__PURE__*/React.createElement(components_size, {
    label: (0,external_wp_i18n_namespaceObject.__)('Size', 'blockart'),
    onChange: function onChange(key, val) {
      return setAttributes(_defineProperty({}, key, val));
    },
    value: size,
    defaultKey: "size",
    custom: true,
    customKey: "padding",
    customValue: padding,
    customLabel: (0,external_wp_i18n_namespaceObject.__)('Padding', 'blockart'),
    customMin: 0,
    customMax: 100,
    customUnits: ['px', 'rem', 'em', '%'],
    customDefaultUnit: "px"
  }), /*#__PURE__*/React.createElement(advance_select, {
    value: style,
    onChange: function onChange(val) {
      return setAttributes({
        style: val
      });
    },
    label: (0,external_wp_i18n_namespaceObject.__)('Type', 'blockart'),
    hasLabel: true,
    options: [{
      label: (0,external_wp_i18n_namespaceObject.__)('Fill', 'blockart'),
      value: 'filled',
      icon: 'filled'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Outline', 'blockart'),
      value: 'outline',
      icon: 'outline'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Plain', 'blockart'),
      value: 'plain',
      icon: 'plain'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Link', 'blockart'),
      value: 'link',
      icon: 'link-o'
    }],
    cols: 4
  })), /*#__PURE__*/React.createElement(panel, {
    title: (0,external_wp_i18n_namespaceObject.__)('Icons', 'blockart')
  }, /*#__PURE__*/React.createElement(icon_selector, {
    label: (0,external_wp_i18n_namespaceObject.__)('Enable', 'blockart'),
    value: icon || {},
    onChange: function onChange(val) {
      return setAttributes({
        icon: val
      });
    }
  }), icon.enable && /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(advance_select, {
    label: (0,external_wp_i18n_namespaceObject.__)('Position', 'blockart'),
    value: iconPosition,
    inline: true,
    onChange: function onChange(val) {
      return setAttributes({
        iconPosition: val
      });
    },
    options: [{
      label: (0,external_wp_i18n_namespaceObject.__)('Left', 'blockart'),
      value: 'left',
      icon: 'align-left'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Right', 'blockart'),
      value: 'right',
      icon: 'align-right'
    }]
  }), /*#__PURE__*/React.createElement(slider, {
    label: (0,external_wp_i18n_namespaceObject.__)('Size', 'blockart'),
    min: 0,
    max: 50,
    value: iconSize,
    onChange: function onChange(val) {
      return setAttributes({
        iconSize: val
      });
    },
    responsive: true,
    units: ['px', 'em', '%']
  }), /*#__PURE__*/React.createElement(slider, {
    label: (0,external_wp_i18n_namespaceObject.__)('Gap', 'blockart'),
    min: 0,
    max: 60,
    value: iconGap,
    onChange: function onChange(val) {
      return setAttributes({
        iconGap: val
      });
    },
    responsive: true,
    units: ['px', 'em', '%']
  }))), /*#__PURE__*/React.createElement(panel, {
    title: (0,external_wp_i18n_namespaceObject.__)('Text', 'blockart')
  }, /*#__PURE__*/React.createElement(components_typography, {
    value: typography,
    onChange: function onChange(val) {
      return setAttributes({
        typography: val
      });
    }
  })), /*#__PURE__*/React.createElement(panel, {
    title: (0,external_wp_i18n_namespaceObject.__)('Color', 'blockart')
  }, /*#__PURE__*/React.createElement(tab_panel, null, /*#__PURE__*/React.createElement(tab, {
    tabTitle: (0,external_wp_i18n_namespaceObject.__)('Normal', 'blockart')
  }, /*#__PURE__*/React.createElement(components_color, {
    onChange: function onChange(val) {
      return 'filled' === style ? setAttributes({
        color1: val
      }) : setAttributes({
        color2: val
      });
    },
    label: (0,external_wp_i18n_namespaceObject.__)('Color', 'blockart'),
    value: 'filled' === style ? color1 : color2
  }), style && (style === 'outline' || style === 'filled') && /*#__PURE__*/React.createElement(components_background, {
    value: 'filled' === style ? background1 : background2,
    onChange: function onChange(val) {
      return 'filled' === style ? setAttributes({
        background1: val
      }) : setAttributes({
        background2: val
      });
    },
    label: (0,external_wp_i18n_namespaceObject.__)('Background', 'blockart')
  })), /*#__PURE__*/React.createElement(tab, {
    tabTitle: (0,external_wp_i18n_namespaceObject.__)('Hover', 'blockart')
  }, /*#__PURE__*/React.createElement(components_color, {
    onChange: function onChange(val) {
      return 'filled' === style ? setAttributes({
        hoverColor1: val
      }) : setAttributes({
        hoverColor2: val
      });
    },
    label: (0,external_wp_i18n_namespaceObject.__)('Color', 'blockart'),
    value: 'filled' === style ? hoverColor1 : hoverColor2
  }), style && (style === 'outline' || style === 'filled') && /*#__PURE__*/React.createElement(components_background, {
    value: 'filled' === style ? hoverBackground1 : hoverBackground2,
    onChange: function onChange(val) {
      return 'filled' === style ? setAttributes({
        hoverBackground1: val
      }) : setAttributes({
        hoverBackground2: val
      });
    },
    label: (0,external_wp_i18n_namespaceObject.__)('Background', 'blockart')
  })))), style && (style === 'outline' || style === 'filled') && /*#__PURE__*/React.createElement(panel, {
    title: (0,external_wp_i18n_namespaceObject.__)('Border', 'blockart')
  }, /*#__PURE__*/React.createElement(tab_panel, null, /*#__PURE__*/React.createElement(tab, {
    tabTitle: (0,external_wp_i18n_namespaceObject.__)('Normal', 'blockart')
  }, /*#__PURE__*/React.createElement(components_border, {
    value: 'filled' === style ? border1 : border2,
    onChange: function onChange(val) {
      return 'filled' === style ? setAttributes({
        border1: val
      }) : setAttributes({
        border2: val
      });
    }
  }), /*#__PURE__*/React.createElement(box_shadow, {
    value: boxShadow,
    onChange: function onChange(val) {
      return setAttributes({
        boxShadow: val
      });
    }
  })), /*#__PURE__*/React.createElement(tab, {
    tabTitle: (0,external_wp_i18n_namespaceObject.__)('Hover', 'blockart')
  }, /*#__PURE__*/React.createElement(components_border, {
    value: 'filled' === style ? hoverBorder1 : hoverBorder2,
    onChange: function onChange(val) {
      return 'filled' === style ? setAttributes({
        hoverBorder1: val
      }) : setAttributes({
        hoverBorder2: val
      });
    }
  }), /*#__PURE__*/React.createElement(box_shadow, {
    value: boxShadowHover,
    onChange: function onChange(val) {
      return setAttributes({
        boxShadowHover: val
      });
    }
  }))))), /*#__PURE__*/React.createElement(tab, {
    tabTitle: (0,external_wp_i18n_namespaceObject.__)('Advanced', 'blockart')
  }, /*#__PURE__*/React.createElement(BlockAdvanceSettings, {
    blockMargin: blockMargin,
    blockPadding: blockPadding,
    blockZIndex: blockZIndex,
    cssID: cssID,
    setAttributes: setAttributes
  }), /*#__PURE__*/React.createElement(BlockResponsiveSettings, {
    hideOnDesktop: hideOnDesktop,
    hideOnTablet: hideOnTablet,
    hideOnMobile: hideOnMobile,
    setAttributes: setAttributes
  }), /*#__PURE__*/React.createElement(BlockCSSSettings, {
    className: className,
    setAttributes: setAttributes,
    hasBlockCSS: false
  })))), /*#__PURE__*/React.createElement(external_wp_blockEditor_namespaceObject.BlockControls, {
    group: "block"
  }, /*#__PURE__*/React.createElement(toolbar_dropdown_control, {
    label: (0,external_wp_i18n_namespaceObject.__)('Change items orientation', 'blockart'),
    value: orientation,
    onChange: function onChange(val) {
      return updateBlockAttributes(rootClientId, {
        orientation: val
      });
    },
    options: [{
      icon: arrow_right,
      title: (0,external_wp_i18n_namespaceObject.__)('Horizontal', 'blockart'),
      value: 'horizontal'
    }, {
      icon: arrow_down,
      title: (0,external_wp_i18n_namespaceObject.__)('Vertical', 'blockart'),
      value: 'vertical'
    }]
  }), /*#__PURE__*/React.createElement(toolbar_dropdown_control, {
    label: (0,external_wp_i18n_namespaceObject.__)('Change items justification', 'blockart'),
    value: justification,
    onChange: function onChange(val) {
      return updateBlockAttributes(rootClientId, {
        justification: val
      });
    },
    options: [{
      icon: justify_left,
      title: (0,external_wp_i18n_namespaceObject.__)('Justify items left', 'blockart'),
      value: 'left'
    }, {
      icon: justify_center,
      title: (0,external_wp_i18n_namespaceObject.__)('Justify items center', 'blockart'),
      value: 'center'
    }, {
      icon: justify_right,
      title: (0,external_wp_i18n_namespaceObject.__)('Justify items right', 'blockart'),
      value: 'right'
    }].concat('vertical' !== justification ? [{
      icon: justify_space_between,
      title: (0,external_wp_i18n_namespaceObject.__)('Space between items', 'blockart'),
      value: 'space-between'
    }] : [])
  }), 'vertical' !== justification && /*#__PURE__*/React.createElement(toolbar_dropdown_control, {
    label: (0,external_wp_i18n_namespaceObject.__)('Change items alignment', 'blockart'),
    value: verticalAlignment,
    onChange: function onChange(val) {
      return updateBlockAttributes(rootClientId, {
        verticalAlignment: val
      });
    },
    options: [{
      icon: edit_alignTop,
      title: (0,external_wp_i18n_namespaceObject._x)('Align top', 'Block vertical alignment setting', 'blockart'),
      value: 'top'
    }, {
      icon: edit_alignCenter,
      title: (0,external_wp_i18n_namespaceObject._x)('Align middle', 'Block vertical alignment setting', 'blockart'),
      value: 'center'
    }, {
      icon: edit_alignBottom,
      title: (0,external_wp_i18n_namespaceObject._x)('Align bottom', 'Block vertical alignment setting', 'blockart'),
      value: 'bottom'
    }]
  })), /*#__PURE__*/React.createElement(external_wp_blockEditor_namespaceObject.BlockControls, null, /*#__PURE__*/React.createElement(CopyPasteStylesBlockControl, null)), /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(Style, null), /*#__PURE__*/React.createElement("div", {
    id: cssID ? cssID : null,
    className: (0,external_wp_hooks_namespaceObject.applyFilters)('blockart.button.classnames', classnames_default()("blockart-button blockart-button-".concat(clientId), className))
  }, /*#__PURE__*/React.createElement("div", {
    className: classNames
  }, icon && '' !== icon.icon && icon.enable && 'left' === iconPosition && /*#__PURE__*/React.createElement("span", {
    className: "blockart-button-icon"
  }, /*#__PURE__*/React.createElement(components_icon, {
    type: "frontendIcon",
    name: icon.icon
  })), /*#__PURE__*/React.createElement(external_wp_blockEditor_namespaceObject.RichText, {
    value: text,
    placeholder: (0,external_wp_i18n_namespaceObject.__)('Text Here', 'blockart'),
    onChange: function onChange(val) {
      setAttributes({
        text: val
      });
    },
    allowedFormats: ['core/bold', 'core/italic']
  }), icon && '' !== icon.icon && icon.enable && 'right' === iconPosition && /*#__PURE__*/React.createElement("span", {
    className: "blockart-button-icon"
  }, /*#__PURE__*/React.createElement(components_icon, {
    type: "frontendIcon",
    name: icon.icon
  }))))));
}));
;// CONCATENATED MODULE: ./src/blocks/blocks/buttons/button/save.js




/* harmony default export */ const save = (function (_ref) {
  var _ref$attributes = _ref.attributes,
      clientId = _ref$attributes.clientId,
      text = _ref$attributes.text,
      className = _ref$attributes.className,
      cssID = _ref$attributes.cssID,
      link = _ref$attributes.link,
      size = _ref$attributes.size,
      style = _ref$attributes.style,
      icon = _ref$attributes.icon,
      iconPosition = _ref$attributes.iconPosition;
  var classNames = classnames_default()('blockart-button-link', size && "is-".concat(size), style && "is-style-".concat(style));
  return /*#__PURE__*/React.createElement("div", {
    id: cssID !== null && cssID !== void 0 ? cssID : undefined,
    className: (0,external_wp_hooks_namespaceObject.applyFilters)('blockart.button.classnames', classnames_default()("blockart-button blockart-button-".concat(clientId, " "), className))
  }, /*#__PURE__*/React.createElement(components_element, {
    tagName: "a",
    htmlAttrs: {
      className: classNames,
      href: link && link.url ? link.url : null,
      target: link && link.newTab ? '_blank' : null,
      rel: link && link.newTab ? 'noopener' : null
    }
  }, icon && '' !== icon.icon && icon.enable && 'left' === iconPosition && /*#__PURE__*/React.createElement("span", {
    className: "blockart-button-icon"
  }, /*#__PURE__*/React.createElement(components_icon, {
    type: "frontendIcon",
    name: icon.icon
  })), /*#__PURE__*/React.createElement(external_wp_blockEditor_namespaceObject.RichText.Content, {
    value: text
  }), icon && '' !== icon.icon && icon.enable && 'right' === iconPosition && /*#__PURE__*/React.createElement("span", {
    className: "blockart-button-icon"
  }, /*#__PURE__*/React.createElement(components_icon, {
    type: "frontendIcon",
    name: icon.icon
  }))));
});
;// CONCATENATED MODULE: ./src/blocks/blocks/buttons/button/attributes.js


function attributes_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function attributes_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? attributes_ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : attributes_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }


/* harmony default export */ const button_attributes = (attributes_objectSpread({
  clientId: {
    type: 'string'
  },
  link: {
    type: 'object'
  },
  text: {
    type: 'string'
  },
  style: {
    type: 'string',
    "default": 'filled'
  },
  size: {
    type: 'string',
    "default": 'large'
  },
  padding: {
    type: 'object',
    "default": {
      dimension: 1,
      desktop: {
        lock: true
      }
    },
    style: [{
      condition: [{
        key: 'size',
        relation: '==',
        value: 'custom'
      }, {
        key: 'style',
        relation: '!=',
        value: 'plain'
      }, {
        key: 'style',
        relation: '!=',
        value: 'link'
      }],
      selector: '{{WRAPPER}} .blockart-button-link.is-custom { padding: {{VALUE}}; }'
    }]
  },
  typography: {
    type: 'object',
    "default": {
      typography: 1
    },
    style: [{
      selector: '{{WRAPPER}} .blockart-button-link'
    }]
  },
  icon: {
    type: 'object',
    "default": {
      enable: false,
      icon: ''
    }
  },
  iconPosition: {
    type: 'string',
    "default": 'right'
  },
  iconSize: {
    type: 'object',
    style: [{
      condition: [{
        key: 'icon',
        relation: '!=',
        value: ''
      }],
      selector: '{{WRAPPER}} .blockart-button-icon .blockart-icon { width: {{VALUE}}; height: auto; }'
    }]
  },
  iconGap: {
    type: 'object',
    style: [{
      condition: [{
        key: 'icon',
        relation: '!=',
        value: ''
      }, {
        key: 'iconPosition',
        relation: '==',
        value: 'left'
      }],
      selector: '{{WRAPPER}} .blockart-button-icon { margin-right: {{VALUE}}; }'
    }, {
      condition: [{
        key: 'icon',
        relation: '!=',
        value: ''
      }, {
        key: 'iconPosition',
        relation: '==',
        value: 'right'
      }],
      selector: '{{WRAPPER}} .blockart-button-icon { margin-left: {{VALUE}}; }'
    }]
  },
  color1: {
    type: 'string',
    "default": '#fff',
    style: [{
      condition: [{
        key: 'style',
        relation: '==',
        value: 'filled'
      }],
      selector: '{{WRAPPER}} .blockart-button-link { color: {{VALUE}}; }' + '{{WRAPPER}} .blockart-button-icon .blockart-icon { fill: {{VALUE}}; }'
    }]
  },
  color2: {
    type: 'string',
    "default": '#2563EB',
    style: [{
      condition: [{
        key: 'style',
        relation: '!=',
        value: 'filled'
      }],
      selector: '{{WRAPPER}} .blockart-button-link{ color: {{VALUE}}; }' + '{{WRAPPER}} .blockart-button-icon .blockart-icon { fill: {{VALUE}}; }'
    }]
  },
  hoverColor1: {
    type: 'string',
    "default": '',
    style: [{
      condition: [{
        key: 'style',
        relation: '==',
        value: 'filled'
      }],
      selector: '{{WRAPPER}} .blockart-button-link:hover { color: {{VALUE}} }' + '{{WRAPPER}} .blockart-button-link:hover .blockart-button-icon .blockart-icon { fill: {{VALUE}} }' + '{{WRAPPER}} .blockart-button-link:focus { color: {{VALUE}} }' + '{{WRAPPER}} .blockart-button-link:focus .blockart-button-icon .blockart-icon { fill: {{VALUE}} }' + '{{WRAPPER}} .blockart-button-link:active { color: {{VALUE}} }' + '{{WRAPPER}} .blockart-button-link:active .blockart-button-icon .blockart-icon { fill: {{VALUE}} }'
    }]
  },
  hoverColor2: {
    type: 'string',
    "default": '',
    style: [{
      condition: [{
        key: 'style',
        relation: '!=',
        value: 'filled'
      }],
      selector: '{{WRAPPER}} .blockart-button-link:hover { color: {{VALUE}} }' + '{{WRAPPER}} .blockart-button-link:hover .blockart-button-icon .blockart-icon { fill: {{VALUE}} }' + '{{WRAPPER}} .blockart-button-link:focus { color: {{VALUE}} }' + '{{WRAPPER}} .blockart-button-link:focus .blockart-button-icon .blockart-icon { fill: {{VALUE}} }' + '{{WRAPPER}} .blockart-button-link:active { color: {{VALUE}} }' + '{{WRAPPER}} .blockart-button-link:active .blockart-button-icon .blockart-icon { fill: {{VALUE}} }'
    }]
  },
  background1: {
    type: 'object',
    "default": {
      background: 1,
      type: 'color',
      color: '#2563eb'
    },
    style: [{
      condition: [{
        key: 'style',
        relation: '==',
        value: 'filled'
      }],
      selector: '{{WRAPPER}} .blockart-button-link'
    }]
  },
  background2: {
    type: 'object',
    "default": {
      background: 1
    },
    style: [{
      condition: [{
        key: 'style',
        relation: '==',
        value: 'outline'
      }],
      selector: '{{WRAPPER}} .blockart-button-link.is-style-outline'
    }]
  },
  hoverBackground1: {
    type: 'object',
    "default": {
      background: 1
    },
    style: [{
      condition: [{
        key: 'style',
        relation: '==',
        value: 'filled'
      }],
      selector: '{{WRAPPER}} .blockart-button-link:hover, {{WRAPPER}} .blockart-button-link:focus, {{WRAPPER}} .blockart-button-link:active'
    }]
  },
  hoverBackground2: {
    type: 'object',
    "default": {
      background: 1
    },
    style: [{
      condition: [{
        key: 'style',
        relation: '==',
        value: 'outline'
      }],
      selector: '{{WRAPPER}} .blockart-button-link.is-style-outline:hover, {{WRAPPER}} .blockart-button-link.is-style-outline:focus, {{WRAPPER}} .blockart-button-link.is-style-outline:active'
    }]
  },
  border1: {
    type: 'object',
    "default": {
      border: 1,
      radius: {
        desktop: {
          lock: true
        }
      },
      size: {
        desktop: {
          lock: true
        }
      }
    },
    style: [{
      condition: [{
        key: 'style',
        relation: '==',
        value: 'filled'
      }],
      selector: '{{WRAPPER}} .blockart-button-link'
    }]
  },
  hoverBorder1: {
    type: 'object',
    "default": {
      border: 1,
      radius: {
        desktop: {
          lock: true
        }
      },
      size: {
        desktop: {
          lock: true
        }
      }
    },
    style: [{
      condition: [{
        key: 'style',
        relation: '==',
        value: 'filled'
      }],
      selector: '{{WRAPPER}} .blockart-button-link:hover, {{WRAPPER}} .blockart-button-link:focus, {{WRAPPER}} .blockart-button-link:active'
    }]
  },
  border2: {
    type: 'object',
    "default": {
      border: 1,
      color: '#2563EB',
      type: 'solid',
      radius: {
        desktop: {
          top: 2,
          right: 2,
          bottom: 2,
          left: 2,
          unit: 'px',
          lock: true
        }
      },
      size: {
        desktop: {
          top: 1,
          right: 1,
          bottom: 1,
          left: 1,
          unit: 'px',
          lock: true
        }
      }
    },
    style: [{
      condition: [{
        key: 'style',
        relation: '==',
        value: 'outline'
      }],
      selector: '{{WRAPPER}} .blockart-button-link'
    }]
  },
  hoverBorder2: {
    type: 'object',
    "default": {
      border: 1,
      radius: {
        desktop: {
          lock: true
        }
      },
      size: {
        desktop: {
          lock: true
        }
      }
    },
    style: [{
      condition: [{
        key: 'style',
        relation: '==',
        value: 'outline'
      }],
      selector: '{{WRAPPER}} .blockart-button-link:hover, {{WRAPPER}} .blockart-button-link:focus, {{WRAPPER}} .blockart-button-link:active'
    }]
  },
  boxShadow: {
    type: 'object',
    "default": {
      boxShadow: 1
    },
    style: [{
      selector: '{{WRAPPER}} .blockart-button-link'
    }]
  },
  boxShadowHover: {
    type: 'object',
    "default": {
      boxShadow: 1
    },
    style: [{
      selector: '{{WRAPPER}} .blockart-button-link:hover, {{WRAPPER}} .blockart-button-link:focus, {{WRAPPER}} .blockart-button-link:active'
    }]
  }
}, blockAttributes));
;// CONCATENATED MODULE: ./src/blocks/blocks/buttons/button/block.json
const block_namespaceObject = JSON.parse('{"$schema":"https://schemas.wp.org/trunk/block.json","name":"blockart/button-inner","title":"Button","description":"Redirect users to your important pages or websites by clicking button.","keywords":["button","icon"],"category":"blockart","textdomain":"blockart","parent":["blockart/button"],"supports":{"className":false,"customClassName":false,"reusable":false},"example":{"attributes":{}},"style":"blockart-blocks","editorScript":"blockart-blocks","editorStyle":"blockart-blocks-editor"}');
;// CONCATENATED MODULE: ./src/blocks/blocks/buttons/button/index.js


function button_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function button_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? button_ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : button_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }








/* harmony default export */ const buttons_button = (function () {
  (0,external_wp_blocks_namespaceObject.registerBlockType)('blockart/button-inner', button_objectSpread(button_objectSpread({}, block_namespaceObject), {}, {
    icon: /*#__PURE__*/React.createElement(components_icon, {
      type: "blockIcon",
      name: "button",
      size: 24
    }),
    attributes: button_attributes,
    edit: button_edit,
    save: save
  }));
});
;// CONCATENATED MODULE: ./src/blocks/blocks/buttons/save.js



/* harmony default export */ const buttons_save = (function (_ref) {
  var _classnames;

  var _ref$attributes = _ref.attributes,
      clientId = _ref$attributes.clientId,
      className = _ref$attributes.className,
      justification = _ref$attributes.justification,
      verticalAlignment = _ref$attributes.verticalAlignment,
      orientation = _ref$attributes.orientation,
      flexWrap = _ref$attributes.flexWrap;
  var classNames = classnames_default()("blockart-buttons blockart-buttons-".concat(clientId), (_classnames = {}, _defineProperty(_classnames, "is-justification-".concat(justification), !!justification), _defineProperty(_classnames, "is-vertical-alignment-".concat(verticalAlignment), !!verticalAlignment && 'horizontal' === orientation), _defineProperty(_classnames, "is-".concat(orientation), !!orientation), _defineProperty(_classnames, "is-wrap", flexWrap), _classnames), className);
  return /*#__PURE__*/React.createElement("div", {
    className: classNames
  }, /*#__PURE__*/React.createElement(external_wp_blockEditor_namespaceObject.InnerBlocks.Content, null));
});
;// CONCATENATED MODULE: ./src/blocks/blocks/buttons/block.json
const buttons_block_namespaceObject = JSON.parse('{"$schema":"https://schemas.wp.org/trunk/block.json","name":"blockart/button","title":"Buttons","description":"Redirect users to your important pages or websites by clicking button.","keywords":["button","icon"],"category":"blockart","textdomain":"blockart","supports":{"className":false,"customClassName":false,"html":false},"example":{"attributes":{}},"style":"blockart-blocks","editorScript":"blockart-blocks","editorStyle":"blockart-blocks-editor"}');
;// CONCATENATED MODULE: ./src/blocks/blocks/buttons/attributes.js


function buttons_attributes_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function buttons_attributes_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? buttons_attributes_ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : buttons_attributes_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }


/* harmony default export */ const buttons_attributes = (buttons_attributes_objectSpread({
  clientId: {
    type: 'string'
  },
  justification: {
    type: 'string'
  },
  verticalAlignment: {
    type: 'string'
  },
  orientation: {
    type: 'string',
    "default": 'horizontal'
  },
  flexWrap: {
    type: 'boolean',
    "default": true
  },
  flexGap: {
    type: 'object',
    "default": {
      value: 8,
      unit: 'px'
    },
    style: [{
      selector: '{{WRAPPER}} { gap: {{VALUE}}; }'
    }]
  }
}, blockAttributes));
;// CONCATENATED MODULE: ./src/blocks/blocks/buttons/deprecated/v1.js


function v1_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function v1_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? v1_ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : v1_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }







/* harmony default export */ const v1 = ({
  attributes: v1_objectSpread(v1_objectSpread({}, button_attributes), {}, {
    alignment: {
      type: 'object'
    }
  }),
  supports: {
    className: false,
    align: false,
    color: {
      background: false,
      gradient: false,
      text: false
    }
  },
  save: function save(props) {
    var _props$attributes = props.attributes,
        clientId = _props$attributes.clientId,
        text = _props$attributes.text,
        className = _props$attributes.className,
        cssID = _props$attributes.cssID,
        link = _props$attributes.link,
        size = _props$attributes.size,
        style = _props$attributes.style,
        icon = _props$attributes.icon,
        iconPosition = _props$attributes.iconPosition;
    var classNames = classnames_default()('blockart-button-link', size && "is-".concat(size), style && "is-style-".concat(style));
    return /*#__PURE__*/React.createElement("div", {
      id: cssID ? cssID : null,
      className: (0,external_wp_hooks_namespaceObject.applyFilters)('blockart.button.classnames', classnames_default()("blockart-button blockart-button-".concat(clientId, " "), className))
    }, /*#__PURE__*/React.createElement(components_element, {
      tagName: "a",
      htmlAttrs: {
        className: classNames,
        href: link && link.url ? link.url : null,
        target: link && link.newTab ? '_blank' : null,
        rel: link && link.newTab ? 'noopener' : null
      }
    }, icon && '' !== icon.icon && icon.enable && 'left' === iconPosition && /*#__PURE__*/React.createElement("span", {
      className: "blockart-button-icon"
    }, /*#__PURE__*/React.createElement(components_icon, {
      type: "frontendIcon",
      name: icon.icon,
      role: "img"
    })), /*#__PURE__*/React.createElement(external_wp_blockEditor_namespaceObject.RichText.Content, {
      value: text
    }), icon && '' !== icon.icon && icon.enable && 'right' === iconPosition && /*#__PURE__*/React.createElement("span", {
      className: "blockart-button-icon"
    }, /*#__PURE__*/React.createElement(components_icon, {
      type: "frontendIcon",
      name: icon.icon,
      role: "img"
    }))));
  },
  migrate: function migrate(attrs) {
    var _attrs$alignment;

    var newInnerBlocks = [(0,external_wp_blocks_namespaceObject.createBlock)('blockart/button-inner', v1_objectSpread({}, attrs))];
    return [{
      justification: attrs === null || attrs === void 0 ? void 0 : (_attrs$alignment = attrs.alignment) === null || _attrs$alignment === void 0 ? void 0 : _attrs$alignment.desktop
    }, newInnerBlocks];
  }
});
;// CONCATENATED MODULE: ./src/blocks/blocks/buttons/deprecated/v2.js


function v2_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function v2_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? v2_ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : v2_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }







/* harmony default export */ const v2 = ({
  attributes: v2_objectSpread(v2_objectSpread({}, button_attributes), {}, {
    alignment: {
      type: 'object'
    }
  }),
  supports: {
    className: false,
    align: false,
    color: {
      background: false,
      gradient: false,
      text: false
    }
  },
  save: function save(props) {
    var _props$attributes = props.attributes,
        clientId = _props$attributes.clientId,
        text = _props$attributes.text,
        className = _props$attributes.className,
        cssID = _props$attributes.cssID,
        link = _props$attributes.link,
        size = _props$attributes.size,
        style = _props$attributes.style,
        icon = _props$attributes.icon,
        iconPosition = _props$attributes.iconPosition;
    var classNames = classnames_default()('blockart-button-link', size && "is-".concat(size), style && "is-style-".concat(style));
    return /*#__PURE__*/React.createElement("div", {
      id: cssID ? cssID : null,
      className: (0,external_wp_hooks_namespaceObject.applyFilters)('blockart.button.classnames', classnames_default()("blockart-button blockart-button-".concat(clientId, " "), className))
    }, /*#__PURE__*/React.createElement(components_element, {
      tagName: "a",
      htmlAttrs: {
        className: classNames,
        href: link && link.url ? link.url : null,
        target: link && link.newTab ? '_blank' : null,
        rel: link && link.newTab ? 'noopener' : null
      }
    }, icon && '' !== icon.icon && icon.enable && 'left' === iconPosition && /*#__PURE__*/React.createElement("span", {
      className: "blockart-button-icon"
    }, /*#__PURE__*/React.createElement(components_icon, {
      type: "frontendIcon",
      name: icon.icon
    })), /*#__PURE__*/React.createElement(external_wp_blockEditor_namespaceObject.RichText.Content, {
      value: text
    }), icon && '' !== icon.icon && icon.enable && 'right' === iconPosition && /*#__PURE__*/React.createElement("span", {
      className: "blockart-button-icon"
    }, /*#__PURE__*/React.createElement(components_icon, {
      type: "frontendIcon",
      name: icon.icon
    }))));
  },
  migrate: function migrate(attrs) {
    var _attrs$alignment;

    var newInnerBlocks = [(0,external_wp_blocks_namespaceObject.createBlock)('blockart/button-inner', v2_objectSpread({}, attrs))];
    return [{
      justification: attrs === null || attrs === void 0 ? void 0 : (_attrs$alignment = attrs.alignment) === null || _attrs$alignment === void 0 ? void 0 : _attrs$alignment.desktop
    }, newInnerBlocks];
  }
});
;// CONCATENATED MODULE: ./src/blocks/blocks/buttons/deprecated/index.js


;// CONCATENATED MODULE: ./src/blocks/blocks/buttons/index.js


function buttons_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function buttons_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? buttons_ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : buttons_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }










/* harmony default export */ const blocks_buttons = (function () {
  (0,external_wp_blocks_namespaceObject.registerBlockType)('blockart/button', buttons_objectSpread(buttons_objectSpread({}, buttons_block_namespaceObject), {}, {
    icon: /*#__PURE__*/React.createElement(components_icon, {
      type: "blockIcon",
      name: "buttons",
      size: 24
    }),
    attributes: buttons_attributes,
    edit: edit,
    save: buttons_save,
    deprecated: [v1, v2]
  }));
});
;// CONCATENATED MODULE: ./src/blocks/blocks/section/column/edit.js




function edit_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function edit_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? edit_ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : edit_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }














/* harmony default export */ const column_edit = ((0,external_wp_compose_namespaceObject.compose)([with_device_type, with_copy_paste_styles])(function (props) {
  var _window, _window2, _window3, _window$frames, _window$frames$editor;

  var _useState = (0,external_wp_element_namespaceObject.useState)({
    colWidth: {
      desktop: 0,
      tablet: 0,
      mobile: 0
    },
    nextColWidth: {
      desktop: 0,
      tablet: 0,
      mobile: 0
    },
    prevColWidth: {
      desktop: 0,
      tablet: 0,
      mobile: 0
    }
  }),
      _useState2 = slicedToArray_slicedToArray(_useState, 2),
      state = _useState2[0],
      setState = _useState2[1];

  var _props$attributes = props.attributes,
      clientId = _props$attributes.clientId,
      colWidth = _props$attributes.colWidth,
      background = _props$attributes.background,
      hoverBackground = _props$attributes.hoverBackground,
      border = _props$attributes.border,
      borderHover = _props$attributes.borderHover,
      boxShadow = _props$attributes.boxShadow,
      boxShadowHover = _props$attributes.boxShadowHover,
      blockMargin = _props$attributes.blockMargin,
      blockPadding = _props$attributes.blockPadding,
      blockZIndex = _props$attributes.blockZIndex,
      hideOnDesktop = _props$attributes.hideOnDesktop,
      hideOnTablet = _props$attributes.hideOnTablet,
      hideOnMobile = _props$attributes.hideOnMobile,
      cssID = _props$attributes.cssID,
      className = _props$attributes.className,
      setAttributes = props.setAttributes,
      deviceType = props.deviceType,
      CopyPasteStylesBlockControl = props.copyPasteStylesBlockControl;
  var document = _BLOCKART_.isWP59OrAbove && 'widgets' !== ((_window = window) === null || _window === void 0 ? void 0 : _window.pagenow) && 'customize' !== ((_window2 = window) === null || _window2 === void 0 ? void 0 : _window2.pagenow) && ('site-editor' === ((_window3 = window) === null || _window3 === void 0 ? void 0 : _window3.pagenow) || 'tablet' === deviceType || 'mobile' === deviceType) ? (_window$frames = window.frames) === null || _window$frames === void 0 ? void 0 : (_window$frames$editor = _window$frames['editor-canvas']) === null || _window$frames$editor === void 0 ? void 0 : _window$frames$editor.document : window.document;
  (0,external_wp_element_namespaceObject.useEffect)(function () {
    var id = props.clientId.substr(0, 8);

    if (!clientId) {
      setAttributes({
        clientId: id
      });
    } else if (clientId && clientId !== id) {
      if (document.querySelectorAll(".blockart-column-".concat(clientId)).length > 1) {
        setAttributes({
          clientId: id
        });
      }
    }

    updateColumnWidthAttribute();
  }, [deviceType]);
  var Style = use_block_style({
    blockName: 'column',
    clientId: clientId,
    attributes: props.attributes,
    deviceType: deviceType
  });
  var classNames = (0,external_wp_hooks_namespaceObject.applyFilters)('blockart.column.classnames', classnames_default()("blockart-column blockart-column-".concat(clientId), className));

  var updateColumnWidthAttribute = function updateColumnWidthAttribute() {
    var currentColumn = document.getElementById("block-".concat(props.clientId));
    var rowWidth = currentColumn.closest('.blockart-section').clientWidth;
    currentColumn.style.width = colWidth[deviceType] + '%';
    setState(edit_objectSpread(edit_objectSpread({}, state), {}, {
      rowWidth: rowWidth,
      colWidth: edit_objectSpread({}, colWidth)
    }));
  };

  var _onChange = function onChange(value) {
    var _select = (0,external_wp_data_namespaceObject.select)('core/block-editor'),
        getPreviousBlockClientId = _select.getPreviousBlockClientId,
        getNextBlockClientId = _select.getNextBlockClientId,
        getBlockAttributes = _select.getBlockAttributes;

    var _dispatch = (0,external_wp_data_namespaceObject.dispatch)('core/block-editor'),
        updateBlockAttributes = _dispatch.updateBlockAttributes;

    var currentColumn = document.getElementById("block-".concat(props.clientId));
    var siblingColumns = getSiblings(currentColumn);
    var nextColumn = currentColumn.nextElementSibling;
    var prevColumn = currentColumn.previousElementSibling;
    var diffWidth = parseFloat(value[deviceType]) - parseFloat(colWidth[deviceType]);

    if ('desktop' === deviceType) {
      if (siblingColumns.length > 0) {
        if (null !== nextColumn) {
          var nextColumnBlockClientId = getNextBlockClientId(props.clientId);
          var nextColumnBlockAttr = getBlockAttributes(nextColumnBlockClientId);

          var nextColumnBlockWidth = edit_objectSpread({}, nextColumnBlockAttr.colWidth);

          if (parseFloat(colWidth[deviceType]) >= 0 && parseFloat(nextColumnBlockWidth[deviceType]) >= 0 && parseFloat(value[deviceType]) <= parseFloat(nextColumnBlockWidth[deviceType]) + parseFloat(colWidth[deviceType])) {
            nextColumnBlockWidth[deviceType] = parseFloat(nextColumnBlockWidth[deviceType]) - diffWidth;
            nextColumn.style.width = nextColumnBlockWidth[deviceType] + '%';
            currentColumn.style.width = value[deviceType] + '%';
            updateBlockAttributes(nextColumnBlockClientId, Object.assign(nextColumnBlockAttr, {
              colWidth: edit_objectSpread({}, nextColumnBlockWidth)
            }));
            setAttributes({
              colWidth: edit_objectSpread({}, value)
            });
          }
        } else if (null !== prevColumn) {
          var prevColumnBlockClientId = getPreviousBlockClientId(props.clientId);
          var prevColumnBlockAttr = getBlockAttributes(prevColumnBlockClientId);

          var prevColumnBlockWidth = edit_objectSpread({}, prevColumnBlockAttr.colWidth);

          if (parseFloat(colWidth[deviceType]) >= 0 && parseFloat(prevColumnBlockWidth[deviceType]) >= 0 && parseFloat(value[deviceType]) <= parseFloat(prevColumnBlockWidth[deviceType]) + parseFloat(colWidth[deviceType])) {
            prevColumnBlockWidth[deviceType] = parseFloat(prevColumnBlockWidth[deviceType]) - diffWidth;
            prevColumn.style.width = prevColumnBlockWidth[deviceType] + '%';
            currentColumn.style.width = value[deviceType] + '%';
            updateBlockAttributes(prevColumnBlockClientId, Object.assign(prevColumnBlockAttr, {
              colWidth: edit_objectSpread({}, prevColumnBlockWidth)
            }));
            setAttributes({
              colWidth: edit_objectSpread({}, value)
            });
          }
        }
      }
    } else {
      currentColumn.style.width = value[deviceType] + '%';
      setAttributes({
        colWidth: edit_objectSpread({}, value)
      });
    }
  };

  var _onResizeStart = function onResizeStart() {
    var toggleSelection = props.toggleSelection;
    toggleSelection(false);
    setState(edit_objectSpread(edit_objectSpread({}, state), {}, {
      absWidth: document.getElementById("block-".concat(props.clientId)).getBoundingClientRect().width
    }));
  };

  var _onResize = function onResize(event, direction, elt, delta) {
    var currentColumn = document.getElementById("block-".concat(props.clientId));
    var nextColumn = currentColumn.nextElementSibling;
    var currentColumnWidth = state.absWidth + delta.width;
    var absWidth = currentColumnWidth / state.rowWidth * 100;
    var diffWidth = parseFloat(colWidth[deviceType]) - absWidth;

    var _select2 = (0,external_wp_data_namespaceObject.select)('core/block-editor'),
        getNextBlockClientId = _select2.getNextBlockClientId,
        getBlock = _select2.getBlock;

    currentColumn.querySelector('.components-resizable-box__container').style.width = 'auto';

    if ('right' === direction) {
      if (null !== nextColumn) {
        var nextColumnBlockClientId = getNextBlockClientId(props.clientId);
        var nextColumnBlock = getBlock(nextColumnBlockClientId);

        var nextColumnBlockWidth = edit_objectSpread({}, nextColumnBlock.attributes.colWidth);

        if (parseFloat(colWidth[deviceType]) >= 0 && parseFloat(nextColumnBlockWidth[deviceType]) >= 0 && absWidth <= parseFloat(nextColumnBlockWidth[deviceType]) + parseFloat(colWidth[deviceType])) {
          var nextColumnWidth = parseFloat(nextColumnBlockWidth[deviceType]) + diffWidth;
          nextColumn.style.width = Math.abs(nextColumnWidth).toFixed(2) + '%';
          nextColumnBlock.attributes.colWidth[deviceType] = parseFloat(nextColumnWidth.toFixed(2));
          currentColumn.style.width = absWidth.toFixed(2) + '%';
          setAttributes({
            colWidth: edit_objectSpread(edit_objectSpread({}, colWidth), {}, _defineProperty({}, deviceType, parseFloat(absWidth.toFixed(2))))
          });
        }
      }
    }
  };

  var _useSelect = (0,external_wp_data_namespaceObject.useSelect)( // eslint-disable-next-line no-shadow
  function (select) {
    var _select3 = select('core/block-editor'),
        getBlockOrder = _select3.getBlockOrder,
        getBlockRootClientId = _select3.getBlockRootClientId,
        getPreviousBlockClientId = _select3.getPreviousBlockClientId,
        getNextBlockClientId = _select3.getNextBlockClientId,
        getBlockParents = _select3.getBlockParents;

    var rootId = getBlockRootClientId(props.clientId);
    return {
      hasChildBlocks: getBlockOrder(props.clientId).length > 0,
      rootClientId: rootId,
      columnsIds: getBlockOrder(rootId),
      nextBlockClientId: getNextBlockClientId(props.clientId),
      prevBlockClientId: getPreviousBlockClientId(props.clientId),
      parentBlocks: getBlockParents(props.clientId)
    };
  }, [props.clientId]),
      columnsIds = _useSelect.columnsIds,
      hasChildBlocks = _useSelect.hasChildBlocks,
      rootClientId = _useSelect.rootClientId,
      parentBlocks = _useSelect.parentBlocks;

  var ALLOWED_BLOCKS = (0,external_wp_element_namespaceObject.useMemo)(function () {
    var allowedBlocks = (0,external_wp_blocks_namespaceObject.getBlockTypes)().map(function (_ref) {
      var name = _ref.name;
      return name;
    });

    if (parentBlocks.length >= 5) {
      allowedBlocks = allowedBlocks.filter(function (name) {
        return 'blockart/section' !== name;
      });
    }

    return allowedBlocks;
  }, [parentBlocks === null || parentBlocks === void 0 ? void 0 : parentBlocks.length]);
  var prevColumnIds = (0,external_wp_element_namespaceObject.useRef)(columnsIds);
  (0,external_wp_element_namespaceObject.useEffect)(function () {
    if (columnsIds.length > 0 && prevColumnIds.current.length !== columnsIds.length) {
      updateColumns();
    }

    prevColumnIds.current = columnsIds;
  }, [columnsIds]);

  var updateColumns = function updateColumns() {
    var _select4 = (0,external_wp_data_namespaceObject.select)('core/block-editor'),
        getBlock = _select4.getBlock,
        getBlocks = _select4.getBlocks;

    var _dispatch2 = (0,external_wp_data_namespaceObject.dispatch)('core/block-editor'),
        updateBlockAttributes = _dispatch2.updateBlockAttributes;

    var rootBlock = getBlock(rootClientId);
    var columns = columnsIds.length;
    var columnFixedWidth = parseFloat((100 / columns).toFixed(3));

    var equalWidth = edit_objectSpread(edit_objectSpread({}, state.colWidth), {
      desktop: columnFixedWidth,
      tablet: columnFixedWidth,
      mobile: columnFixedWidth
    });

    if (rootClientId && rootBlock) {
      updateBlockAttributes(rootClientId, Object.assign(rootBlock.attributes, {
        columns: columns
      }));
      getBlocks(rootClientId).forEach(function (block) {
        updateBlockAttributes(block.clientId, Object.assign(block.attributes, {
          colWidth: edit_objectSpread({}, equalWidth)
        }));
        var columnBlock = document.getElementById("block-".concat(block.clientId));

        if (null !== columnBlock) {
          columnBlock.style.width = equalWidth[deviceType] + '%';
        }
      });
    }
  };

  var addRemoveBlock = function addRemoveBlock(type) {
    var _select5 = (0,external_wp_data_namespaceObject.select)('core/block-editor'),
        getBlockIndex = _select5.getBlockIndex,
        getBlocks = _select5.getBlocks;

    var _dispatch3 = (0,external_wp_data_namespaceObject.dispatch)('core/block-editor'),
        replaceInnerBlocks = _dispatch3.replaceInnerBlocks;

    var selectedBlockIndex = getBlockIndex(props.clientId, rootClientId);

    var innerBlocks = _toConsumableArray(getBlocks(rootClientId));

    if (type === 'delete') {
      innerBlocks.splice(selectedBlockIndex, 1);
    } else {
      innerBlocks.splice(selectedBlockIndex + 1, 0, (0,external_wp_blocks_namespaceObject.createBlock)('blockart/column'));
    }

    replaceInnerBlocks(rootClientId, innerBlocks, false);
  };

  var inlineStyle = 'desktop' !== deviceType ? '.blockart-section > .block-editor-inner-blocks > .block-editor-block-list__layout [data-type=\'blockart/column\'] .components-resizable-box__container.has-show-handle .components-resizable-box__handle { display: none; }' : '';
  return /*#__PURE__*/React.createElement(external_wp_element_namespaceObject.Fragment, null, /*#__PURE__*/React.createElement(external_wp_blockEditor_namespaceObject.InspectorControls, null, /*#__PURE__*/React.createElement(tab_panel, {
    root: true
  }, /*#__PURE__*/React.createElement(tab, {
    tabTitle: (0,external_wp_i18n_namespaceObject.__)('Settings', 'blockart')
  }, /*#__PURE__*/React.createElement(panel, {
    title: (0,external_wp_i18n_namespaceObject.__)('General', 'blockart'),
    initialOpen: true
  }, /*#__PURE__*/React.createElement(slider, {
    label: (0,external_wp_i18n_namespaceObject.__)('Width', 'blockart'),
    onChange: function onChange(val) {
      return _onChange(val);
    },
    value: colWidth,
    min: 0,
    max: 100,
    step: 1,
    defaultUnit: "%",
    showUnit: true,
    responsive: true
  })), /*#__PURE__*/React.createElement(panel, {
    title: (0,external_wp_i18n_namespaceObject.__)('Background', 'blockart')
  }, /*#__PURE__*/React.createElement(tab_panel, null, /*#__PURE__*/React.createElement(tab, {
    tabTitle: (0,external_wp_i18n_namespaceObject.__)('Normal', 'blockart')
  }, /*#__PURE__*/React.createElement(components_background, {
    onChange: function onChange(val) {
      return setAttributes({
        background: val
      });
    },
    label: (0,external_wp_i18n_namespaceObject.__)('Background', 'blockart'),
    bgTypes: ['color', 'image'],
    value: background
  })), /*#__PURE__*/React.createElement(tab, {
    tabTitle: (0,external_wp_i18n_namespaceObject.__)('Hover', 'blockart')
  }, /*#__PURE__*/React.createElement(components_background, {
    onChange: function onChange(val) {
      return setAttributes({
        hoverBackground: val
      });
    },
    label: (0,external_wp_i18n_namespaceObject.__)('Background', 'blockart'),
    bgTypes: ['color', 'image'],
    value: hoverBackground
  })))), /*#__PURE__*/React.createElement(panel, {
    title: (0,external_wp_i18n_namespaceObject.__)('Border', 'blockart')
  }, /*#__PURE__*/React.createElement(tab_panel, null, /*#__PURE__*/React.createElement(tab, {
    tabTitle: (0,external_wp_i18n_namespaceObject.__)('Normal', 'blockart')
  }, /*#__PURE__*/React.createElement(components_border, {
    value: border,
    onChange: function onChange(val) {
      return setAttributes({
        border: val
      });
    }
  }), /*#__PURE__*/React.createElement(box_shadow, {
    value: boxShadow,
    onChange: function onChange(val) {
      return setAttributes({
        boxShadow: val
      });
    }
  })), /*#__PURE__*/React.createElement(tab, {
    tabTitle: (0,external_wp_i18n_namespaceObject.__)('Hover', 'blockart')
  }, /*#__PURE__*/React.createElement(components_border, {
    value: borderHover,
    onChange: function onChange(val) {
      return setAttributes({
        borderHover: val
      });
    }
  }), /*#__PURE__*/React.createElement(box_shadow, {
    value: boxShadowHover,
    onChange: function onChange(val) {
      return setAttributes({
        boxShadowHover: val
      });
    }
  }))))), /*#__PURE__*/React.createElement(tab, {
    tabTitle: (0,external_wp_i18n_namespaceObject.__)('Advanced', 'blockart')
  }, /*#__PURE__*/React.createElement(BlockAdvanceSettings, {
    blockMargin: blockMargin,
    blockPadding: blockPadding,
    blockZIndex: blockZIndex,
    cssID: cssID,
    setAttributes: setAttributes
  }), /*#__PURE__*/React.createElement(BlockResponsiveSettings, {
    hideOnDesktop: hideOnDesktop,
    hideOnTablet: hideOnTablet,
    hideOnMobile: hideOnMobile,
    setAttributes: setAttributes
  }), /*#__PURE__*/React.createElement(BlockCSSSettings, {
    className: className,
    setAttributes: setAttributes,
    hasBlockCSS: false
  })))), /*#__PURE__*/React.createElement(external_wp_blockEditor_namespaceObject.BlockControls, null, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Toolbar, null, columnsIds.length + 1 <= 6 && /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Button, {
    label: (0,external_wp_i18n_namespaceObject.__)('Add Column', 'blockart'),
    onClick: function onClick() {
      return addRemoveBlock('add');
    },
    icon: "plus"
  }), columnsIds.length > 1 && /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Button, {
    label: (0,external_wp_i18n_namespaceObject.__)('Delete Column', 'blockart'),
    onClick: function onClick() {
      return addRemoveBlock('delete');
    },
    icon: "trash"
  })), /*#__PURE__*/React.createElement(CopyPasteStylesBlockControl, null)), /*#__PURE__*/React.createElement(Style, null), /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.ResizableBox, {
    maxWidth: 999999999,
    style: {},
    size: {},
    enable: {
      top: false,
      right: true,
      bottom: false,
      left: false,
      topRight: false,
      bottomRight: false,
      bottomLeft: false,
      topLeft: false
    },
    onResizeStart: function onResizeStart() {
      return _onResizeStart();
    },
    onResize: function onResize(event, direction, elt, delta) {
      return _onResize(event, direction, elt, delta);
    },
    onResizeStop: function onResizeStop() {
      return props.toggleSelection(true);
    },
    className: "blockart-resizable"
  }, /*#__PURE__*/React.createElement("style", null, inlineStyle), /*#__PURE__*/React.createElement("div", {
    id: cssID ? cssID : null,
    className: classNames
  }, /*#__PURE__*/React.createElement("div", {
    className: "blockart-column-inner"
  }, /*#__PURE__*/React.createElement(external_wp_blockEditor_namespaceObject.InnerBlocks, {
    templateLock: false,
    allowedBlocks: ALLOWED_BLOCKS,
    renderAppender: hasChildBlocks ? undefined : function () {
      return /*#__PURE__*/React.createElement(external_wp_blockEditor_namespaceObject.InnerBlocks.ButtonBlockAppender, null);
    }
  })))));
}));
;// CONCATENATED MODULE: ./src/blocks/blocks/section/column/save.js



/* harmony default export */ const column_save = (function (_ref) {
  var _ref$attributes = _ref.attributes,
      clientId = _ref$attributes.clientId,
      className = _ref$attributes.className,
      cssID = _ref$attributes.cssID;
  var classNames = (0,external_wp_hooks_namespaceObject.applyFilters)('blockart.column.classnames', classnames_default()("blockart-column blockart-column-".concat(clientId), className));
  return /*#__PURE__*/React.createElement("div", {
    id: cssID !== null && cssID !== void 0 ? cssID : undefined,
    className: classNames
  }, /*#__PURE__*/React.createElement("div", {
    className: "blockart-column-inner"
  }, /*#__PURE__*/React.createElement(external_wp_blockEditor_namespaceObject.InnerBlocks.Content, null)));
});
;// CONCATENATED MODULE: ./src/blocks/blocks/section/column/attributes.js


function column_attributes_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function column_attributes_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? column_attributes_ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : column_attributes_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }


/* harmony default export */ const column_attributes = (column_attributes_objectSpread({
  clientId: {
    type: 'string',
    "default": ''
  },
  colWidth: {
    type: 'object',
    "default": {
      desktop: 50,
      tablet: 100,
      mobile: 100
    },
    style: [{
      selector: '{{WRAPPER}} { width: {{VALUE}}%; }'
    }]
  },
  background: {
    type: 'object',
    "default": {
      background: 1
    },
    style: [{
      selector: '{{WRAPPER}} > .blockart-column-inner'
    }]
  },
  hoverBackground: {
    type: 'object',
    "default": {
      background: 1
    },
    style: [{
      selector: '{{WRAPPER}}:hover > .blockart-column-inner'
    }]
  },
  border: {
    type: 'object',
    "default": {
      border: 1,
      radius: {
        desktop: {
          lock: true
        }
      },
      size: {
        desktop: {
          lock: true
        }
      }
    },
    style: [{
      selector: '{{WRAPPER}} > .blockart-column-inner'
    }]
  },
  borderHover: {
    type: 'object',
    "default": {
      border: 1,
      radius: {
        desktop: {
          lock: true
        }
      },
      size: {
        desktop: {
          lock: true
        }
      }
    },
    style: [{
      selector: '{{WRAPPER}}:hover > .blockart-column-inner'
    }]
  },
  boxShadow: {
    type: 'object',
    "default": {
      boxShadow: 1
    },
    style: [{
      selector: '{{WRAPPER}} > .blockart-column-inner'
    }]
  },
  boxShadowHover: {
    type: 'object',
    "default": {
      boxShadow: 1
    },
    style: [{
      selector: '{{WRAPPER}}:hover > .blockart-column-inner'
    }]
  }
}, column_attributes_objectSpread(column_attributes_objectSpread({}, blockAttributes), {}, {
  blockPadding: {
    type: 'object',
    "default": {
      dimension: 1,
      desktop: {
        lock: true
      }
    },
    style: [{
      selector: '{{WRAPPER}} > .blockart-column-inner { padding: {{VALUE}}; }'
    }]
  }
})));
;// CONCATENATED MODULE: ./src/blocks/blocks/section/column/block.json
const column_block_namespaceObject = JSON.parse('{"$schema":"https://schemas.wp.org/trunk/block.json","textdomain":"blockart","title":"Column","description":"An advanced single column within section block.","parent":["blockart/section"],"category":"blockart","name":"blockart/column","supports":{"className":false,"customClassName":false,"inserter":false,"reusable":false,"html":false},"example":{"attributes":{}},"style":"blockart-blocks","editorScript":"blockart-blocks","editorStyle":"blockart-blocks-editor"}');
;// CONCATENATED MODULE: ./src/blocks/blocks/section/column/index.js


function column_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function column_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? column_ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : column_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }







/* harmony default export */ const section_column = (function () {
  (0,external_wp_blocks_namespaceObject.registerBlockType)('blockart/column', column_objectSpread(column_objectSpread({}, column_block_namespaceObject), {}, {
    icon: /*#__PURE__*/React.createElement(components_icon, {
      className: "blockart-column-block",
      type: "blockIcon",
      name: "column",
      size: 24
    }),
    attributes: column_attributes,
    edit: column_edit,
    save: column_save
  }));
});
;// CONCATENATED MODULE: ./src/blocks/blocks/section/edit.js












var layouts = [{
  label: '100',
  columns: 1,
  structure: {
    desktop: [100],
    tablet: [100],
    mobile: [100]
  }
}, {
  label: '50/50',
  columns: 2,
  structure: {
    desktop: [50, 50],
    tablet: [100, 100],
    mobile: [100, 100]
  }
}, {
  label: '34/66',
  columns: 2,
  structure: {
    desktop: [34, 66],
    tablet: [100, 100],
    mobile: [100, 100]
  }
}, {
  label: '66/34',
  columns: 2,
  structure: {
    desktop: [66, 34],
    tablet: [100, 100],
    mobile: [100, 100]
  }
}, {
  label: '33/33/33',
  columns: 3,
  structure: {
    desktop: [33.33, 33.33, 33.34],
    tablet: [100, 100, 100],
    mobile: [100, 100, 100]
  }
}, {
  label: '25/50/25',
  columns: 3,
  structure: {
    desktop: [25, 50, 25],
    tablet: [100, 100, 100],
    mobile: [100, 100, 100]
  }
}, {
  label: '25/25/50',
  columns: 3,
  structure: {
    desktop: [25, 25, 50],
    tablet: [100, 100, 100],
    mobile: [100, 100, 100]
  }
}, {
  label: '50/25/25',
  columns: 3,
  structure: {
    desktop: [50, 25, 25],
    tablet: [100, 100, 100],
    mobile: [100, 100, 100]
  }
}, {
  label: '25/25/25/25',
  columns: 4,
  structure: {
    desktop: [25, 25, 25, 25],
    tablet: [100, 100, 100, 100],
    mobile: [100, 100, 100, 100]
  }
}];
var defaultLayout = {
  desktop: [100],
  tablet: [100],
  mobile: [100]
};
/* harmony default export */ const section_edit = ((0,external_wp_compose_namespaceObject.compose)([with_device_type, with_copy_paste_styles])(function (props) {
  var _props$attributes = props.attributes,
      uniqueId = _props$attributes.clientId,
      columns = _props$attributes.columns,
      hasModal = _props$attributes.hasModal,
      modalOnly = _props$attributes.modalOnly,
      childRow = _props$attributes.childRow,
      verticalAlignment = _props$attributes.verticalAlignment,
      container = _props$attributes.container,
      width = _props$attributes.width,
      columnGap = _props$attributes.columnGap,
      height = _props$attributes.height,
      minHeight = _props$attributes.minHeight,
      background = _props$attributes.background,
      hoverBackground = _props$attributes.hoverBackground,
      border = _props$attributes.border,
      borderHover = _props$attributes.borderHover,
      boxShadow = _props$attributes.boxShadow,
      boxShadowHover = _props$attributes.boxShadowHover,
      overlay = _props$attributes.overlay,
      overlayBackground = _props$attributes.overlayBackground,
      blockMargin = _props$attributes.blockMargin,
      blockPadding = _props$attributes.blockPadding,
      blockZIndex = _props$attributes.blockZIndex,
      cssID = _props$attributes.cssID,
      hideOnDesktop = _props$attributes.hideOnDesktop,
      hideOnTablet = _props$attributes.hideOnTablet,
      hideOnMobile = _props$attributes.hideOnMobile,
      className = _props$attributes.className,
      colReverseOnTablet = _props$attributes.colReverseOnTablet,
      colReverseOnMobile = _props$attributes.colReverseOnMobile,
      align = _props$attributes.align,
      setAttributes = props.setAttributes,
      deviceType = props.deviceType,
      CopyPasteStylesBlockControl = props.copyPasteStylesBlockControl;
  (0,external_wp_element_namespaceObject.useEffect)(function () {
    var _select = (0,external_wp_data_namespaceObject.select)('core/block-editor'),
        getBlockRootClientId = _select.getBlockRootClientId;

    var parentClientId = getBlockRootClientId(props.clientId);
    var id = props.clientId.substr(0, 8);

    if (!uniqueId) {
      setAttributes({
        clientId: id,
        childRow: !!parentClientId
      });
    } else if (uniqueId !== id) {
      if (document.querySelectorAll(".blockart-section-".concat(uniqueId)).length > 1) {
        setAttributes({
          clientId: id,
          childRow: !!parentClientId
        });
      }
    }
  }, []);
  var Style = use_block_style({
    blockName: 'section',
    clientId: uniqueId,
    attributes: props.attributes,
    deviceType: deviceType
  }); // eslint-disable-next-line no-shadow

  var getLayouts = function getLayouts(columns) {
    return _toConsumableArray(Array(parseInt(columns))).map(function (data, index) {
      var columnWidth = {
        desktop: defaultLayout.desktop[index],
        tablet: defaultLayout.tablet[index],
        mobile: defaultLayout.mobile[index]
      };
      return ['blockart/column', {
        colWidth: columnWidth
      }];
    });
  };

  var containerClassNames = classnames_default()({
    'blockart-container': container === 'contained' || !childRow
  }, {
    'blockart-container-fluid': container === 'stretched' || childRow
  });
  var sectionClassNames = (0,external_wp_hooks_namespaceObject.applyFilters)('blockart.section.classnames', classnames_default()("blockart-section blockart-section-".concat(uniqueId), className, align && "align".concat(align)));

  var inlineStyle = function inlineStyle() {
    var css = '';

    if (columnGap && columnGap[deviceType]) {
      var value = (columnGap[deviceType].value || 0).toString() + columnGap[deviceType].unit || 'px';
      css += ".blockart-section-".concat(uniqueId, " [data-type=\"blockart/column\"] { padding-right: calc(").concat(value, " / 2); padding-left: calc(").concat(value, " / 2); }");
    }

    if ('tablet' === deviceType || 'mobile' === deviceType) {
      css += ".blockart-section-inner > .block-editor-inner-blocks > .block-editor-block-list__layout { flex-wrap: wrap; }";
    }

    if (verticalAlignment && verticalAlignment[deviceType]) {
      css += ".blockart-section-".concat(uniqueId, " .blockart-section-inner > .block-editor-inner-blocks .block-editor-block-list__layout { align-items: ").concat(verticalAlignment[deviceType], " }");
    }

    css += '.blockart-section-inner {margin: unset !important}';
    return css;
  };

  if (!columns) {
    return /*#__PURE__*/React.createElement(external_wp_element_namespaceObject.Fragment, null, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Placeholder, {
      label: (0,external_wp_i18n_namespaceObject.__)('Choose Your Layout', 'blockart'),
      className: "blockart-section-preset"
    }, /*#__PURE__*/React.createElement("div", {
      className: "blockart-section-preset-group"
    }, layouts.map(function (_ref, idx) {
      var label = _ref.label,
          columns = _ref.columns,
          structure = _ref.structure;
      return /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.Tooltip, {
        key: idx,
        text: label,
        delay: 300
      }, /*#__PURE__*/React.createElement("button", {
        className: "blockart-section-preset-btn",
        onClick: function onClick() {
          setAttributes({
            columns: columns
          });
          defaultLayout = structure;
        }
      }, structure.desktop.map(function (s, k) {
        return /*#__PURE__*/React.createElement("i", {
          key: k,
          style: {
            width: s + '%'
          }
        });
      })));
    })), !_BLOCKART_.isNotPostEditor && /*#__PURE__*/React.createElement("div", {
      className: "blockart-section-preset-import-btn"
    }, /*#__PURE__*/React.createElement("button", {
      onClick: function onClick() {
        return setAttributes({
          hasModal: true
        });
      }
    }, (0,external_wp_i18n_namespaceObject.__)('View Templates', 'blockart')))), hasModal && /*#__PURE__*/React.createElement(library_modal, {
      closeModal: function closeModal() {
        return setAttributes({
          hasModal: false
        });
      },
      hasModal: hasModal,
      modalOnly: modalOnly,
      blockId: props.clientId
    }));
  }

  return /*#__PURE__*/React.createElement(external_wp_element_namespaceObject.Fragment, null, /*#__PURE__*/React.createElement(external_wp_blockEditor_namespaceObject.InspectorControls, null, /*#__PURE__*/React.createElement(tab_panel, {
    root: true
  }, /*#__PURE__*/React.createElement(tab, {
    tabTitle: (0,external_wp_i18n_namespaceObject.__)('Layout', 'blockart')
  }, /*#__PURE__*/React.createElement(layout, {
    block: "section"
  })), /*#__PURE__*/React.createElement(tab, {
    tabTitle: (0,external_wp_i18n_namespaceObject.__)('Settings', 'blockart')
  }, /*#__PURE__*/React.createElement(panel, {
    title: (0,external_wp_i18n_namespaceObject.__)('General', 'blockart'),
    initialOpen: true
  }, /*#__PURE__*/React.createElement(components_select, {
    options: [{
      label: (0,external_wp_i18n_namespaceObject.__)('Default', 'blockart'),
      value: ''
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Baseline', 'blockart'),
      value: 'baseline'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Top', 'blockart'),
      value: 'flex-start'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Middle', 'blockart'),
      value: 'center'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Bottom', 'blockart'),
      value: 'flex-end'
    }],
    onChange: function onChange(val) {
      return setAttributes({
        verticalAlignment: val
      });
    },
    value: verticalAlignment,
    label: (0,external_wp_i18n_namespaceObject.__)('Vertical Alignment', 'blockart'),
    placeholder: (0,external_wp_i18n_namespaceObject.__)('Default', 'blockart'),
    responsive: true,
    inline: false
  }), /*#__PURE__*/React.createElement(components_select, {
    value: container,
    options: [{
      label: (0,external_wp_i18n_namespaceObject.__)('Contained', 'blockart'),
      value: 'contained'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Stretched', 'blockart'),
      value: 'stretched'
    }],
    onChange: function onChange(val) {
      return setAttributes({
        container: val
      });
    },
    label: (0,external_wp_i18n_namespaceObject.__)('Container', 'blockart')
  }), 'contained' === container && /*#__PURE__*/React.createElement(slider, {
    onChange: function onChange(val) {
      return setAttributes({
        width: val
      });
    },
    label: (0,external_wp_i18n_namespaceObject.__)('Width', 'blockart'),
    units: ['px'],
    responsive: true,
    min: 0,
    max: 1920,
    value: width
  }), /*#__PURE__*/React.createElement(slider, {
    onChange: function onChange(val) {
      return setAttributes({
        columnGap: val
      });
    },
    label: (0,external_wp_i18n_namespaceObject.__)('Column Gap', 'blockart'),
    units: ['px', 'em', '%'],
    responsive: true,
    min: 0,
    max: 100,
    value: columnGap
  }), /*#__PURE__*/React.createElement(components_select, {
    options: [{
      label: (0,external_wp_i18n_namespaceObject.__)('Min Height', 'blockart'),
      value: 'min-height'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Default', 'blockart'),
      value: 'default'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Fit To Screen', 'blockart'),
      value: 'fit-to-screen'
    }],
    onChange: function onChange(val) {
      return setAttributes({
        height: val
      });
    },
    value: height,
    label: (0,external_wp_i18n_namespaceObject.__)('Height', 'blockart')
  }), 'min-height' === height && /*#__PURE__*/React.createElement(slider, {
    onChange: function onChange(val) {
      return setAttributes({
        minHeight: val
      });
    },
    label: (0,external_wp_i18n_namespaceObject.__)('Min Height', 'blockart'),
    units: ['px', 'em', 'vh'],
    responsive: true,
    min: 0,
    max: 1200,
    value: minHeight
  })), /*#__PURE__*/React.createElement(panel, {
    title: (0,external_wp_i18n_namespaceObject.__)('Background', 'blockart')
  }, /*#__PURE__*/React.createElement(tab_panel, null, /*#__PURE__*/React.createElement(tab, {
    tabTitle: (0,external_wp_i18n_namespaceObject.__)('Normal', 'blockart')
  }, /*#__PURE__*/React.createElement(components_background, {
    onChange: function onChange(val) {
      return setAttributes({
        background: val
      });
    },
    label: (0,external_wp_i18n_namespaceObject.__)('Background', 'blockart'),
    bgTypes: ['color', 'image'],
    value: background
  })), /*#__PURE__*/React.createElement(tab, {
    tabTitle: (0,external_wp_i18n_namespaceObject.__)('Hover', 'blockart')
  }, /*#__PURE__*/React.createElement(components_background, {
    onChange: function onChange(val) {
      return setAttributes({
        background: val
      });
    },
    label: (0,external_wp_i18n_namespaceObject.__)('Background', 'blockart'),
    bgTypes: ['color', 'image'],
    value: hoverBackground
  })))), /*#__PURE__*/React.createElement(panel, {
    title: (0,external_wp_i18n_namespaceObject.__)('Border', 'blockart')
  }, /*#__PURE__*/React.createElement(tab_panel, null, /*#__PURE__*/React.createElement(tab, {
    tabTitle: (0,external_wp_i18n_namespaceObject.__)('Normal', 'blockart')
  }, /*#__PURE__*/React.createElement(components_border, {
    value: border,
    onChange: function onChange(val) {
      return setAttributes({
        border: val
      });
    }
  }), /*#__PURE__*/React.createElement(box_shadow, {
    value: boxShadow,
    onChange: function onChange(val) {
      return setAttributes({
        boxShadow: val
      });
    }
  })), /*#__PURE__*/React.createElement(tab, {
    tabTitle: (0,external_wp_i18n_namespaceObject.__)('Hover', 'blockart')
  }, /*#__PURE__*/React.createElement(components_border, {
    value: borderHover,
    onChange: function onChange(val) {
      return setAttributes({
        borderHover: val
      });
    }
  }), /*#__PURE__*/React.createElement(box_shadow, {
    value: boxShadowHover,
    onChange: function onChange(val) {
      return setAttributes({
        boxShadowHover: val
      });
    }
  })))), /*#__PURE__*/React.createElement(panel, {
    title: (0,external_wp_i18n_namespaceObject.__)('Overlay', 'blockart')
  }, /*#__PURE__*/React.createElement(toggle, {
    checked: overlay,
    onChange: function onChange() {
      return setAttributes({
        overlay: !overlay
      });
    },
    label: (0,external_wp_i18n_namespaceObject.__)('Enable', 'blockart')
  }), overlay && /*#__PURE__*/React.createElement(components_background, {
    onChange: function onChange(val) {
      return setAttributes({
        overlayBackground: val
      });
    },
    value: overlayBackground || {},
    label: (0,external_wp_i18n_namespaceObject.__)('Background', 'blockart')
  }))), /*#__PURE__*/React.createElement(tab, {
    tabTitle: (0,external_wp_i18n_namespaceObject.__)('Advanced', 'blockart')
  }, /*#__PURE__*/React.createElement(BlockAdvanceSettings, {
    blockMargin: blockMargin,
    blockPadding: blockPadding,
    blockZIndex: blockZIndex,
    cssID: cssID,
    setAttributes: setAttributes
  }), /*#__PURE__*/React.createElement(BlockResponsiveSettings, {
    hideOnDesktop: hideOnDesktop,
    hideOnTablet: hideOnTablet,
    hideOnMobile: hideOnMobile,
    setAttributes: setAttributes,
    hasColReverse: true,
    colReverseOnTablet: colReverseOnTablet,
    colReverseOnMobile: colReverseOnMobile
  }), /*#__PURE__*/React.createElement(BlockCSSSettings, {
    className: className,
    setAttributes: setAttributes,
    hasBlockCSS: false
  })))), /*#__PURE__*/React.createElement(external_wp_blockEditor_namespaceObject.BlockControls, null, /*#__PURE__*/React.createElement(CopyPasteStylesBlockControl, null)), /*#__PURE__*/React.createElement(Style, null), /*#__PURE__*/React.createElement("div", {
    id: cssID ? cssID : null,
    className: sectionClassNames
  }, /*#__PURE__*/React.createElement("style", null, inlineStyle()), overlay && /*#__PURE__*/React.createElement("div", {
    className: "blockart-overlay"
  }), /*#__PURE__*/React.createElement("div", {
    className: containerClassNames
  }, /*#__PURE__*/React.createElement("div", {
    className: "blockart-section-inner".concat('fit-to-screen' === height ? ' blockart-height-fit-to-screen' : '')
  }, /*#__PURE__*/React.createElement(external_wp_blockEditor_namespaceObject.InnerBlocks, {
    template: getLayouts(columns),
    allowedBlocks: ['blockart/column'],
    orientation: "horizontal",
    renderAppender: false
  })))));
}));
;// CONCATENATED MODULE: ./src/blocks/blocks/section/save.js



/* harmony default export */ const section_save = (function (_ref) {
  var _ref$attributes = _ref.attributes,
      clientId = _ref$attributes.clientId,
      container = _ref$attributes.container,
      cssID = _ref$attributes.cssID,
      className = _ref$attributes.className,
      overlay = _ref$attributes.overlay,
      height = _ref$attributes.height,
      align = _ref$attributes.align;
  var containerClassNames = classnames_default()({
    'blockart-container': container === 'contained'
  }, {
    'blockart-container-fluid': container === 'stretched'
  });
  var sectionClassNames = (0,external_wp_hooks_namespaceObject.applyFilters)('blockart.section.classnames', classnames_default()("blockart-section blockart-section-".concat(clientId), className, align && "align".concat(align)));
  return /*#__PURE__*/React.createElement("div", {
    id: cssID !== null && cssID !== void 0 ? cssID : undefined,
    className: sectionClassNames
  }, overlay && /*#__PURE__*/React.createElement("div", {
    className: "blockart-overlay"
  }), /*#__PURE__*/React.createElement("div", {
    className: containerClassNames
  }, /*#__PURE__*/React.createElement("div", {
    className: "blockart-section-inner".concat(height === 'fit-to-screen' ? ' blockart-height-fit-to-screen' : '')
  }, /*#__PURE__*/React.createElement(external_wp_blockEditor_namespaceObject.InnerBlocks.Content, null))));
});
;// CONCATENATED MODULE: ./src/blocks/blocks/section/attributes.js


function section_attributes_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function section_attributes_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? section_attributes_ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : section_attributes_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }


/* harmony default export */ const section_attributes = (section_attributes_objectSpread({
  clientId: {
    type: 'string'
  },
  hasModal: {
    type: 'boolean',
    "default": false
  },
  modalOnly: {
    type: 'boolean',
    "default": false
  },
  columns: {
    type: 'number',
    "default": ''
  },
  childRow: {
    type: 'boolean',
    "default": false
  },
  verticalAlignment: {
    type: 'object',
    "default": {
      desktop: ''
    },
    style: [{
      selector: '{{WRAPPER}} > .blockart-container > .blockart-section-inner,' + '{{WRAPPER}} > .blockart-container-fluid > .blockart-section-inner' + '{ align-items: {{VALUE}}; }'
    }]
  },
  container: {
    type: 'string',
    "default": 'contained'
  },
  inheritFromTheme: {
    type: 'boolean',
    "default": false
  },
  width: {
    type: 'object',
    "default": {
      desktop: {
        value: 1170,
        unit: 'px'
      }
    },
    style: [{
      condition: [{
        key: 'container',
        relation: '==',
        value: 'contained'
      }, {
        key: 'inheritFromTheme',
        relation: '!=',
        value: true
      }],
      selector: '{{WRAPPER}} > .blockart-container { max-width: {{VALUE}}; }'
    }]
  },
  columnGap: {
    type: 'object',
    "default": {
      desktop: {
        value: 30,
        unit: 'px'
      }
    },
    style: [{
      selector: '{{WRAPPER}} > .blockart-container > .blockart-section-inner > .blockart-column,' + '{{WRAPPER}} > .blockart-container-fluid > .blockart-section-inner > .blockart-column' + '{ padding-left: {{VALUE}};}' + '{{WRAPPER}} > .blockart-container-fluid > .blockart-section-inner,' + '{{WRAPPER}} > .blockart-container > .blockart-section-inner' + '{ margin-left: -{{VALUE}};}'
    }]
  },
  height: {
    type: 'string',
    "default": 'default'
  },
  minHeight: {
    type: 'object',
    style: [{
      condition: [{
        key: 'height',
        relation: '==',
        value: 'min-height'
      }],
      selector: '{{WRAPPER}} > .blockart-container > .blockart-section-inner,' + '{{WRAPPER}} > .blockart-container-fluid > .blockart-section-inner {min-height: {{VALUE}};}'
    }]
  },
  background: {
    type: 'object',
    "default": {
      background: 1
    },
    style: [{
      selector: '{{WRAPPER}}'
    }]
  },
  hoverBackground: {
    type: 'object',
    "default": {
      background: 1
    },
    style: [{
      selector: '{{WRAPPER}}:hover'
    }]
  },
  border: {
    type: 'object',
    "default": {
      border: 1,
      radius: {
        desktop: {
          lock: true
        }
      },
      size: {
        desktop: {
          lock: true
        }
      }
    },
    style: [{
      selector: '{{WRAPPER}}'
    }]
  },
  borderHover: {
    type: 'object',
    "default": {
      border: 1,
      radius: {
        desktop: {
          lock: true
        }
      },
      size: {
        desktop: {
          lock: true
        }
      }
    },
    style: [{
      selector: '{{WRAPPER}}:hover'
    }]
  },
  boxShadow: {
    type: 'object',
    "default": {
      boxShadow: 1
    },
    style: [{
      selector: '{{WRAPPER}}'
    }]
  },
  boxShadowHover: {
    type: 'object',
    "default": {
      boxShadow: 1
    },
    style: [{
      selector: '{{WRAPPER}}:hover'
    }]
  },
  overlay: {
    type: 'boolean',
    "default": false
  },
  overlayBackground: {
    type: 'object',
    "default": {
      background: 1,
      color: 'rgba(37, 99, 235,0.3)'
    },
    style: [{
      condition: [{
        key: 'overlay',
        relation: '==',
        value: true
      }],
      selector: '{{WRAPPER}} > .blockart-overlay'
    }]
  }
}, section_attributes_objectSpread(section_attributes_objectSpread({}, blockAttributes), {}, {
  blockPadding: {
    type: 'object',
    "default": {
      dimension: 1,
      desktop: {
        left: 15,
        right: 15,
        unit: 'px'
      }
    },
    style: [{
      selector: '{{WRAPPER}} { padding: {{VALUE}}; }'
    }]
  }
})));
;// CONCATENATED MODULE: ./src/blocks/blocks/section/block.json
const section_block_namespaceObject = JSON.parse('{"$schema":"https://schemas.wp.org/trunk/block.json","name":"blockart/section","title":"Section","description":"Add Rows and Columns inside rows to create various layouts.","keywords":["section","column","layout"],"category":"blockart","textdomain":"blockart","supports":{"className":false,"customClassName":false,"align":["center","wide","full"]},"example":{"attributes":{}},"style":"blockart-blocks","editorScript":"blockart-blocks","editorStyle":"blockart-blocks-editor"}');
;// CONCATENATED MODULE: ./src/blocks/blocks/section/index.js


function section_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function section_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? section_ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : section_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }









/* harmony default export */ const blocks_section = (function () {
  (0,external_wp_blocks_namespaceObject.registerBlockType)('blockart/section', section_objectSpread(section_objectSpread({}, section_block_namespaceObject), {}, {
    icon: /*#__PURE__*/React.createElement(components_icon, {
      type: "blockIcon",
      name: "section",
      size: 24
    }),
    attributes: section_attributes,
    edit: section_edit,
    save: section_save
  }));
});
;// CONCATENATED MODULE: ./src/blocks/blocks/paragraph/edit.js


function paragraph_edit_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function paragraph_edit_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? paragraph_edit_ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : paragraph_edit_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }











/* harmony default export */ const paragraph_edit = ((0,external_wp_compose_namespaceObject.compose)([with_client_id, with_device_type, with_copy_paste_styles])(function (props) {
  var _props$attributes = props.attributes,
      clientId = _props$attributes.clientId,
      text = _props$attributes.text,
      color = _props$attributes.color,
      hoverColor = _props$attributes.hoverColor,
      background = _props$attributes.background,
      hoverBackground = _props$attributes.hoverBackground,
      alignment = _props$attributes.alignment,
      margin = _props$attributes.margin,
      typography = _props$attributes.typography,
      blockZIndex = _props$attributes.blockZIndex,
      blockPadding = _props$attributes.blockPadding,
      cssID = _props$attributes.cssID,
      hideOnDesktop = _props$attributes.hideOnDesktop,
      hideOnTablet = _props$attributes.hideOnTablet,
      hideOnMobile = _props$attributes.hideOnMobile,
      className = _props$attributes.className,
      setAttributes = props.setAttributes,
      CopyPasteStylesBlockControl = props.copyPasteStylesBlockControl,
      deviceType = props.deviceType;
  var Style = use_block_style({
    blockName: 'paragraph',
    clientId: clientId,
    attributes: props.attributes,
    deviceType: deviceType
  });
  var classNames = (0,external_wp_hooks_namespaceObject.applyFilters)('blockart.paragraph.classnames', classnames_default()("blockart-paragraph blockart-paragraph-".concat(clientId), className));
  return /*#__PURE__*/React.createElement(external_wp_element_namespaceObject.Fragment, null, /*#__PURE__*/React.createElement(external_wp_blockEditor_namespaceObject.InspectorControls, null, /*#__PURE__*/React.createElement(tab_panel, {
    root: true
  }, /*#__PURE__*/React.createElement(tab, {
    tabTitle: (0,external_wp_i18n_namespaceObject.__)('Layout', 'blockart')
  }, /*#__PURE__*/React.createElement(layout, {
    block: "paragraph"
  })), /*#__PURE__*/React.createElement(tab, {
    tabTitle: (0,external_wp_i18n_namespaceObject.__)('Settings', 'blockart')
  }, /*#__PURE__*/React.createElement(panel, {
    title: (0,external_wp_i18n_namespaceObject.__)('General', 'blockart'),
    initialOpen: true
  }, /*#__PURE__*/React.createElement(advance_select, {
    value: alignment,
    onChange: function onChange(val) {
      return setAttributes({
        alignment: val
      });
    },
    responsive: true,
    label: (0,external_wp_i18n_namespaceObject.__)('Alignment', 'blockart'),
    options: [{
      label: (0,external_wp_i18n_namespaceObject.__)('Left', 'blockart'),
      value: 'left',
      icon: 'text-align-left'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Center', 'blockart'),
      value: 'center',
      icon: 'text-align-center'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Right', 'blockart'),
      value: 'right',
      icon: 'text-align-right'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Justify', 'blockart'),
      value: 'justify',
      icon: 'text-align-justify'
    }]
  })), /*#__PURE__*/React.createElement(panel, {
    title: (0,external_wp_i18n_namespaceObject.__)('Text', 'blockart')
  }, /*#__PURE__*/React.createElement(components_typography, {
    value: typography,
    onChange: function onChange(val) {
      return setAttributes({
        typography: val
      });
    }
  })), /*#__PURE__*/React.createElement(panel, {
    title: (0,external_wp_i18n_namespaceObject.__)('Spacing', 'blockart')
  }, /*#__PURE__*/React.createElement(dimensions, {
    value: margin || {},
    responsive: true,
    label: (0,external_wp_i18n_namespaceObject.__)('Margin', 'blockart'),
    defaultUnit: "px",
    units: ['px', 'rem', 'em', '%'],
    onChange: function onChange(val) {
      return setAttributes({
        margin: val
      });
    },
    type: "margin"
  })), /*#__PURE__*/React.createElement(panel, {
    title: (0,external_wp_i18n_namespaceObject.__)('Color', 'blockart')
  }, /*#__PURE__*/React.createElement(tab_panel, null, /*#__PURE__*/React.createElement(tab, {
    tabTitle: (0,external_wp_i18n_namespaceObject.__)('Normal', 'blockart')
  }, /*#__PURE__*/React.createElement(components_color, {
    onChange: function onChange(val) {
      return setAttributes({
        color: val
      });
    },
    label: (0,external_wp_i18n_namespaceObject.__)('Color', 'blockart'),
    value: color || ''
  }), /*#__PURE__*/React.createElement(components_background, {
    value: background,
    onChange: function onChange(val) {
      return setAttributes({
        background: val
      });
    },
    label: (0,external_wp_i18n_namespaceObject.__)('Background', 'blockart')
  })), /*#__PURE__*/React.createElement(tab, {
    tabTitle: (0,external_wp_i18n_namespaceObject.__)('Hover', 'blockart')
  }, /*#__PURE__*/React.createElement(components_color, {
    onChange: function onChange(val) {
      return setAttributes({
        hoverColor: val
      });
    },
    label: (0,external_wp_i18n_namespaceObject.__)('Color', 'blockart'),
    value: hoverColor || ''
  }), /*#__PURE__*/React.createElement(components_background, {
    value: hoverBackground,
    onChange: function onChange(val) {
      return setAttributes({
        hoverBackground: val
      });
    },
    label: (0,external_wp_i18n_namespaceObject.__)('Background', 'blockart')
  }))))), /*#__PURE__*/React.createElement(tab, {
    tabTitle: (0,external_wp_i18n_namespaceObject.__)('Advanced', 'blockart')
  }, /*#__PURE__*/React.createElement(panel, {
    title: (0,external_wp_i18n_namespaceObject.__)('Advanced', 'blockart'),
    initialOpen: true
  }, /*#__PURE__*/React.createElement(dimensions, {
    value: blockPadding || {},
    responsive: true,
    label: (0,external_wp_i18n_namespaceObject.__)('Block Padding', 'blockart'),
    min: 0,
    max: 500,
    defaultUnit: "px",
    units: ['px', 'rem', 'em', '%'],
    onChange: function onChange(val) {
      return setAttributes({
        blockPadding: val
      });
    }
  }), /*#__PURE__*/React.createElement(slider, {
    label: (0,external_wp_i18n_namespaceObject.__)('Z-Index', 'blockart'),
    value: blockZIndex || 0,
    min: 0,
    max: 10000,
    step: 1,
    onChange: function onChange(val) {
      return setAttributes({
        blockZIndex: val
      });
    }
  }), /*#__PURE__*/React.createElement(input, {
    value: cssID || '',
    label: (0,external_wp_i18n_namespaceObject.__)('CSS ID', 'blockart'),
    onChange: function onChange(val) {
      return setAttributes({
        cssID: val
      });
    },
    labelPosition: "side"
  })), /*#__PURE__*/React.createElement(BlockResponsiveSettings, {
    hideOnDesktop: hideOnDesktop,
    hideOnTablet: hideOnTablet,
    hideOnMobile: hideOnMobile,
    setAttributes: setAttributes
  }), /*#__PURE__*/React.createElement(BlockCSSSettings, {
    className: className,
    setAttributes: setAttributes,
    hasBlockCSS: false
  })))), /*#__PURE__*/React.createElement(external_wp_blockEditor_namespaceObject.BlockControls, null, /*#__PURE__*/React.createElement(CopyPasteStylesBlockControl, null)), /*#__PURE__*/React.createElement(Style, null), /*#__PURE__*/React.createElement(external_wp_blockEditor_namespaceObject.RichText, {
    id: cssID ? cssID : null,
    className: classNames,
    identifier: "content",
    tagName: "p",
    onSplit: function onSplit(value, isOriginal) {
      var newAttributes;

      if (isOriginal || value) {
        newAttributes = paragraph_edit_objectSpread(paragraph_edit_objectSpread({}, props.attributes), {}, {
          text: value
        });
      }

      var block = (0,external_wp_blocks_namespaceObject.createBlock)('blockart/paragraph', newAttributes);

      if (isOriginal) {
        block.clientId = clientId;
      }

      return block;
    },
    onMerge: props.mergeBlocks,
    onReplace: props.onReplace,
    onRemove: props.onRemove,
    "data-empty": !text,
    placeholder: (0,external_wp_i18n_namespaceObject.__)('This is Paragraph.'),
    value: text,
    onChange: function onChange(val) {
      setAttributes({
        text: val
      });
    }
  }));
}));
;// CONCATENATED MODULE: ./src/blocks/blocks/paragraph/save.js



/* harmony default export */ const paragraph_save = (function (_ref) {
  var _ref$attributes = _ref.attributes,
      cssID = _ref$attributes.cssID,
      clientId = _ref$attributes.clientId,
      className = _ref$attributes.className,
      text = _ref$attributes.text;

  if (external_wp_blockEditor_namespaceObject.RichText.isEmpty(text)) {
    return '';
  }

  var classNames = (0,external_wp_hooks_namespaceObject.applyFilters)('blockart.paragraph.classnames', classnames_default()("blockart-paragraph blockart-paragraph-".concat(clientId), className));
  return /*#__PURE__*/React.createElement("p", {
    id: cssID !== null && cssID !== void 0 ? cssID : undefined,
    className: classNames
  }, /*#__PURE__*/React.createElement(external_wp_blockEditor_namespaceObject.RichText.Content, {
    value: text
  }));
});
;// CONCATENATED MODULE: ./src/blocks/blocks/paragraph/attributes.js


function paragraph_attributes_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function paragraph_attributes_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? paragraph_attributes_ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : paragraph_attributes_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }


/* harmony default export */ const paragraph_attributes = (paragraph_attributes_objectSpread({
  clientId: {
    type: 'string'
  },
  text: {
    type: 'string'
  },
  alignment: {
    type: 'object',
    style: [{
      selector: '.blockart-paragraph{{WRAPPER}} {text-align: {{VALUE}}; }'
    }]
  },
  typography: {
    type: 'object',
    "default": {
      typography: 1
    },
    style: [{
      selector: '.blockart-paragraph{{WRAPPER}}'
    }]
  },
  color: {
    type: 'string',
    style: [{
      selector: '.blockart-paragraph{{WRAPPER}} {color: {{VALUE}}; }'
    }]
  },
  hoverColor: {
    type: 'string',
    style: [{
      selector: '.blockart-paragraph{{WRAPPER}}:hover {color: {{VALUE}}; }'
    }]
  },
  background: {
    type: 'object',
    "default": {
      background: 1
    },
    style: [{
      selector: '.blockart-paragraph{{WRAPPER}}'
    }]
  },
  hoverBackground: {
    type: 'object',
    "default": {
      background: 1
    },
    style: [{
      selector: '.blockart-paragraph{{WRAPPER}}:hover'
    }]
  },
  margin: {
    type: 'object',
    "default": {
      dimension: 1,
      desktop: {
        lock: true
      }
    },
    style: [{
      selector: '.blockart-paragraph{{WRAPPER}} { margin: {{VALUE}}; }'
    }]
  }
}, blockAttributes));
;// CONCATENATED MODULE: ./src/blocks/blocks/paragraph/block.json
const paragraph_block_namespaceObject = JSON.parse('{"$schema":"https://schemas.wp.org/trunk/block.json","name":"blockart/paragraph","title":"Paragraph","description":"Customize typography and style paragraphs with multiple setting options.","keywords":["paragraph","text"],"category":"blockart","textdomain":"blockart","supports":{"className":false,"customClassName":false},"example":{"attributes":{}},"style":"blockart-blocks","editorScript":"blockart-blocks","editorStyle":"blockart-blocks-editor"}');
;// CONCATENATED MODULE: ./src/blocks/blocks/paragraph/index.js


function paragraph_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function paragraph_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? paragraph_ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : paragraph_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }








/* harmony default export */ const blocks_paragraph = (function () {
  (0,external_wp_blocks_namespaceObject.registerBlockType)('blockart/paragraph', paragraph_objectSpread(paragraph_objectSpread({}, paragraph_block_namespaceObject), {}, {
    icon: /*#__PURE__*/React.createElement(components_icon, {
      type: "blockIcon",
      name: "paragraph",
      size: 24
    }),
    attributes: paragraph_attributes,
    edit: paragraph_edit,
    save: paragraph_save
  }));
});
;// CONCATENATED MODULE: ./src/blocks/blocks/image/edit.js


function image_edit_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function image_edit_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? image_edit_ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : image_edit_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }











/* harmony default export */ const image_edit = ((0,external_wp_compose_namespaceObject.compose)([external_wp_components_namespaceObject.withNotices, with_client_id, with_device_type, with_copy_paste_styles])(function (props) {
  var _image$id, _image$url, _image$alt;

  var _props$attributes = props.attributes,
      clientId = _props$attributes.clientId,
      link = _props$attributes.link,
      _props$attributes$ima = _props$attributes.image,
      image = _props$attributes$ima === void 0 ? {} : _props$attributes$ima,
      alignment = _props$attributes.alignment,
      objectFit = _props$attributes.objectFit,
      border = _props$attributes.border,
      hoverBorder = _props$attributes.hoverBorder,
      boxShadow = _props$attributes.boxShadow,
      boxShadowHover = _props$attributes.boxShadowHover,
      blockMargin = _props$attributes.blockMargin,
      blockPadding = _props$attributes.blockPadding,
      blockZIndex = _props$attributes.blockZIndex,
      cssID = _props$attributes.cssID,
      width = _props$attributes.width,
      height = _props$attributes.height,
      maxWidth = _props$attributes.maxWidth,
      opacity = _props$attributes.opacity,
      hideOnDesktop = _props$attributes.hideOnDesktop,
      hideOnTablet = _props$attributes.hideOnTablet,
      hideOnMobile = _props$attributes.hideOnMobile,
      className = _props$attributes.className,
      setAttributes = props.setAttributes,
      noticeUI = props.noticeUI,
      noticeOperations = props.noticeOperations,
      CopyPasteStylesBlockControl = props.copyPasteStylesBlockControl,
      deviceType = props.deviceType;
  var id = (_image$id = image === null || image === void 0 ? void 0 : image.id) !== null && _image$id !== void 0 ? _image$id : undefined;
  var url = (_image$url = image === null || image === void 0 ? void 0 : image.url) !== null && _image$url !== void 0 ? _image$url : undefined;
  var alt = (_image$alt = image === null || image === void 0 ? void 0 : image.alt) !== null && _image$alt !== void 0 ? _image$alt : '';
  var Style = use_block_style({
    blockName: 'image',
    clientId: clientId,
    attributes: props.attributes,
    deviceType: deviceType
  });
  var classNames = (0,external_wp_hooks_namespaceObject.applyFilters)('blockart.image.classnames', classnames_default()("blockart-image blockart-image-".concat(clientId), className));

  var onError = function onError(message) {
    noticeOperations.removeAllNotices();
    noticeOperations.createErrorNotice(message);
  };

  var onSelect = function onSelect(media) {
    if (!(media !== null && media !== void 0 && media.url)) {
      return;
    }

    var u = media.url,
        i = media.id,
        h = media.height,
        w = media.width,
        a = media.alt;
    setAttributes({
      image: {
        url: u,
        id: i,
        height: h,
        width: w,
        alt: a
      }
    });
  };

  var onSelectURL = function onSelectURL(u) {
    setAttributes({
      image: {
        url: u,
        id: undefined,
        height: undefined,
        width: undefined,
        alt: undefined
      }
    });
  };

  return /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(external_wp_blockEditor_namespaceObject.InspectorControls, null, /*#__PURE__*/React.createElement(tab_panel, {
    root: true
  }, /*#__PURE__*/React.createElement(tab, {
    tabTitle: (0,external_wp_i18n_namespaceObject.__)('Layout', 'blockart')
  }, /*#__PURE__*/React.createElement(layout, {
    block: "image"
  })), /*#__PURE__*/React.createElement(tab, {
    tabTitle: (0,external_wp_i18n_namespaceObject.__)('Settings', 'blockart')
  }, /*#__PURE__*/React.createElement(panel, {
    title: (0,external_wp_i18n_namespaceObject.__)('General', 'blockart'),
    initialOpen: true
  }, /*#__PURE__*/React.createElement(advance_select, {
    value: alignment,
    onChange: function onChange(val) {
      return setAttributes({
        alignment: val
      });
    },
    responsive: true,
    label: (0,external_wp_i18n_namespaceObject.__)('Alignment', 'blockart'),
    options: [{
      label: (0,external_wp_i18n_namespaceObject.__)('Left', 'blockart'),
      value: 'left',
      icon: 'align-left'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Center', 'blockart'),
      value: 'center',
      icon: 'align-center'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Right', 'blockart'),
      value: 'right',
      icon: 'align-right'
    }]
  }), /*#__PURE__*/React.createElement(components_media, {
    onChange: function onChange(val) {
      return setAttributes({
        image: val
      });
    },
    label: (0,external_wp_i18n_namespaceObject.__)('Image', 'blockart'),
    type: 'image',
    value: image
  }), /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.TextareaControl, {
    label: (0,external_wp_i18n_namespaceObject.__)('Alt text (alternative text)', 'blockart'),
    className: "blockart-control blockart-textarea",
    value: alt,
    onChange: function onChange(val) {
      return setAttributes({
        image: image_edit_objectSpread(image_edit_objectSpread({}, image !== null && image !== void 0 ? image : {}), {}, {
          alt: val
        })
      });
    },
    help: /*#__PURE__*/React.createElement(React.Fragment, null, /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.ExternalLink, {
      href: "https://www.w3.org/WAI/tutorials/images/decision-tree"
    }, (0,external_wp_i18n_namespaceObject.__)('Describe the purpose of the image', 'blockart')), /*#__PURE__*/React.createElement("br", null), (0,external_wp_i18n_namespaceObject.__)('Leave empty if the image is purely decorative.', 'blockart'))
  }), /*#__PURE__*/React.createElement(url_input, {
    label: (0,external_wp_i18n_namespaceObject.__)('Link', 'blockart'),
    onChange: function onChange(val) {
      return setAttributes({
        link: val
      });
    },
    value: link,
    placeholder: "https://",
    newTab: true
  })), /*#__PURE__*/React.createElement(panel, {
    title: (0,external_wp_i18n_namespaceObject.__)('Image', 'blockart')
  }, /*#__PURE__*/React.createElement(slider, {
    onChange: function onChange(val) {
      return setAttributes({
        width: val
      });
    },
    label: (0,external_wp_i18n_namespaceObject.__)('Width', 'blockart'),
    units: ['px', 'em', '%'],
    responsive: true,
    min: 0,
    max: 1920,
    value: width
  }), /*#__PURE__*/React.createElement(slider, {
    onChange: function onChange(val) {
      return setAttributes({
        maxWidth: val
      });
    },
    label: (0,external_wp_i18n_namespaceObject.__)('Max Width', 'blockart'),
    units: ['px', 'em', '%'],
    responsive: true,
    min: 0,
    max: 1920,
    value: maxWidth
  }), /*#__PURE__*/React.createElement(slider, {
    onChange: function onChange(val) {
      return setAttributes({
        height: val
      });
    },
    label: (0,external_wp_i18n_namespaceObject.__)('Height', 'blockart'),
    units: ['px', 'em', '%'],
    responsive: true,
    min: 0,
    max: 1000,
    value: height
  }), /*#__PURE__*/React.createElement(components_select, {
    onChange: function onChange(val) {
      return setAttributes({
        objectFit: val
      });
    },
    value: objectFit,
    responsive: true,
    label: (0,external_wp_i18n_namespaceObject.__)('Object Fit', 'blockart'),
    options: [{
      label: (0,external_wp_i18n_namespaceObject.__)('Fill', 'blockart'),
      value: 'fill'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Cover', 'blockart'),
      value: 'cover'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Contain', 'blockart'),
      value: 'contain'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('None', 'blockart'),
      value: 'none'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Scale Down', 'blockart'),
      value: 'scale-down'
    }]
  }), /*#__PURE__*/React.createElement(slider, {
    onChange: function onChange(val) {
      return setAttributes({
        opacity: val
      });
    },
    label: (0,external_wp_i18n_namespaceObject.__)('Opacity', 'blockart'),
    responsive: true,
    step: 0.1,
    min: 0,
    max: 1,
    value: opacity
  })), /*#__PURE__*/React.createElement(panel, {
    title: (0,external_wp_i18n_namespaceObject.__)('Border', 'blockart')
  }, /*#__PURE__*/React.createElement(tab_panel, null, /*#__PURE__*/React.createElement(tab, {
    tabTitle: (0,external_wp_i18n_namespaceObject.__)('Normal', 'blockart')
  }, /*#__PURE__*/React.createElement(components_border, {
    value: border,
    onChange: function onChange(val) {
      return setAttributes({
        border: val
      });
    }
  }), /*#__PURE__*/React.createElement(box_shadow, {
    value: boxShadow,
    onChange: function onChange(val) {
      return setAttributes({
        boxShadow: val
      });
    }
  })), /*#__PURE__*/React.createElement(tab, {
    tabTitle: (0,external_wp_i18n_namespaceObject.__)('Hover', 'blockart')
  }, /*#__PURE__*/React.createElement(components_border, {
    value: hoverBorder,
    onChange: function onChange(val) {
      return setAttributes({
        hoverBorder: val
      });
    }
  }), /*#__PURE__*/React.createElement(box_shadow, {
    value: boxShadowHover,
    onChange: function onChange(val) {
      return setAttributes({
        boxShadowHover: val
      });
    }
  }))))), /*#__PURE__*/React.createElement(tab, {
    tabTitle: (0,external_wp_i18n_namespaceObject.__)('Advanced', 'blockart')
  }, /*#__PURE__*/React.createElement(BlockAdvanceSettings, {
    blockMargin: blockMargin,
    blockPadding: blockPadding,
    blockZIndex: blockZIndex,
    cssID: cssID,
    setAttributes: setAttributes
  }), /*#__PURE__*/React.createElement(BlockResponsiveSettings, {
    hideOnDesktop: hideOnDesktop,
    hideOnTablet: hideOnTablet,
    hideOnMobile: hideOnMobile,
    setAttributes: setAttributes
  }), /*#__PURE__*/React.createElement(BlockCSSSettings, {
    className: className,
    setAttributes: setAttributes,
    hasBlockCSS: false
  })))), /*#__PURE__*/React.createElement(external_wp_blockEditor_namespaceObject.BlockControls, null, /*#__PURE__*/React.createElement(CopyPasteStylesBlockControl, null)), /*#__PURE__*/React.createElement(external_wp_blockEditor_namespaceObject.BlockControls, {
    group: "other"
  }, /*#__PURE__*/React.createElement(external_wp_blockEditor_namespaceObject.MediaReplaceFlow, {
    mediaId: id,
    mediaURL: url,
    allowedTypes: ['image'],
    accept: "image/*",
    onSelect: onSelect,
    onSelectURL: onSelectURL,
    onError: onError
  })), /*#__PURE__*/React.createElement(Style, null), /*#__PURE__*/React.createElement("div", {
    id: cssID ? cssID : null,
    className: classNames
  }, url ? /*#__PURE__*/React.createElement("img", {
    src: url,
    alt: alt !== null && alt !== void 0 ? alt : ''
  }) : /*#__PURE__*/React.createElement(external_wp_blockEditor_namespaceObject.MediaPlaceholder, {
    onSelect: onSelect,
    notices: noticeUI,
    onError: onError,
    accept: "image/*",
    allowedTypes: ['image'],
    value: {
      src: url,
      id: id
    },
    onSelectURL: onSelectURL
  })));
}));
;// CONCATENATED MODULE: ./src/blocks/blocks/image/save.js




/* harmony default export */ const image_save = (function (_ref) {
  var _image$alt, _image$height, _image$width;

  var _ref$attributes = _ref.attributes,
      cssID = _ref$attributes.cssID,
      _ref$attributes$image = _ref$attributes.image,
      image = _ref$attributes$image === void 0 ? {} : _ref$attributes$image,
      clientId = _ref$attributes.clientId,
      className = _ref$attributes.className,
      link = _ref$attributes.link;
  var classNames = (0,external_wp_hooks_namespaceObject.applyFilters)('blockart.image.classnames', classnames_default()("blockart-image blockart-image-".concat(clientId), className));
  var imageClassNames = classnames_default()(_defineProperty({}, "wp-image-".concat(image === null || image === void 0 ? void 0 : image.id), !!(image !== null && image !== void 0 && image.id)));
  var imageHTML = /*#__PURE__*/React.createElement("img", {
    className: imageClassNames || undefined,
    src: image === null || image === void 0 ? void 0 : image.url,
    alt: (_image$alt = image === null || image === void 0 ? void 0 : image.alt) !== null && _image$alt !== void 0 ? _image$alt : '',
    height: (_image$height = image === null || image === void 0 ? void 0 : image.height) !== null && _image$height !== void 0 ? _image$height : undefined,
    width: (_image$width = image === null || image === void 0 ? void 0 : image.width) !== null && _image$width !== void 0 ? _image$width : undefined
  });

  if (link !== null && link !== void 0 && link.url) {
    imageHTML = /*#__PURE__*/React.createElement(components_element, {
      tagName: "a",
      htmlAttrs: {
        href: link.url,
        target: link !== null && link !== void 0 && link.newTab ? '_blank' : undefined,
        rel: link !== null && link !== void 0 && link.rel ? 'noopener' : undefined
      },
      children: imageHTML
    });
  }

  return /*#__PURE__*/React.createElement("div", {
    id: cssID !== null && cssID !== void 0 ? cssID : undefined,
    className: classNames || undefined
  }, imageHTML);
});
;// CONCATENATED MODULE: ./src/blocks/blocks/image/attributes.js


function image_attributes_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function image_attributes_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? image_attributes_ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : image_attributes_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }


/* harmony default export */ const image_attributes = (image_attributes_objectSpread({
  clientId: {
    type: 'string'
  },
  link: {
    type: 'object',
    "default": {}
  },
  image: {
    type: 'object',
    "default": {}
  },
  alt1: {
    type: 'string'
  },
  alt2: {
    type: 'string'
  },
  alignment: {
    type: 'object',
    style: [{
      selector: '{{WRAPPER}} {text-align: {{VALUE}}; }'
    }]
  },
  objectFit: {
    type: 'object',
    "default": {
      desktop: 'fill'
    },
    style: [{
      selector: '{{WRAPPER}} img {object-fit: {{VALUE}}; }'
    }]
  },
  border: {
    type: 'object',
    "default": {
      border: 1,
      radius: {
        desktop: {
          lock: true
        }
      },
      size: {
        desktop: {
          lock: true
        }
      }
    },
    style: [{
      selector: '{{WRAPPER}} img'
    }]
  },
  hoverBorder: {
    type: 'object',
    "default": {
      border: 1,
      radius: {
        desktop: {
          lock: true
        }
      },
      size: {
        desktop: {
          lock: true
        }
      }
    },
    style: [{
      selector: '{{WRAPPER}} img:hover'
    }]
  },
  boxShadow: {
    type: 'object',
    "default": {
      boxShadow: 1
    },
    style: [{
      selector: '{{WRAPPER}} img'
    }]
  },
  boxShadowHover: {
    type: 'object',
    "default": {
      boxShadow: 1
    },
    style: [{
      selector: '{{WRAPPER}} img:hover'
    }]
  },
  width: {
    type: 'object',
    style: [{
      selector: '{{WRAPPER}} img { width: {{VALUE}} }'
    }]
  },
  maxWidth: {
    type: 'object',
    style: [{
      selector: '{{WRAPPER}} img { max-width: {{VALUE}} }'
    }]
  },
  height: {
    type: 'object',
    style: [{
      selector: '{{WRAPPER}} img { height: {{VALUE}} }'
    }]
  },
  opacity: {
    type: 'string',
    "default": 1,
    style: [{
      selector: '{{WRAPPER}} img { opacity: {{VALUE}} }'
    }]
  }
}, blockAttributes));
;// CONCATENATED MODULE: ./src/blocks/blocks/image/block.json
const image_block_namespaceObject = JSON.parse('{"$schema":"https://schemas.wp.org/trunk/block.json","name":"blockart/image","title":"Image","description":"Visual communication with your visitor via images.","keywords":["image"],"category":"blockart","textdomain":"blockart","supports":{"className":false,"customClassName":false},"example":{"attributes":{}},"style":"blockart-blocks","editorScript":"blockart-blocks","editorStyle":"blockart-blocks-editor"}');
;// CONCATENATED MODULE: ./src/blocks/blocks/image/deprecated/v1.js


function deprecated_v1_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function deprecated_v1_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? deprecated_v1_ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : deprecated_v1_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }




/* harmony default export */ const deprecated_v1 = ({
  attributes: image_attributes,
  supports: {
    className: false,
    align: false,
    color: {
      background: false,
      gradient: false,
      text: false
    }
  },
  save: function save(props) {
    var _ref, _image$local;

    var _props$attributes = props.attributes,
        cssID = _props$attributes.cssID,
        image = _props$attributes.image,
        clientId = _props$attributes.clientId,
        className = _props$attributes.className,
        alt1 = _props$attributes.alt1,
        alt2 = _props$attributes.alt2,
        link = _props$attributes.link;
    var src = (_ref = (_image$local = image === null || image === void 0 ? void 0 : image.local) !== null && _image$local !== void 0 ? _image$local : image === null || image === void 0 ? void 0 : image.external) !== null && _ref !== void 0 ? _ref : _BLOCKART_.placeholderImage;
    var alt = image !== null && image !== void 0 && image.local ? alt1 !== null && alt1 !== void 0 ? alt1 : '' : alt2 !== null && alt2 !== void 0 ? alt2 : '';
    var classNames = (0,external_wp_hooks_namespaceObject.applyFilters)('blockart.image.classnames', classnames_default()("blockart-image blockart-image-".concat(clientId, " "), className));
    /* eslint-disable */

    return /*#__PURE__*/React.createElement("div", {
      id: cssID ? cssID : null,
      className: classNames
    }, link.url ? /*#__PURE__*/React.createElement("a", {
      href: link.url,
      target: link.newTab ? '_blank' : null,
      rel: link.newTab ? 'noopener' : null
    }, /*#__PURE__*/React.createElement("img", {
      src: src,
      alt: alt
    })) : /*#__PURE__*/React.createElement("img", {
      src: src,
      alt: alt
    }));
  },
  migrate: function migrate(attributes) {
    var image = attributes.image;
    var newImageProps = {};

    if ('external' === (image === null || image === void 0 ? void 0 : image.type)) {
      if (image !== null && image !== void 0 && image.external) {
        newImageProps = {
          width: undefined,
          height: undefined,
          url: image.external,
          id: undefined,
          alt: undefined
        };
      }
    } else if ('local' === (image === null || image === void 0 ? void 0 : image.type)) {
      if (image !== null && image !== void 0 && image.local) {
        var _mediaItem$media_deta, _mediaItem$media_deta2, _mediaItem$source_url;

        var mediaItems = _BLOCKART_.mediaItems;
        var mediaItem = mediaItems.find(function (item) {
          return item.source_url === image.local;
        });
        newImageProps = {
          width: mediaItem === null || mediaItem === void 0 ? void 0 : (_mediaItem$media_deta = mediaItem.media_details) === null || _mediaItem$media_deta === void 0 ? void 0 : _mediaItem$media_deta.width,
          height: mediaItem === null || mediaItem === void 0 ? void 0 : (_mediaItem$media_deta2 = mediaItem.media_details) === null || _mediaItem$media_deta2 === void 0 ? void 0 : _mediaItem$media_deta2.height,
          url: (_mediaItem$source_url = mediaItem === null || mediaItem === void 0 ? void 0 : mediaItem.source_url) !== null && _mediaItem$source_url !== void 0 ? _mediaItem$source_url : image.local,
          id: mediaItem === null || mediaItem === void 0 ? void 0 : mediaItem.ID,
          alt: mediaItem === null || mediaItem === void 0 ? void 0 : mediaItem.alt_text
        };
      }
    }

    return deprecated_v1_objectSpread(deprecated_v1_objectSpread({}, attributes), {}, {
      image: newImageProps
    });
  }
});
;// CONCATENATED MODULE: ./src/blocks/blocks/image/deprecated/index.js

;// CONCATENATED MODULE: ./src/blocks/blocks/image/index.js


function image_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function image_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? image_ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : image_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }









/* harmony default export */ const blocks_image = (function () {
  (0,external_wp_blocks_namespaceObject.registerBlockType)('blockart/image', image_objectSpread(image_objectSpread({}, image_block_namespaceObject), {}, {
    icon: /*#__PURE__*/React.createElement(components_icon, {
      type: "blockIcon",
      name: "image",
      size: 24
    }),
    attributes: image_attributes,
    edit: image_edit,
    save: image_save,
    deprecated: [deprecated_v1]
  }));
});
;// CONCATENATED MODULE: ./src/blocks/blocks/heading/edit.js











/* harmony default export */ const heading_edit = ((0,external_wp_compose_namespaceObject.compose)([with_client_id, with_device_type, with_copy_paste_styles])(function (props) {
  var _props$attributes = props.attributes,
      clientId = _props$attributes.clientId,
      markup = _props$attributes.markup,
      text = _props$attributes.text,
      color = _props$attributes.color,
      hoverColor = _props$attributes.hoverColor,
      margin = _props$attributes.margin,
      background = _props$attributes.background,
      hoverBackground = _props$attributes.hoverBackground,
      alignment = _props$attributes.alignment,
      size = _props$attributes.size,
      typography = _props$attributes.typography,
      border = _props$attributes.border,
      hoverBorder = _props$attributes.hoverBorder,
      boxShadow = _props$attributes.boxShadow,
      boxShadowHover = _props$attributes.boxShadowHover,
      blockPadding = _props$attributes.blockPadding,
      blockZIndex = _props$attributes.blockZIndex,
      cssID = _props$attributes.cssID,
      hideOnDesktop = _props$attributes.hideOnDesktop,
      hideOnTablet = _props$attributes.hideOnTablet,
      hideOnMobile = _props$attributes.hideOnMobile,
      className = _props$attributes.className,
      setAttributes = props.setAttributes,
      CopyPasteStylesBlockControl = props.copyPasteStylesBlockControl,
      deviceType = props.deviceType;
  var Style = use_block_style({
    blockName: 'heading',
    clientId: clientId,
    attributes: props.attributes,
    deviceType: deviceType
  });
  var classNames = (0,external_wp_hooks_namespaceObject.applyFilters)('blockart.heading.classnames', classnames_default()("blockart-heading blockart-heading-".concat(clientId), size && "is-".concat(size), className));
  return /*#__PURE__*/React.createElement(external_wp_element_namespaceObject.Fragment, null, /*#__PURE__*/React.createElement(external_wp_blockEditor_namespaceObject.InspectorControls, null, /*#__PURE__*/React.createElement(tab_panel, {
    root: true
  }, /*#__PURE__*/React.createElement(tab, {
    tabTitle: (0,external_wp_i18n_namespaceObject.__)('Layout', 'blockart')
  }, /*#__PURE__*/React.createElement(layout, {
    block: "heading"
  })), /*#__PURE__*/React.createElement(tab, {
    tabTitle: (0,external_wp_i18n_namespaceObject.__)('Settings', 'blockart')
  }, /*#__PURE__*/React.createElement(panel, {
    title: (0,external_wp_i18n_namespaceObject.__)('General', 'blockart'),
    initialOpen: true
  }, /*#__PURE__*/React.createElement(advance_select, {
    value: alignment,
    onChange: function onChange(val) {
      return setAttributes({
        alignment: val
      });
    },
    responsive: true,
    label: (0,external_wp_i18n_namespaceObject.__)('Alignment', 'blockart'),
    options: [{
      label: (0,external_wp_i18n_namespaceObject.__)('Text align left', 'blockart'),
      value: 'left',
      icon: 'text-align-left'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Text align center', 'blockart'),
      value: 'center',
      icon: 'text-align-center'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Text align right', 'blockart'),
      value: 'right',
      icon: 'text-align-right'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('Text align justify', 'blockart'),
      value: 'justify',
      icon: 'text-align-justify'
    }]
  }), /*#__PURE__*/React.createElement(components_size, {
    label: (0,external_wp_i18n_namespaceObject.__)('Size', 'blockart'),
    onChange: function onChange(key, val) {
      return setAttributes(_defineProperty({}, key, val));
    },
    value: size || ''
  }), /*#__PURE__*/React.createElement(components_select, {
    options: [{
      label: (0,external_wp_i18n_namespaceObject.__)('H1', 'blockart'),
      value: 'h1'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('H2', 'blockart'),
      value: 'h2'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('H3', 'blockart'),
      value: 'h3'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('H4', 'blockart'),
      value: 'h4'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('H5', 'blockart'),
      value: 'h5'
    }, {
      label: (0,external_wp_i18n_namespaceObject.__)('H6', 'blockart'),
      value: 'h6'
    }],
    onChange: function onChange(val) {
      return setAttributes({
        markup: val
      });
    },
    value: markup,
    label: (0,external_wp_i18n_namespaceObject.__)('HTML Markup', 'blockart'),
    inline: false
  })), /*#__PURE__*/React.createElement(panel, {
    title: (0,external_wp_i18n_namespaceObject.__)('Text', 'blockart')
  }, /*#__PURE__*/React.createElement(components_typography, {
    value: typography,
    onChange: function onChange(val) {
      return setAttributes({
        typography: val
      });
    }
  })), /*#__PURE__*/React.createElement(panel, {
    title: (0,external_wp_i18n_namespaceObject.__)('Spacing', 'blockart')
  }, /*#__PURE__*/React.createElement(dimensions, {
    value: margin || {},
    responsive: true,
    label: (0,external_wp_i18n_namespaceObject.__)('Margin', 'blockart'),
    defaultUnit: "px",
    units: ['px', 'rem', 'em', '%'],
    onChange: function onChange(val) {
      return setAttributes({
        margin: val
      });
    },
    type: "margin"
  })), /*#__PURE__*/React.createElement(panel, {
    title: (0,external_wp_i18n_namespaceObject.__)('Color', 'blockart')
  }, /*#__PURE__*/React.createElement(tab_panel, null, /*#__PURE__*/React.createElement(tab, {
    tabTitle: (0,external_wp_i18n_namespaceObject.__)('Normal', 'blockart')
  }, /*#__PURE__*/React.createElement(components_color, {
    onChange: function onChange(val) {
      return setAttributes({
        color: val
      });
    },
    label: (0,external_wp_i18n_namespaceObject.__)('Color', 'blockart'),
    value: color || ''
  }), /*#__PURE__*/React.createElement(components_background, {
    value: background,
    onChange: function onChange(val) {
      return setAttributes({
        background: val
      });
    },
    label: (0,external_wp_i18n_namespaceObject.__)('Background', 'blockart')
  })), /*#__PURE__*/React.createElement(tab, {
    tabTitle: (0,external_wp_i18n_namespaceObject.__)('Hover', 'blockart')
  }, /*#__PURE__*/React.createElement(components_color, {
    onChange: function onChange(val) {
      return setAttributes({
        hoverColor: val
      });
    },
    label: (0,external_wp_i18n_namespaceObject.__)('Color', 'blockart'),
    value: hoverColor || ''
  }), /*#__PURE__*/React.createElement(components_background, {
    value: hoverBackground,
    onChange: function onChange(val) {
      return setAttributes({
        hoverBackground: val
      });
    },
    label: (0,external_wp_i18n_namespaceObject.__)('Background', 'blockart')
  })))), /*#__PURE__*/React.createElement(panel, {
    title: (0,external_wp_i18n_namespaceObject.__)('Border', 'blockart')
  }, /*#__PURE__*/React.createElement(tab_panel, null, /*#__PURE__*/React.createElement(tab, {
    tabTitle: (0,external_wp_i18n_namespaceObject.__)('Normal', 'blockart')
  }, /*#__PURE__*/React.createElement(components_border, {
    value: border,
    onChange: function onChange(val) {
      return setAttributes({
        border: val
      });
    }
  }), /*#__PURE__*/React.createElement(box_shadow, {
    value: boxShadow,
    onChange: function onChange(val) {
      return setAttributes({
        boxShadow: val
      });
    }
  })), /*#__PURE__*/React.createElement(tab, {
    tabTitle: (0,external_wp_i18n_namespaceObject.__)('Hover', 'blockart')
  }, /*#__PURE__*/React.createElement(components_border, {
    value: hoverBorder,
    onChange: function onChange(val) {
      return setAttributes({
        hoverBorder: val
      });
    }
  }), /*#__PURE__*/React.createElement(box_shadow, {
    value: boxShadowHover,
    onChange: function onChange(val) {
      return setAttributes({
        boxShadowHover: val
      });
    }
  }))))), /*#__PURE__*/React.createElement(tab, {
    tabTitle: (0,external_wp_i18n_namespaceObject.__)('Advanced', 'blockart')
  }, /*#__PURE__*/React.createElement(panel, {
    title: (0,external_wp_i18n_namespaceObject.__)('Advanced', 'blockart'),
    initialOpen: true
  }, /*#__PURE__*/React.createElement(dimensions, {
    value: blockPadding || {},
    responsive: true,
    label: (0,external_wp_i18n_namespaceObject.__)('Block Padding', 'blockart'),
    min: 0,
    max: 500,
    defaultUnit: "px",
    units: ['px', 'rem', 'em', '%'],
    onChange: function onChange(val) {
      return setAttributes({
        blockPadding: val
      });
    }
  }), /*#__PURE__*/React.createElement(slider, {
    label: (0,external_wp_i18n_namespaceObject.__)('Z-Index', 'blockart'),
    value: blockZIndex || 0,
    min: 0,
    max: 10000,
    step: 1,
    onChange: function onChange(val) {
      return setAttributes({
        blockZIndex: val
      });
    }
  }), /*#__PURE__*/React.createElement(input, {
    value: cssID || '',
    label: (0,external_wp_i18n_namespaceObject.__)('CSS ID', 'blockart'),
    onChange: function onChange(val) {
      return setAttributes({
        cssID: val
      });
    },
    labelPosition: "side"
  })), /*#__PURE__*/React.createElement(BlockResponsiveSettings, {
    hideOnDesktop: hideOnDesktop,
    hideOnTablet: hideOnTablet,
    hideOnMobile: hideOnMobile,
    setAttributes: setAttributes
  }), /*#__PURE__*/React.createElement(BlockCSSSettings, {
    className: className,
    setAttributes: setAttributes,
    hasBlockCSS: false
  })))), /*#__PURE__*/React.createElement(external_wp_blockEditor_namespaceObject.BlockControls, null, /*#__PURE__*/React.createElement(CopyPasteStylesBlockControl, null)), /*#__PURE__*/React.createElement(Style, null), /*#__PURE__*/React.createElement(external_wp_blockEditor_namespaceObject.RichText, {
    id: cssID ? cssID : null,
    className: classNames,
    tagName: markup,
    placeholder: (0,external_wp_i18n_namespaceObject.__)('This is heading', 'blockart'),
    value: text,
    onChange: function onChange(val) {
      setAttributes({
        text: val
      });
    }
  }));
}));
;// CONCATENATED MODULE: ./src/blocks/blocks/heading/save.js



/* harmony default export */ const heading_save = (function (_ref) {
  var _ref$attributes = _ref.attributes,
      markup = _ref$attributes.markup,
      text = _ref$attributes.text,
      className = _ref$attributes.className,
      cssID = _ref$attributes.cssID,
      size = _ref$attributes.size,
      clientId = _ref$attributes.clientId;
  var classNames = (0,external_wp_hooks_namespaceObject.applyFilters)('blockart.heading.classnames', classnames_default()("blockart-heading blockart-heading-".concat(clientId), size && "is-".concat(size), className));
  return /*#__PURE__*/React.createElement(external_wp_blockEditor_namespaceObject.RichText.Content, {
    id: cssID !== null && cssID !== void 0 ? cssID : undefined,
    className: classNames,
    tagName: markup,
    value: text
  });
});
;// CONCATENATED MODULE: ./src/blocks/blocks/heading/attributes.js


function heading_attributes_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function heading_attributes_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? heading_attributes_ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : heading_attributes_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }


/* harmony default export */ const heading_attributes = (heading_attributes_objectSpread({
  clientId: {
    type: 'string'
  },
  markup: {
    type: 'string',
    "default": 'h2'
  },
  text: {
    type: 'string'
  },
  color: {
    type: 'string',
    style: [{
      selector: '.blockart-heading{{WRAPPER}} {color: {{VALUE}}; }'
    }]
  },
  hoverColor: {
    type: 'string',
    style: [{
      selector: '.blockart-heading{{WRAPPER}}:hover {color: {{VALUE}}; }'
    }]
  },
  background: {
    type: 'object',
    "default": {
      background: 1
    },
    style: [{
      selector: '.blockart-heading{{WRAPPER}}'
    }]
  },
  hoverBackground: {
    type: 'object',
    "default": {
      background: 1
    },
    style: [{
      selector: '.blockart-heading{{WRAPPER}}:hover'
    }]
  },
  alignment: {
    type: 'object',
    style: [{
      selector: '.blockart-heading{{WRAPPER}} {text-align: {{VALUE}}; }'
    }]
  },
  size: {
    type: 'string'
  },
  typography: {
    type: 'object',
    "default": {
      typography: 1,
      weight: 500
    },
    style: [{
      selector: '.blockart-heading{{WRAPPER}}'
    }]
  },
  border: {
    type: 'object',
    "default": {
      border: 1,
      radius: {
        desktop: {
          lock: true
        }
      },
      size: {
        desktop: {
          lock: true
        }
      }
    },
    style: [{
      selector: '.blockart-heading{{WRAPPER}}'
    }]
  },
  hoverBorder: {
    type: 'object',
    "default": {
      border: 1,
      radius: {
        desktop: {
          lock: true
        }
      },
      size: {
        desktop: {
          lock: true
        }
      }
    },
    style: [{
      selector: '.blockart-heading{{WRAPPER}}:hover'
    }]
  },
  boxShadow: {
    type: 'object',
    "default": {
      boxShadow: 1
    },
    style: [{
      selector: '.blockart-heading{{WRAPPER}}'
    }]
  },
  boxShadowHover: {
    type: 'object',
    "default": {
      boxShadow: 1
    },
    style: [{
      selector: '.blockart-heading{{WRAPPER}}:hover'
    }]
  },
  margin: {
    type: 'object',
    "default": {
      dimension: 1,
      desktop: {
        lock: true
      }
    },
    style: [{
      selector: '.blockart-heading{{WRAPPER}} { margin: {{VALUE}}; }'
    }]
  }
}, blockAttributes));
;// CONCATENATED MODULE: ./src/blocks/blocks/heading/block.json
const heading_block_namespaceObject = JSON.parse('{"$schema":"https://schemas.wp.org/trunk/block.json","name":"blockart/heading","title":"Heading","description":"Create stylish title for each section with various markups from H1 to H6.","keywords":["heading","headline"],"category":"blockart","textdomain":"blockart","supports":{"className":false,"customClassName":false},"example":{"attributes":{}},"style":"blockart-blocks","editorScript":"blockart-blocks","editorStyle":"blockart-blocks-editor"}');
;// CONCATENATED MODULE: ./src/blocks/blocks/heading/index.js


function heading_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function heading_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? heading_ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : heading_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }








/* harmony default export */ const blocks_heading = (function () {
  (0,external_wp_blocks_namespaceObject.registerBlockType)('blockart/heading', heading_objectSpread(heading_objectSpread({}, heading_block_namespaceObject), {}, {
    icon: /*#__PURE__*/React.createElement(components_icon, {
      type: "blockIcon",
      name: "heading",
      size: 24
    }),
    attributes: heading_attributes,
    edit: heading_edit,
    save: heading_save
  }));
});
;// CONCATENATED MODULE: ./src/blocks/blocks/spacing/edit.js









/* harmony default export */ const spacing_edit = ((0,external_wp_compose_namespaceObject.compose)([with_client_id, with_device_type, with_copy_paste_styles])(function (props) {
  var _props$attributes = props.attributes,
      clientId = _props$attributes.clientId,
      height = _props$attributes.height,
      background = _props$attributes.background,
      hoverBackground = _props$attributes.hoverBackground,
      border = _props$attributes.border,
      hoverBorder = _props$attributes.hoverBorder,
      boxShadow = _props$attributes.boxShadow,
      boxShadowHover = _props$attributes.boxShadowHover,
      blockMargin = _props$attributes.blockMargin,
      blockPadding = _props$attributes.blockPadding,
      blockZIndex = _props$attributes.blockZIndex,
      cssID = _props$attributes.cssID,
      className = _props$attributes.className,
      setAttributes = props.setAttributes,
      CopyPasteStylesBlockControl = props.copyPasteStylesBlockControl,
      deviceType = props.deviceType;
  var classNames = (0,external_wp_hooks_namespaceObject.applyFilters)('blockart.spacing.classnames', classnames_default()("blockart-spacing blockart-spacing-".concat(clientId), className));
  var Style = use_block_style({
    blockName: 'spacing',
    clientId: clientId,
    attributes: props.attributes,
    deviceType: deviceType
  });
  return /*#__PURE__*/React.createElement(external_wp_element_namespaceObject.Fragment, null, /*#__PURE__*/React.createElement(external_wp_blockEditor_namespaceObject.InspectorControls, null, /*#__PURE__*/React.createElement(tab_panel, {
    root: true
  }, /*#__PURE__*/React.createElement(tab, {
    tabTitle: (0,external_wp_i18n_namespaceObject.__)('Layout', 'blockart')
  }, /*#__PURE__*/React.createElement(layout, {
    block: "spacing"
  })), /*#__PURE__*/React.createElement(tab, {
    tabTitle: (0,external_wp_i18n_namespaceObject.__)('Settings', 'blockart')
  }, /*#__PURE__*/React.createElement(panel, {
    title: (0,external_wp_i18n_namespaceObject.__)('General', 'blockart'),
    initialOpen: true
  }, /*#__PURE__*/React.createElement(slider, {
    onChange: function onChange(val) {
      return setAttributes({
        height: val
      });
    },
    label: (0,external_wp_i18n_namespaceObject.__)('Height', 'blockart'),
    units: ['px', 'em', 'vh'],
    responsive: true,
    min: 1,
    max: 1000,
    value: height
  })), /*#__PURE__*/React.createElement(panel, {
    title: (0,external_wp_i18n_namespaceObject.__)('Color', 'blockart')
  }, /*#__PURE__*/React.createElement(tab_panel, null, /*#__PURE__*/React.createElement(tab, {
    tabTitle: (0,external_wp_i18n_namespaceObject.__)('Normal', 'blockart')
  }, /*#__PURE__*/React.createElement(components_background, {
    value: background,
    onChange: function onChange(val) {
      return setAttributes({
        background: val
      });
    },
    label: (0,external_wp_i18n_namespaceObject.__)('Background', 'blockart')
  })), /*#__PURE__*/React.createElement(tab, {
    tabTitle: (0,external_wp_i18n_namespaceObject.__)('Hover', 'blockart')
  }, /*#__PURE__*/React.createElement(components_background, {
    value: hoverBackground,
    onChange: function onChange(val) {
      return setAttributes({
        hoverBackground: val
      });
    },
    label: (0,external_wp_i18n_namespaceObject.__)('Background', 'blockart')
  })))), /*#__PURE__*/React.createElement(panel, {
    title: (0,external_wp_i18n_namespaceObject.__)('Border', 'blockart')
  }, /*#__PURE__*/React.createElement(tab_panel, null, /*#__PURE__*/React.createElement(tab, {
    tabTitle: (0,external_wp_i18n_namespaceObject.__)('Normal', 'blockart')
  }, /*#__PURE__*/React.createElement(components_border, {
    value: border,
    onChange: function onChange(val) {
      return setAttributes({
        border: val
      });
    }
  }), /*#__PURE__*/React.createElement(box_shadow, {
    value: boxShadow,
    onChange: function onChange(val) {
      return setAttributes({
        boxShadow: val
      });
    }
  })), /*#__PURE__*/React.createElement(tab, {
    tabTitle: (0,external_wp_i18n_namespaceObject.__)('Hover', 'blockart')
  }, /*#__PURE__*/React.createElement(components_border, {
    value: hoverBorder,
    onChange: function onChange(val) {
      return setAttributes({
        hoverBorder: val
      });
    }
  }), /*#__PURE__*/React.createElement(box_shadow, {
    value: boxShadowHover,
    onChange: function onChange(val) {
      return setAttributes({
        boxShadowHover: val
      });
    }
  }))))), /*#__PURE__*/React.createElement(tab, {
    tabTitle: (0,external_wp_i18n_namespaceObject.__)('Advanced', 'blockart')
  }, /*#__PURE__*/React.createElement(BlockAdvanceSettings, {
    blockMargin: blockMargin,
    blockPadding: blockPadding,
    blockZIndex: blockZIndex,
    cssID: cssID,
    setAttributes: setAttributes
  }), /*#__PURE__*/React.createElement(BlockCSSSettings, {
    className: className,
    setAttributes: setAttributes,
    hasBlockCSS: false
  })))), /*#__PURE__*/React.createElement(external_wp_blockEditor_namespaceObject.BlockControls, null, /*#__PURE__*/React.createElement(CopyPasteStylesBlockControl, null)), /*#__PURE__*/React.createElement(Style, null), /*#__PURE__*/React.createElement("div", {
    className: classNames
  }, /*#__PURE__*/React.createElement("div", {
    className: "blockart-spacing-inner ".concat(props.isSelected && 'is-selected')
  })));
}));
;// CONCATENATED MODULE: ./src/blocks/blocks/spacing/save.js


/* harmony default export */ const spacing_save = (function (_ref) {
  var _ref$attributes = _ref.attributes,
      cssID = _ref$attributes.cssID,
      clientId = _ref$attributes.clientId,
      className = _ref$attributes.className;
  var classNames = (0,external_wp_hooks_namespaceObject.applyFilters)('blockart.spacing.classnames', classnames_default()("blockart-spacing blockart-spacing-".concat(clientId), className));
  return /*#__PURE__*/React.createElement("div", {
    id: cssID !== null && cssID !== void 0 ? cssID : undefined,
    className: classNames
  }, /*#__PURE__*/React.createElement("div", {
    className: "blockart-spacing-inner"
  }));
});
;// CONCATENATED MODULE: ./src/blocks/blocks/spacing/attributes.js


function spacing_attributes_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function spacing_attributes_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? spacing_attributes_ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : spacing_attributes_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }


/* harmony default export */ const spacing_attributes = (spacing_attributes_objectSpread({
  clientId: {
    type: 'string'
  },
  height: {
    type: 'object',
    "default": {
      desktop: {
        value: 50,
        unit: 'px'
      }
    },
    style: [{
      selector: '{{WRAPPER}} .blockart-spacing-inner { height: {{VALUE}}; }'
    }]
  },
  background: {
    type: 'object',
    "default": {
      background: 1
    },
    style: [{
      selector: '{{WRAPPER}} .blockart-spacing-inner'
    }]
  },
  hoverBackground: {
    type: 'object',
    "default": {
      background: 1
    },
    style: [{
      selector: '{{WRAPPER}} .blockart-spacing-inner:hover'
    }]
  },
  border: {
    type: 'object',
    "default": {
      border: 1,
      radius: {
        desktop: {
          lock: true
        }
      },
      size: {
        desktop: {
          lock: true
        }
      }
    },
    style: [{
      selector: '{{WRAPPER}} .blockart-spacing-inner'
    }]
  },
  hoverBorder: {
    type: 'object',
    "default": {
      border: 1,
      radius: {
        desktop: {
          lock: true
        }
      },
      size: {
        desktop: {
          lock: true
        }
      }
    },
    style: [{
      selector: '{{WRAPPER}} .blockart-spacing-inner:hover'
    }]
  },
  boxShadow: {
    type: 'object',
    "default": {
      boxShadow: 1
    },
    style: [{
      selector: '{{WRAPPER}} .blockart-spacing-inner'
    }]
  },
  boxShadowHover: {
    type: 'object',
    "default": {
      boxShadow: 1
    },
    style: [{
      selector: '{{WRAPPER}} .blockart-spacing-inner:hover'
    }]
  }
}, blockAttributes));
;// CONCATENATED MODULE: ./src/blocks/blocks/spacing/block.json
const spacing_block_namespaceObject = JSON.parse('{"$schema":"https://schemas.wp.org/trunk/block.json","name":"blockart/spacing","title":"Spacing","description":"Give your designs room to breathe with white space.","keywords":["spacing","spacer","divider"],"category":"blockart","textdomain":"blockart","supports":{"className":false,"customClassName":false},"example":{"attributes":{}},"style":"blockart-blocks","editorScript":"blockart-blocks","editorStyle":"blockart-blocks-editor"}');
;// CONCATENATED MODULE: ./src/blocks/blocks/spacing/index.js


function spacing_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function spacing_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? spacing_ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : spacing_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }









/* harmony default export */ const blocks_spacing = (function () {
  (0,external_wp_blocks_namespaceObject.registerBlockType)('blockart/spacing', spacing_objectSpread(spacing_objectSpread({}, spacing_block_namespaceObject), {}, {
    icon: /*#__PURE__*/React.createElement(components_icon, {
      type: "blockIcon",
      name: "spacing",
      size: 24
    }),
    attributes: spacing_attributes,
    edit: spacing_edit,
    save: spacing_save
  }));
});
;// CONCATENATED MODULE: ./src/blocks/blocks/index.js








;// CONCATENATED MODULE: ./src/blocks/helpers/auto-recover-blocks.js


function auto_recover_blocks_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }

function auto_recover_blocks_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? auto_recover_blocks_ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : auto_recover_blocks_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }




var subscribeOnceWhen = function subscribeOnceWhen(predicate, callback) {
  var unsubscribe = (0,external_wp_data_namespaceObject.subscribe)(function () {
    if (predicate()) {
      setTimeout(function () {
        callback();
      }, 500);
      unsubscribe();
    }
  });
  return unsubscribe;
};

var isBlocksLoaded = function isBlocksLoaded() {
  var _select = (0,external_wp_data_namespaceObject.select)('core/block-editor'),
      getBlocks = _select.getBlocks;

  return getBlocks().length > 0;
};

var recoverBlock = function recoverBlock(_ref) {
  var name = _ref.name,
      attributes = _ref.attributes,
      innerBlocks = _ref.innerBlocks;
  return (0,external_wp_blocks_namespaceObject.createBlock)(name, attributes, innerBlocks);
};

var getInvalidBlocks = function getInvalidBlocks(blocks) {
  return blocks.reduce(function (invalidBlocks, block) {
    if (!block.isValid && block.name.includes('blockart')) {
      invalidBlocks.push(block);
    }

    if (block.innerBlocks.length > 0) {
      var invalidInnerBlocks = getInvalidBlocks(block.innerBlocks);

      if (invalidInnerBlocks.length > 0) {
        invalidBlocks = invalidBlocks.concat(invalidInnerBlocks);
      }
    }

    return invalidBlocks;
  }, []);
};

var recoverBlocks = function recoverBlocks() {
  var _window, _window2, _blocks;

  var _dispatch = (0,external_wp_data_namespaceObject.dispatch)('core/block-editor'),
      replaceBlock = _dispatch.replaceBlock;

  var blocks;

  if ('widgets' === ((_window = window) === null || _window === void 0 ? void 0 : _window.pagenow) || 'customize' === ((_window2 = window) === null || _window2 === void 0 ? void 0 : _window2.pagenow)) {
    var widgetAreas = (0,external_wp_data_namespaceObject.select)('core/block-editor').getBlocks();
    blocks = widgetAreas.map(function (widgetArea) {
      var innerBlocks = (0,external_wp_data_namespaceObject.select)('core/block-editor').getBlocks(widgetArea.clientId);
      return auto_recover_blocks_objectSpread(auto_recover_blocks_objectSpread({}, widgetArea), {}, {
        innerBlocks: innerBlocks
      });
    });
  } else {
    blocks = (0,external_wp_data_namespaceObject.select)('core/block-editor').getBlocks();
  }

  if ((_blocks = blocks) !== null && _blocks !== void 0 && _blocks.length) {
    var invalidBlocks = getInvalidBlocks(blocks);

    if (invalidBlocks !== null && invalidBlocks !== void 0 && invalidBlocks.length) {
      invalidBlocks.forEach(function (oldBlock) {
        var newBlock = recoverBlock(oldBlock);

        if (newBlock.isValid) {
          replaceBlock(oldBlock.clientId, newBlock);
        }
      });
    }
  }
};

var run = function run() {
  return new Promise(function (resolve) {
    subscribeOnceWhen(isBlocksLoaded, function () {
      recoverBlocks();
      setTimeout(function () {
        return resolve();
      }, 200);
    });
  });
};

/* harmony default export */ const auto_recover_blocks = (function () {
  run().then(function () {});
});
;// CONCATENATED MODULE: external "jQuery"
const external_jQuery_namespaceObject = window["jQuery"];
var external_jQuery_default = /*#__PURE__*/__webpack_require__.n(external_jQuery_namespaceObject);
;// CONCATENATED MODULE: ./src/blocks/helpers/init-css-generators.js



var isSavingCSS = false;
var isSavingWidgetsCSS = false;
/* harmony default export */ const init_css_generators = (function () {
  var _window, _wp;

  (0,external_wp_data_namespaceObject.subscribe)(function () {
    if ((0,external_wp_data_namespaceObject.select)('core/editor')) {
      var _select = (0,external_wp_data_namespaceObject.select)('core/editor'),
          isSavingPost = _select.isSavingPost,
          isAutosavingPost = _select.isAutosavingPost,
          isSavingNonPostEntityChanges = _select.isSavingNonPostEntityChanges;

      if ((isSavingNonPostEntityChanges && isSavingNonPostEntityChanges() || isSavingPost()) && !isAutosavingPost() && !isSavingCSS) {
        isSavingCSS = true;
        save_frontend_css()["finally"](function () {
          isSavingCSS = false;
        });
      }
    }

    external_jQuery_default()('.edit-widgets-header__actions > .components-button').on('click', function () {
      if (!isSavingWidgetsCSS) {
        isSavingWidgetsCSS = true;
        save_frontend_css(true)["finally"](function () {
          isSavingWidgetsCSS = false;
        });
      }
    });
  });

  if ('customize' === ((_window = window) === null || _window === void 0 ? void 0 : _window.pagenow) && (_wp = wp) !== null && _wp !== void 0 && _wp.customize) {
    wp.customize.bind('saved', function () {
      wp.customize.state('saving').set(true);
      save_frontend_css(true)["finally"](function () {
        wp.customize.state('saving').set(false);
      });
    });
  }
});
;// CONCATENATED MODULE: ./src/blocks/helpers/update-block-category-icon.js

/* harmony default export */ const update_block_category_icon = (function () {
  (0,external_wp_blocks_namespaceObject.updateCategory)('blockart', {
    icon: /*#__PURE__*/React.createElement("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 24 24"
    }, /*#__PURE__*/React.createElement("path", {
      d: "M22 22H2V2h20zM3 21h18V3H3z",
      fill: "#0369fc"
    }), /*#__PURE__*/React.createElement("path", {
      d: "M13.46 10l-1.39-5-1.39 5zm.92 3H9.77l-1 4.46V19h6.4v-1.52z",
      fill: "#005cff",
      fillRule: "evenodd"
    }))
  });
});
;// CONCATENATED MODULE: external ["wp","domReady"]
const external_wp_domReady_namespaceObject = window["wp"]["domReady"];
var external_wp_domReady_default = /*#__PURE__*/__webpack_require__.n(external_wp_domReady_namespaceObject);
;// CONCATENATED MODULE: ./src/blocks/helpers/add-toolbar-library-button.js







var ImportButton = function ImportButton() {
  return /*#__PURE__*/React.createElement(external_wp_components_namespaceObject.ToolbarButton, {
    className: "blockart-library-button",
    icon: /*#__PURE__*/React.createElement("svg", {
      width: 20,
      height: 20,
      xmlns: "http://www.w3.org/2000/svg",
      viewBox: "0 0 24 24"
    }, /*#__PURE__*/React.createElement("path", {
      d: "M22 22H2V2h20zM3 21h18V3H3z",
      fill: "#fff"
    }), /*#__PURE__*/React.createElement("path", {
      d: "M13.46 10l-1.39-5-1.39 5zm.92 3H9.77l-1 4.46V19h6.4v-1.52z",
      fill: "#fff",
      fillRule: "evenodd"
    })),
    onClick: function onClick() {
      var _dispatch = (0,external_wp_data_namespaceObject.dispatch)('core/block-editor'),
          insertBlocks = _dispatch.insertBlocks;

      insertBlocks((0,external_wp_blocks_namespaceObject.createBlock)('blockart/section', {
        hasModal: true,
        modalOnly: true
      }));
    }
  }, (0,external_wp_i18n_namespaceObject.__)('BlockArt Library', 'blockart'));
};

/* harmony default export */ const add_toolbar_library_button = (function () {
  external_wp_domReady_default()(function () {
    if ('widgets' === window.pagenow || 'customize' === window.pagenow) return;
    var timeout = null;
    var unsubscribe = (0,external_wp_data_namespaceObject.subscribe)(function () {
      var toolbar = document.querySelector('.edit-post-header-toolbar');
      if (!toolbar) return;
      var wrapper = document.createElement('div');
      wrapper.classList.add('blockart-library-button-wrapper');

      if (!toolbar.querySelector('.blockart-library-button-wrapper')) {
        (0,external_wp_element_namespaceObject.render)( /*#__PURE__*/React.createElement(ImportButton, null), wrapper);
        toolbar.appendChild(wrapper);
      }

      if (timeout) clearTimeout(timeout);
      timeout = setTimeout(function () {
        if (document.querySelector('.blockart-import-button-wrapper')) {
          unsubscribe();
        }
      }, 0);
    });
  });
});
;// CONCATENATED MODULE: ./src/blocks/helpers/update-block-attributes.js
function update_block_attributes_createForOfIteratorHelper(o, allowArrayLike) { var it = typeof Symbol !== "undefined" && o[Symbol.iterator] || o["@@iterator"]; if (!it) { if (Array.isArray(o) || (it = update_block_attributes_unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === "number") { if (it) o = it; var i = 0; var F = function F() {}; return { s: F, n: function n() { if (i >= o.length) return { done: true }; return { done: false, value: o[i++] }; }, e: function e(_e) { throw _e; }, f: F }; } throw new TypeError("Invalid attempt to iterate non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); } var normalCompletion = true, didErr = false, err; return { s: function s() { it = it.call(o); }, n: function n() { var step = it.next(); normalCompletion = step.done; return step; }, e: function e(_e2) { didErr = true; err = _e2; }, f: function f() { try { if (!normalCompletion && it["return"] != null) it["return"](); } finally { if (didErr) throw err; } } }; }

function update_block_attributes_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return update_block_attributes_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return update_block_attributes_arrayLikeToArray(o, minLen); }

function update_block_attributes_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }


var BACKGROUND_ATTRIBUTE_KEYS = ['background', 'hoverBackground', 'background1', 'background2', 'hoverBackground1', 'hoverBackground2'];
/* harmony default export */ const update_block_attributes = (function () {
  (0,external_wp_hooks_namespaceObject.addFilter)('blocks.getBlockAttributes', 'blockart/update-background-attribute', function (attrs, block) {
    if (block.name.startsWith('blockart/')) {
      var _iterator = update_block_attributes_createForOfIteratorHelper(BACKGROUND_ATTRIBUTE_KEYS),
          _step;

      try {
        for (_iterator.s(); !(_step = _iterator.n()).done;) {
          var _attrs$key, _attrs$key$image, _attrs$key$image$imag;

          var key = _step.value;

          if (attrs !== null && attrs !== void 0 && (_attrs$key = attrs[key]) !== null && _attrs$key !== void 0 && (_attrs$key$image = _attrs$key.image) !== null && _attrs$key$image !== void 0 && (_attrs$key$image$imag = _attrs$key$image.image) !== null && _attrs$key$image$imag !== void 0 && _attrs$key$image$imag.type) {
            var _attrs$key$image$imag2, _attrs$key$image$imag3, _attrs$key$image$imag4, _attrs$key$image$imag5, _attrs$key$image$imag6, _attrs$key$image$imag7;

            attrs[key].image.image.url = ((_attrs$key$image$imag2 = (_attrs$key$image$imag3 = attrs[key].image.image) === null || _attrs$key$image$imag3 === void 0 ? void 0 : _attrs$key$image$imag3.local) !== null && _attrs$key$image$imag2 !== void 0 ? _attrs$key$image$imag2 : '') || ((_attrs$key$image$imag4 = (_attrs$key$image$imag5 = attrs[key].image.image) === null || _attrs$key$image$imag5 === void 0 ? void 0 : _attrs$key$image$imag5.external) !== null && _attrs$key$image$imag4 !== void 0 ? _attrs$key$image$imag4 : '');
            delete attrs[key].image.image.type;
            (_attrs$key$image$imag6 = attrs[key].image.image) === null || _attrs$key$image$imag6 === void 0 ? true : delete _attrs$key$image$imag6.local;
            (_attrs$key$image$imag7 = attrs[key].image.image) === null || _attrs$key$image$imag7 === void 0 ? true : delete _attrs$key$image$imag7.external;
          }
        }
      } catch (err) {
        _iterator.e(err);
      } finally {
        _iterator.f();
      }
    }

    return attrs;
  });
});
;// CONCATENATED MODULE: ./src/blocks/helpers/index.js





;// CONCATENATED MODULE: ./src/blocks/index.js


 // Register blocks.

section_column();
blocks_section();
blocks_heading();
blocks_paragraph();
buttons_button();
blocks_buttons();
blocks_image();
blocks_spacing();
update_block_attributes();
add_toolbar_library_button(); // Add toolbar library button.

update_block_category_icon(); // Update BlockArt category icon.

init_css_generators(); //  Initialize CSS generators for blocks.

auto_recover_blocks(); // Auto recover blocks in widget/customize screen.

/***/ }),

/***/ 4184:
/***/ ((module, exports) => {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;/*!
  Copyright (c) 2018 Jed Watson.
  Licensed under the MIT License (MIT), see
  http://jedwatson.github.io/classnames
*/
/* global define */

(function () {
	'use strict';

	var hasOwn = {}.hasOwnProperty;

	function classNames() {
		var classes = [];

		for (var i = 0; i < arguments.length; i++) {
			var arg = arguments[i];
			if (!arg) continue;

			var argType = typeof arg;

			if (argType === 'string' || argType === 'number') {
				classes.push(arg);
			} else if (Array.isArray(arg)) {
				if (arg.length) {
					var inner = classNames.apply(null, arg);
					if (inner) {
						classes.push(inner);
					}
				}
			} else if (argType === 'object') {
				if (arg.toString === Object.prototype.toString) {
					for (var key in arg) {
						if (hasOwn.call(arg, key) && arg[key]) {
							classes.push(key);
						}
					}
				} else {
					classes.push(arg.toString());
				}
			}
		}

		return classes.join(' ');
	}

	if ( true && module.exports) {
		classNames.default = classNames;
		module.exports = classNames;
	} else if (true) {
		// register as 'classnames', consistent with npm package name
		!(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
			return classNames;
		}).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
		__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
	} else {}
}());


/***/ }),

/***/ 8552:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(852),
    root = __webpack_require__(5639);

/* Built-in method references that are verified to be native. */
var DataView = getNative(root, 'DataView');

module.exports = DataView;


/***/ }),

/***/ 1989:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var hashClear = __webpack_require__(1789),
    hashDelete = __webpack_require__(401),
    hashGet = __webpack_require__(7667),
    hashHas = __webpack_require__(1327),
    hashSet = __webpack_require__(1866);

/**
 * Creates a hash object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Hash(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `Hash`.
Hash.prototype.clear = hashClear;
Hash.prototype['delete'] = hashDelete;
Hash.prototype.get = hashGet;
Hash.prototype.has = hashHas;
Hash.prototype.set = hashSet;

module.exports = Hash;


/***/ }),

/***/ 8407:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var listCacheClear = __webpack_require__(7040),
    listCacheDelete = __webpack_require__(4125),
    listCacheGet = __webpack_require__(2117),
    listCacheHas = __webpack_require__(7518),
    listCacheSet = __webpack_require__(4705);

/**
 * Creates an list cache object.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function ListCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `ListCache`.
ListCache.prototype.clear = listCacheClear;
ListCache.prototype['delete'] = listCacheDelete;
ListCache.prototype.get = listCacheGet;
ListCache.prototype.has = listCacheHas;
ListCache.prototype.set = listCacheSet;

module.exports = ListCache;


/***/ }),

/***/ 7071:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(852),
    root = __webpack_require__(5639);

/* Built-in method references that are verified to be native. */
var Map = getNative(root, 'Map');

module.exports = Map;


/***/ }),

/***/ 3369:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var mapCacheClear = __webpack_require__(4785),
    mapCacheDelete = __webpack_require__(1285),
    mapCacheGet = __webpack_require__(6000),
    mapCacheHas = __webpack_require__(9916),
    mapCacheSet = __webpack_require__(5265);

/**
 * Creates a map cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function MapCache(entries) {
  var index = -1,
      length = entries == null ? 0 : entries.length;

  this.clear();
  while (++index < length) {
    var entry = entries[index];
    this.set(entry[0], entry[1]);
  }
}

// Add methods to `MapCache`.
MapCache.prototype.clear = mapCacheClear;
MapCache.prototype['delete'] = mapCacheDelete;
MapCache.prototype.get = mapCacheGet;
MapCache.prototype.has = mapCacheHas;
MapCache.prototype.set = mapCacheSet;

module.exports = MapCache;


/***/ }),

/***/ 3818:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(852),
    root = __webpack_require__(5639);

/* Built-in method references that are verified to be native. */
var Promise = getNative(root, 'Promise');

module.exports = Promise;


/***/ }),

/***/ 8525:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(852),
    root = __webpack_require__(5639);

/* Built-in method references that are verified to be native. */
var Set = getNative(root, 'Set');

module.exports = Set;


/***/ }),

/***/ 8668:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var MapCache = __webpack_require__(3369),
    setCacheAdd = __webpack_require__(619),
    setCacheHas = __webpack_require__(2385);

/**
 *
 * Creates an array cache object to store unique values.
 *
 * @private
 * @constructor
 * @param {Array} [values] The values to cache.
 */
function SetCache(values) {
  var index = -1,
      length = values == null ? 0 : values.length;

  this.__data__ = new MapCache;
  while (++index < length) {
    this.add(values[index]);
  }
}

// Add methods to `SetCache`.
SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
SetCache.prototype.has = setCacheHas;

module.exports = SetCache;


/***/ }),

/***/ 6384:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ListCache = __webpack_require__(8407),
    stackClear = __webpack_require__(7465),
    stackDelete = __webpack_require__(3779),
    stackGet = __webpack_require__(7599),
    stackHas = __webpack_require__(4758),
    stackSet = __webpack_require__(4309);

/**
 * Creates a stack cache object to store key-value pairs.
 *
 * @private
 * @constructor
 * @param {Array} [entries] The key-value pairs to cache.
 */
function Stack(entries) {
  var data = this.__data__ = new ListCache(entries);
  this.size = data.size;
}

// Add methods to `Stack`.
Stack.prototype.clear = stackClear;
Stack.prototype['delete'] = stackDelete;
Stack.prototype.get = stackGet;
Stack.prototype.has = stackHas;
Stack.prototype.set = stackSet;

module.exports = Stack;


/***/ }),

/***/ 2705:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(5639);

/** Built-in value references. */
var Symbol = root.Symbol;

module.exports = Symbol;


/***/ }),

/***/ 1149:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(5639);

/** Built-in value references. */
var Uint8Array = root.Uint8Array;

module.exports = Uint8Array;


/***/ }),

/***/ 577:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(852),
    root = __webpack_require__(5639);

/* Built-in method references that are verified to be native. */
var WeakMap = getNative(root, 'WeakMap');

module.exports = WeakMap;


/***/ }),

/***/ 4963:
/***/ ((module) => {

/**
 * A specialized version of `_.filter` for arrays without support for
 * iteratee shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {Array} Returns the new filtered array.
 */
function arrayFilter(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length,
      resIndex = 0,
      result = [];

  while (++index < length) {
    var value = array[index];
    if (predicate(value, index, array)) {
      result[resIndex++] = value;
    }
  }
  return result;
}

module.exports = arrayFilter;


/***/ }),

/***/ 4636:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseTimes = __webpack_require__(2545),
    isArguments = __webpack_require__(5694),
    isArray = __webpack_require__(1469),
    isBuffer = __webpack_require__(4144),
    isIndex = __webpack_require__(5776),
    isTypedArray = __webpack_require__(6719);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */
function arrayLikeKeys(value, inherited) {
  var isArr = isArray(value),
      isArg = !isArr && isArguments(value),
      isBuff = !isArr && !isArg && isBuffer(value),
      isType = !isArr && !isArg && !isBuff && isTypedArray(value),
      skipIndexes = isArr || isArg || isBuff || isType,
      result = skipIndexes ? baseTimes(value.length, String) : [],
      length = result.length;

  for (var key in value) {
    if ((inherited || hasOwnProperty.call(value, key)) &&
        !(skipIndexes && (
           // Safari 9 has enumerable `arguments.length` in strict mode.
           key == 'length' ||
           // Node.js 0.10 has enumerable non-index properties on buffers.
           (isBuff && (key == 'offset' || key == 'parent')) ||
           // PhantomJS 2 has enumerable non-index properties on typed arrays.
           (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
           // Skip index properties.
           isIndex(key, length)
        ))) {
      result.push(key);
    }
  }
  return result;
}

module.exports = arrayLikeKeys;


/***/ }),

/***/ 2488:
/***/ ((module) => {

/**
 * Appends the elements of `values` to `array`.
 *
 * @private
 * @param {Array} array The array to modify.
 * @param {Array} values The values to append.
 * @returns {Array} Returns `array`.
 */
function arrayPush(array, values) {
  var index = -1,
      length = values.length,
      offset = array.length;

  while (++index < length) {
    array[offset + index] = values[index];
  }
  return array;
}

module.exports = arrayPush;


/***/ }),

/***/ 2908:
/***/ ((module) => {

/**
 * A specialized version of `_.some` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} predicate The function invoked per iteration.
 * @returns {boolean} Returns `true` if any element passes the predicate check,
 *  else `false`.
 */
function arraySome(array, predicate) {
  var index = -1,
      length = array == null ? 0 : array.length;

  while (++index < length) {
    if (predicate(array[index], index, array)) {
      return true;
    }
  }
  return false;
}

module.exports = arraySome;


/***/ }),

/***/ 8470:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var eq = __webpack_require__(7813);

/**
 * Gets the index at which the `key` is found in `array` of key-value pairs.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} key The key to search for.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */
function assocIndexOf(array, key) {
  var length = array.length;
  while (length--) {
    if (eq(array[length][0], key)) {
      return length;
    }
  }
  return -1;
}

module.exports = assocIndexOf;


/***/ }),

/***/ 8866:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayPush = __webpack_require__(2488),
    isArray = __webpack_require__(1469);

/**
 * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
 * `keysFunc` and `symbolsFunc` to get the enumerable property names and
 * symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Function} keysFunc The function to get the keys of `object`.
 * @param {Function} symbolsFunc The function to get the symbols of `object`.
 * @returns {Array} Returns the array of property names and symbols.
 */
function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  var result = keysFunc(object);
  return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
}

module.exports = baseGetAllKeys;


/***/ }),

/***/ 4239:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(2705),
    getRawTag = __webpack_require__(9607),
    objectToString = __webpack_require__(2333);

/** `Object#toString` result references. */
var nullTag = '[object Null]',
    undefinedTag = '[object Undefined]';

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * The base implementation of `getTag` without fallbacks for buggy environments.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
function baseGetTag(value) {
  if (value == null) {
    return value === undefined ? undefinedTag : nullTag;
  }
  return (symToStringTag && symToStringTag in Object(value))
    ? getRawTag(value)
    : objectToString(value);
}

module.exports = baseGetTag;


/***/ }),

/***/ 9454:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(4239),
    isObjectLike = __webpack_require__(7005);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]';

/**
 * The base implementation of `_.isArguments`.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 */
function baseIsArguments(value) {
  return isObjectLike(value) && baseGetTag(value) == argsTag;
}

module.exports = baseIsArguments;


/***/ }),

/***/ 939:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsEqualDeep = __webpack_require__(2492),
    isObjectLike = __webpack_require__(7005);

/**
 * The base implementation of `_.isEqual` which supports partial comparisons
 * and tracks traversed objects.
 *
 * @private
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @param {boolean} bitmask The bitmask flags.
 *  1 - Unordered comparison
 *  2 - Partial comparison
 * @param {Function} [customizer] The function to customize comparisons.
 * @param {Object} [stack] Tracks traversed `value` and `other` objects.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 */
function baseIsEqual(value, other, bitmask, customizer, stack) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
    return value !== value && other !== other;
  }
  return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
}

module.exports = baseIsEqual;


/***/ }),

/***/ 2492:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Stack = __webpack_require__(6384),
    equalArrays = __webpack_require__(7114),
    equalByTag = __webpack_require__(8351),
    equalObjects = __webpack_require__(6096),
    getTag = __webpack_require__(4160),
    isArray = __webpack_require__(1469),
    isBuffer = __webpack_require__(4144),
    isTypedArray = __webpack_require__(6719);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    objectTag = '[object Object]';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqual` for arrays and objects which performs
 * deep comparisons and tracks traversed objects enabling objects with circular
 * references to be compared.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} [stack] Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  var objIsArr = isArray(object),
      othIsArr = isArray(other),
      objTag = objIsArr ? arrayTag : getTag(object),
      othTag = othIsArr ? arrayTag : getTag(other);

  objTag = objTag == argsTag ? objectTag : objTag;
  othTag = othTag == argsTag ? objectTag : othTag;

  var objIsObj = objTag == objectTag,
      othIsObj = othTag == objectTag,
      isSameTag = objTag == othTag;

  if (isSameTag && isBuffer(object)) {
    if (!isBuffer(other)) {
      return false;
    }
    objIsArr = true;
    objIsObj = false;
  }
  if (isSameTag && !objIsObj) {
    stack || (stack = new Stack);
    return (objIsArr || isTypedArray(object))
      ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
      : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  }
  if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
    var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
        othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

    if (objIsWrapped || othIsWrapped) {
      var objUnwrapped = objIsWrapped ? object.value() : object,
          othUnwrapped = othIsWrapped ? other.value() : other;

      stack || (stack = new Stack);
      return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
    }
  }
  if (!isSameTag) {
    return false;
  }
  stack || (stack = new Stack);
  return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
}

module.exports = baseIsEqualDeep;


/***/ }),

/***/ 8458:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isFunction = __webpack_require__(3560),
    isMasked = __webpack_require__(5346),
    isObject = __webpack_require__(3218),
    toSource = __webpack_require__(346);

/**
 * Used to match `RegExp`
 * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
 */
var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

/** Used to detect host constructors (Safari). */
var reIsHostCtor = /^\[object .+?Constructor\]$/;

/** Used for built-in method references. */
var funcProto = Function.prototype,
    objectProto = Object.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Used to detect if a method is native. */
var reIsNative = RegExp('^' +
  funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
);

/**
 * The base implementation of `_.isNative` without bad shim checks.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a native function,
 *  else `false`.
 */
function baseIsNative(value) {
  if (!isObject(value) || isMasked(value)) {
    return false;
  }
  var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  return pattern.test(toSource(value));
}

module.exports = baseIsNative;


/***/ }),

/***/ 8749:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(4239),
    isLength = __webpack_require__(1780),
    isObjectLike = __webpack_require__(7005);

/** `Object#toString` result references. */
var argsTag = '[object Arguments]',
    arrayTag = '[object Array]',
    boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    funcTag = '[object Function]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    objectTag = '[object Object]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    weakMapTag = '[object WeakMap]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]',
    float32Tag = '[object Float32Array]',
    float64Tag = '[object Float64Array]',
    int8Tag = '[object Int8Array]',
    int16Tag = '[object Int16Array]',
    int32Tag = '[object Int32Array]',
    uint8Tag = '[object Uint8Array]',
    uint8ClampedTag = '[object Uint8ClampedArray]',
    uint16Tag = '[object Uint16Array]',
    uint32Tag = '[object Uint32Array]';

/** Used to identify `toStringTag` values of typed arrays. */
var typedArrayTags = {};
typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
typedArrayTags[uint32Tag] = true;
typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
typedArrayTags[errorTag] = typedArrayTags[funcTag] =
typedArrayTags[mapTag] = typedArrayTags[numberTag] =
typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
typedArrayTags[setTag] = typedArrayTags[stringTag] =
typedArrayTags[weakMapTag] = false;

/**
 * The base implementation of `_.isTypedArray` without Node.js optimizations.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 */
function baseIsTypedArray(value) {
  return isObjectLike(value) &&
    isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
}

module.exports = baseIsTypedArray;


/***/ }),

/***/ 280:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isPrototype = __webpack_require__(5726),
    nativeKeys = __webpack_require__(6916);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */
function baseKeys(object) {
  if (!isPrototype(object)) {
    return nativeKeys(object);
  }
  var result = [];
  for (var key in Object(object)) {
    if (hasOwnProperty.call(object, key) && key != 'constructor') {
      result.push(key);
    }
  }
  return result;
}

module.exports = baseKeys;


/***/ }),

/***/ 2545:
/***/ ((module) => {

/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */
function baseTimes(n, iteratee) {
  var index = -1,
      result = Array(n);

  while (++index < n) {
    result[index] = iteratee(index);
  }
  return result;
}

module.exports = baseTimes;


/***/ }),

/***/ 1717:
/***/ ((module) => {

/**
 * The base implementation of `_.unary` without support for storing metadata.
 *
 * @private
 * @param {Function} func The function to cap arguments for.
 * @returns {Function} Returns the new capped function.
 */
function baseUnary(func) {
  return function(value) {
    return func(value);
  };
}

module.exports = baseUnary;


/***/ }),

/***/ 4757:
/***/ ((module) => {

/**
 * Checks if a `cache` value for `key` exists.
 *
 * @private
 * @param {Object} cache The cache to query.
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function cacheHas(cache, key) {
  return cache.has(key);
}

module.exports = cacheHas;


/***/ }),

/***/ 4429:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var root = __webpack_require__(5639);

/** Used to detect overreaching core-js shims. */
var coreJsData = root['__core-js_shared__'];

module.exports = coreJsData;


/***/ }),

/***/ 7114:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var SetCache = __webpack_require__(8668),
    arraySome = __webpack_require__(2908),
    cacheHas = __webpack_require__(4757);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/**
 * A specialized version of `baseIsEqualDeep` for arrays with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Array} array The array to compare.
 * @param {Array} other The other array to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `array` and `other` objects.
 * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
 */
function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      arrLength = array.length,
      othLength = other.length;

  if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
    return false;
  }
  // Check that cyclic values are equal.
  var arrStacked = stack.get(array);
  var othStacked = stack.get(other);
  if (arrStacked && othStacked) {
    return arrStacked == other && othStacked == array;
  }
  var index = -1,
      result = true,
      seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined;

  stack.set(array, other);
  stack.set(other, array);

  // Ignore non-index properties.
  while (++index < arrLength) {
    var arrValue = array[index],
        othValue = other[index];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, arrValue, index, other, array, stack)
        : customizer(arrValue, othValue, index, array, other, stack);
    }
    if (compared !== undefined) {
      if (compared) {
        continue;
      }
      result = false;
      break;
    }
    // Recursively compare arrays (susceptible to call stack limits).
    if (seen) {
      if (!arraySome(other, function(othValue, othIndex) {
            if (!cacheHas(seen, othIndex) &&
                (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
              return seen.push(othIndex);
            }
          })) {
        result = false;
        break;
      }
    } else if (!(
          arrValue === othValue ||
            equalFunc(arrValue, othValue, bitmask, customizer, stack)
        )) {
      result = false;
      break;
    }
  }
  stack['delete'](array);
  stack['delete'](other);
  return result;
}

module.exports = equalArrays;


/***/ }),

/***/ 8351:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(2705),
    Uint8Array = __webpack_require__(1149),
    eq = __webpack_require__(7813),
    equalArrays = __webpack_require__(7114),
    mapToArray = __webpack_require__(8776),
    setToArray = __webpack_require__(1814);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1,
    COMPARE_UNORDERED_FLAG = 2;

/** `Object#toString` result references. */
var boolTag = '[object Boolean]',
    dateTag = '[object Date]',
    errorTag = '[object Error]',
    mapTag = '[object Map]',
    numberTag = '[object Number]',
    regexpTag = '[object RegExp]',
    setTag = '[object Set]',
    stringTag = '[object String]',
    symbolTag = '[object Symbol]';

var arrayBufferTag = '[object ArrayBuffer]',
    dataViewTag = '[object DataView]';

/** Used to convert symbols to primitives and strings. */
var symbolProto = Symbol ? Symbol.prototype : undefined,
    symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

/**
 * A specialized version of `baseIsEqualDeep` for comparing objects of
 * the same `toStringTag`.
 *
 * **Note:** This function only supports comparing values with tags of
 * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {string} tag The `toStringTag` of the objects to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  switch (tag) {
    case dataViewTag:
      if ((object.byteLength != other.byteLength) ||
          (object.byteOffset != other.byteOffset)) {
        return false;
      }
      object = object.buffer;
      other = other.buffer;

    case arrayBufferTag:
      if ((object.byteLength != other.byteLength) ||
          !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
        return false;
      }
      return true;

    case boolTag:
    case dateTag:
    case numberTag:
      // Coerce booleans to `1` or `0` and dates to milliseconds.
      // Invalid dates are coerced to `NaN`.
      return eq(+object, +other);

    case errorTag:
      return object.name == other.name && object.message == other.message;

    case regexpTag:
    case stringTag:
      // Coerce regexes to strings and treat strings, primitives and objects,
      // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
      // for more details.
      return object == (other + '');

    case mapTag:
      var convert = mapToArray;

    case setTag:
      var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
      convert || (convert = setToArray);

      if (object.size != other.size && !isPartial) {
        return false;
      }
      // Assume cyclic values are equal.
      var stacked = stack.get(object);
      if (stacked) {
        return stacked == other;
      }
      bitmask |= COMPARE_UNORDERED_FLAG;

      // Recursively compare objects (susceptible to call stack limits).
      stack.set(object, other);
      var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
      stack['delete'](object);
      return result;

    case symbolTag:
      if (symbolValueOf) {
        return symbolValueOf.call(object) == symbolValueOf.call(other);
      }
  }
  return false;
}

module.exports = equalByTag;


/***/ }),

/***/ 6096:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getAllKeys = __webpack_require__(8234);

/** Used to compose bitmasks for value comparisons. */
var COMPARE_PARTIAL_FLAG = 1;

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * A specialized version of `baseIsEqualDeep` for objects with support for
 * partial deep comparisons.
 *
 * @private
 * @param {Object} object The object to compare.
 * @param {Object} other The other object to compare.
 * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
 * @param {Function} customizer The function to customize comparisons.
 * @param {Function} equalFunc The function to determine equivalents of values.
 * @param {Object} stack Tracks traversed `object` and `other` objects.
 * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
 */
function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
      objProps = getAllKeys(object),
      objLength = objProps.length,
      othProps = getAllKeys(other),
      othLength = othProps.length;

  if (objLength != othLength && !isPartial) {
    return false;
  }
  var index = objLength;
  while (index--) {
    var key = objProps[index];
    if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
      return false;
    }
  }
  // Check that cyclic values are equal.
  var objStacked = stack.get(object);
  var othStacked = stack.get(other);
  if (objStacked && othStacked) {
    return objStacked == other && othStacked == object;
  }
  var result = true;
  stack.set(object, other);
  stack.set(other, object);

  var skipCtor = isPartial;
  while (++index < objLength) {
    key = objProps[index];
    var objValue = object[key],
        othValue = other[key];

    if (customizer) {
      var compared = isPartial
        ? customizer(othValue, objValue, key, other, object, stack)
        : customizer(objValue, othValue, key, object, other, stack);
    }
    // Recursively compare objects (susceptible to call stack limits).
    if (!(compared === undefined
          ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
          : compared
        )) {
      result = false;
      break;
    }
    skipCtor || (skipCtor = key == 'constructor');
  }
  if (result && !skipCtor) {
    var objCtor = object.constructor,
        othCtor = other.constructor;

    // Non `Object` object instances with different constructors are not equal.
    if (objCtor != othCtor &&
        ('constructor' in object && 'constructor' in other) &&
        !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
          typeof othCtor == 'function' && othCtor instanceof othCtor)) {
      result = false;
    }
  }
  stack['delete'](object);
  stack['delete'](other);
  return result;
}

module.exports = equalObjects;


/***/ }),

/***/ 1957:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

/** Detect free variable `global` from Node.js. */
var freeGlobal = typeof __webpack_require__.g == 'object' && __webpack_require__.g && __webpack_require__.g.Object === Object && __webpack_require__.g;

module.exports = freeGlobal;


/***/ }),

/***/ 8234:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetAllKeys = __webpack_require__(8866),
    getSymbols = __webpack_require__(9551),
    keys = __webpack_require__(3674);

/**
 * Creates an array of own enumerable property names and symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names and symbols.
 */
function getAllKeys(object) {
  return baseGetAllKeys(object, keys, getSymbols);
}

module.exports = getAllKeys;


/***/ }),

/***/ 5050:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isKeyable = __webpack_require__(7019);

/**
 * Gets the data for `map`.
 *
 * @private
 * @param {Object} map The map to query.
 * @param {string} key The reference key.
 * @returns {*} Returns the map data.
 */
function getMapData(map, key) {
  var data = map.__data__;
  return isKeyable(key)
    ? data[typeof key == 'string' ? 'string' : 'hash']
    : data.map;
}

module.exports = getMapData;


/***/ }),

/***/ 852:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsNative = __webpack_require__(8458),
    getValue = __webpack_require__(7801);

/**
 * Gets the native function at `key` of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {string} key The key of the method to get.
 * @returns {*} Returns the function if it's native, else `undefined`.
 */
function getNative(object, key) {
  var value = getValue(object, key);
  return baseIsNative(value) ? value : undefined;
}

module.exports = getNative;


/***/ }),

/***/ 9607:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Symbol = __webpack_require__(2705);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/** Built-in value references. */
var symToStringTag = Symbol ? Symbol.toStringTag : undefined;

/**
 * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the raw `toStringTag`.
 */
function getRawTag(value) {
  var isOwn = hasOwnProperty.call(value, symToStringTag),
      tag = value[symToStringTag];

  try {
    value[symToStringTag] = undefined;
    var unmasked = true;
  } catch (e) {}

  var result = nativeObjectToString.call(value);
  if (unmasked) {
    if (isOwn) {
      value[symToStringTag] = tag;
    } else {
      delete value[symToStringTag];
    }
  }
  return result;
}

module.exports = getRawTag;


/***/ }),

/***/ 9551:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayFilter = __webpack_require__(4963),
    stubArray = __webpack_require__(479);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeGetSymbols = Object.getOwnPropertySymbols;

/**
 * Creates an array of the own enumerable symbols of `object`.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of symbols.
 */
var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  if (object == null) {
    return [];
  }
  object = Object(object);
  return arrayFilter(nativeGetSymbols(object), function(symbol) {
    return propertyIsEnumerable.call(object, symbol);
  });
};

module.exports = getSymbols;


/***/ }),

/***/ 4160:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var DataView = __webpack_require__(8552),
    Map = __webpack_require__(7071),
    Promise = __webpack_require__(3818),
    Set = __webpack_require__(8525),
    WeakMap = __webpack_require__(577),
    baseGetTag = __webpack_require__(4239),
    toSource = __webpack_require__(346);

/** `Object#toString` result references. */
var mapTag = '[object Map]',
    objectTag = '[object Object]',
    promiseTag = '[object Promise]',
    setTag = '[object Set]',
    weakMapTag = '[object WeakMap]';

var dataViewTag = '[object DataView]';

/** Used to detect maps, sets, and weakmaps. */
var dataViewCtorString = toSource(DataView),
    mapCtorString = toSource(Map),
    promiseCtorString = toSource(Promise),
    setCtorString = toSource(Set),
    weakMapCtorString = toSource(WeakMap);

/**
 * Gets the `toStringTag` of `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @returns {string} Returns the `toStringTag`.
 */
var getTag = baseGetTag;

// Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
    (Map && getTag(new Map) != mapTag) ||
    (Promise && getTag(Promise.resolve()) != promiseTag) ||
    (Set && getTag(new Set) != setTag) ||
    (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  getTag = function(value) {
    var result = baseGetTag(value),
        Ctor = result == objectTag ? value.constructor : undefined,
        ctorString = Ctor ? toSource(Ctor) : '';

    if (ctorString) {
      switch (ctorString) {
        case dataViewCtorString: return dataViewTag;
        case mapCtorString: return mapTag;
        case promiseCtorString: return promiseTag;
        case setCtorString: return setTag;
        case weakMapCtorString: return weakMapTag;
      }
    }
    return result;
  };
}

module.exports = getTag;


/***/ }),

/***/ 7801:
/***/ ((module) => {

/**
 * Gets the value at `key` of `object`.
 *
 * @private
 * @param {Object} [object] The object to query.
 * @param {string} key The key of the property to get.
 * @returns {*} Returns the property value.
 */
function getValue(object, key) {
  return object == null ? undefined : object[key];
}

module.exports = getValue;


/***/ }),

/***/ 1789:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(4536);

/**
 * Removes all key-value entries from the hash.
 *
 * @private
 * @name clear
 * @memberOf Hash
 */
function hashClear() {
  this.__data__ = nativeCreate ? nativeCreate(null) : {};
  this.size = 0;
}

module.exports = hashClear;


/***/ }),

/***/ 401:
/***/ ((module) => {

/**
 * Removes `key` and its value from the hash.
 *
 * @private
 * @name delete
 * @memberOf Hash
 * @param {Object} hash The hash to modify.
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function hashDelete(key) {
  var result = this.has(key) && delete this.__data__[key];
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = hashDelete;


/***/ }),

/***/ 7667:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(4536);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Gets the hash value for `key`.
 *
 * @private
 * @name get
 * @memberOf Hash
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function hashGet(key) {
  var data = this.__data__;
  if (nativeCreate) {
    var result = data[key];
    return result === HASH_UNDEFINED ? undefined : result;
  }
  return hasOwnProperty.call(data, key) ? data[key] : undefined;
}

module.exports = hashGet;


/***/ }),

/***/ 1327:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(4536);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/**
 * Checks if a hash value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Hash
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function hashHas(key) {
  var data = this.__data__;
  return nativeCreate ? (data[key] !== undefined) : hasOwnProperty.call(data, key);
}

module.exports = hashHas;


/***/ }),

/***/ 1866:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var nativeCreate = __webpack_require__(4536);

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Sets the hash `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Hash
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the hash instance.
 */
function hashSet(key, value) {
  var data = this.__data__;
  this.size += this.has(key) ? 0 : 1;
  data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
  return this;
}

module.exports = hashSet;


/***/ }),

/***/ 5776:
/***/ ((module) => {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/** Used to detect unsigned integer values. */
var reIsUint = /^(?:0|[1-9]\d*)$/;

/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */
function isIndex(value, length) {
  var type = typeof value;
  length = length == null ? MAX_SAFE_INTEGER : length;

  return !!length &&
    (type == 'number' ||
      (type != 'symbol' && reIsUint.test(value))) &&
        (value > -1 && value % 1 == 0 && value < length);
}

module.exports = isIndex;


/***/ }),

/***/ 7019:
/***/ ((module) => {

/**
 * Checks if `value` is suitable for use as unique object key.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
 */
function isKeyable(value) {
  var type = typeof value;
  return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
    ? (value !== '__proto__')
    : (value === null);
}

module.exports = isKeyable;


/***/ }),

/***/ 5346:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var coreJsData = __webpack_require__(4429);

/** Used to detect methods masquerading as native. */
var maskSrcKey = (function() {
  var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  return uid ? ('Symbol(src)_1.' + uid) : '';
}());

/**
 * Checks if `func` has its source masked.
 *
 * @private
 * @param {Function} func The function to check.
 * @returns {boolean} Returns `true` if `func` is masked, else `false`.
 */
function isMasked(func) {
  return !!maskSrcKey && (maskSrcKey in func);
}

module.exports = isMasked;


/***/ }),

/***/ 5726:
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */
function isPrototype(value) {
  var Ctor = value && value.constructor,
      proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  return value === proto;
}

module.exports = isPrototype;


/***/ }),

/***/ 7040:
/***/ ((module) => {

/**
 * Removes all key-value entries from the list cache.
 *
 * @private
 * @name clear
 * @memberOf ListCache
 */
function listCacheClear() {
  this.__data__ = [];
  this.size = 0;
}

module.exports = listCacheClear;


/***/ }),

/***/ 4125:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(8470);

/** Used for built-in method references. */
var arrayProto = Array.prototype;

/** Built-in value references. */
var splice = arrayProto.splice;

/**
 * Removes `key` and its value from the list cache.
 *
 * @private
 * @name delete
 * @memberOf ListCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function listCacheDelete(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    return false;
  }
  var lastIndex = data.length - 1;
  if (index == lastIndex) {
    data.pop();
  } else {
    splice.call(data, index, 1);
  }
  --this.size;
  return true;
}

module.exports = listCacheDelete;


/***/ }),

/***/ 2117:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(8470);

/**
 * Gets the list cache value for `key`.
 *
 * @private
 * @name get
 * @memberOf ListCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function listCacheGet(key) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  return index < 0 ? undefined : data[index][1];
}

module.exports = listCacheGet;


/***/ }),

/***/ 7518:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(8470);

/**
 * Checks if a list cache value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf ListCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function listCacheHas(key) {
  return assocIndexOf(this.__data__, key) > -1;
}

module.exports = listCacheHas;


/***/ }),

/***/ 4705:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var assocIndexOf = __webpack_require__(8470);

/**
 * Sets the list cache `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf ListCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the list cache instance.
 */
function listCacheSet(key, value) {
  var data = this.__data__,
      index = assocIndexOf(data, key);

  if (index < 0) {
    ++this.size;
    data.push([key, value]);
  } else {
    data[index][1] = value;
  }
  return this;
}

module.exports = listCacheSet;


/***/ }),

/***/ 4785:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var Hash = __webpack_require__(1989),
    ListCache = __webpack_require__(8407),
    Map = __webpack_require__(7071);

/**
 * Removes all key-value entries from the map.
 *
 * @private
 * @name clear
 * @memberOf MapCache
 */
function mapCacheClear() {
  this.size = 0;
  this.__data__ = {
    'hash': new Hash,
    'map': new (Map || ListCache),
    'string': new Hash
  };
}

module.exports = mapCacheClear;


/***/ }),

/***/ 1285:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(5050);

/**
 * Removes `key` and its value from the map.
 *
 * @private
 * @name delete
 * @memberOf MapCache
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function mapCacheDelete(key) {
  var result = getMapData(this, key)['delete'](key);
  this.size -= result ? 1 : 0;
  return result;
}

module.exports = mapCacheDelete;


/***/ }),

/***/ 6000:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(5050);

/**
 * Gets the map value for `key`.
 *
 * @private
 * @name get
 * @memberOf MapCache
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function mapCacheGet(key) {
  return getMapData(this, key).get(key);
}

module.exports = mapCacheGet;


/***/ }),

/***/ 9916:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(5050);

/**
 * Checks if a map value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf MapCache
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function mapCacheHas(key) {
  return getMapData(this, key).has(key);
}

module.exports = mapCacheHas;


/***/ }),

/***/ 5265:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getMapData = __webpack_require__(5050);

/**
 * Sets the map `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf MapCache
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the map cache instance.
 */
function mapCacheSet(key, value) {
  var data = getMapData(this, key),
      size = data.size;

  data.set(key, value);
  this.size += data.size == size ? 0 : 1;
  return this;
}

module.exports = mapCacheSet;


/***/ }),

/***/ 8776:
/***/ ((module) => {

/**
 * Converts `map` to its key-value pairs.
 *
 * @private
 * @param {Object} map The map to convert.
 * @returns {Array} Returns the key-value pairs.
 */
function mapToArray(map) {
  var index = -1,
      result = Array(map.size);

  map.forEach(function(value, key) {
    result[++index] = [key, value];
  });
  return result;
}

module.exports = mapToArray;


/***/ }),

/***/ 4536:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var getNative = __webpack_require__(852);

/* Built-in method references that are verified to be native. */
var nativeCreate = getNative(Object, 'create');

module.exports = nativeCreate;


/***/ }),

/***/ 6916:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var overArg = __webpack_require__(5569);

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeKeys = overArg(Object.keys, Object);

module.exports = nativeKeys;


/***/ }),

/***/ 1167:
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
var freeGlobal = __webpack_require__(1957);

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Detect free variable `process` from Node.js. */
var freeProcess = moduleExports && freeGlobal.process;

/** Used to access faster Node.js helpers. */
var nodeUtil = (function() {
  try {
    // Use `util.types` for Node.js 10+.
    var types = freeModule && freeModule.require && freeModule.require('util').types;

    if (types) {
      return types;
    }

    // Legacy `process.binding('util')` for Node.js < 10.
    return freeProcess && freeProcess.binding && freeProcess.binding('util');
  } catch (e) {}
}());

module.exports = nodeUtil;


/***/ }),

/***/ 2333:
/***/ ((module) => {

/** Used for built-in method references. */
var objectProto = Object.prototype;

/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */
var nativeObjectToString = objectProto.toString;

/**
 * Converts `value` to a string using `Object.prototype.toString`.
 *
 * @private
 * @param {*} value The value to convert.
 * @returns {string} Returns the converted string.
 */
function objectToString(value) {
  return nativeObjectToString.call(value);
}

module.exports = objectToString;


/***/ }),

/***/ 5569:
/***/ ((module) => {

/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */
function overArg(func, transform) {
  return function(arg) {
    return func(transform(arg));
  };
}

module.exports = overArg;


/***/ }),

/***/ 5639:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var freeGlobal = __webpack_require__(1957);

/** Detect free variable `self`. */
var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

/** Used as a reference to the global object. */
var root = freeGlobal || freeSelf || Function('return this')();

module.exports = root;


/***/ }),

/***/ 619:
/***/ ((module) => {

/** Used to stand-in for `undefined` hash values. */
var HASH_UNDEFINED = '__lodash_hash_undefined__';

/**
 * Adds `value` to the array cache.
 *
 * @private
 * @name add
 * @memberOf SetCache
 * @alias push
 * @param {*} value The value to cache.
 * @returns {Object} Returns the cache instance.
 */
function setCacheAdd(value) {
  this.__data__.set(value, HASH_UNDEFINED);
  return this;
}

module.exports = setCacheAdd;


/***/ }),

/***/ 2385:
/***/ ((module) => {

/**
 * Checks if `value` is in the array cache.
 *
 * @private
 * @name has
 * @memberOf SetCache
 * @param {*} value The value to search for.
 * @returns {number} Returns `true` if `value` is found, else `false`.
 */
function setCacheHas(value) {
  return this.__data__.has(value);
}

module.exports = setCacheHas;


/***/ }),

/***/ 1814:
/***/ ((module) => {

/**
 * Converts `set` to an array of its values.
 *
 * @private
 * @param {Object} set The set to convert.
 * @returns {Array} Returns the values.
 */
function setToArray(set) {
  var index = -1,
      result = Array(set.size);

  set.forEach(function(value) {
    result[++index] = value;
  });
  return result;
}

module.exports = setToArray;


/***/ }),

/***/ 7465:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ListCache = __webpack_require__(8407);

/**
 * Removes all key-value entries from the stack.
 *
 * @private
 * @name clear
 * @memberOf Stack
 */
function stackClear() {
  this.__data__ = new ListCache;
  this.size = 0;
}

module.exports = stackClear;


/***/ }),

/***/ 3779:
/***/ ((module) => {

/**
 * Removes `key` and its value from the stack.
 *
 * @private
 * @name delete
 * @memberOf Stack
 * @param {string} key The key of the value to remove.
 * @returns {boolean} Returns `true` if the entry was removed, else `false`.
 */
function stackDelete(key) {
  var data = this.__data__,
      result = data['delete'](key);

  this.size = data.size;
  return result;
}

module.exports = stackDelete;


/***/ }),

/***/ 7599:
/***/ ((module) => {

/**
 * Gets the stack value for `key`.
 *
 * @private
 * @name get
 * @memberOf Stack
 * @param {string} key The key of the value to get.
 * @returns {*} Returns the entry value.
 */
function stackGet(key) {
  return this.__data__.get(key);
}

module.exports = stackGet;


/***/ }),

/***/ 4758:
/***/ ((module) => {

/**
 * Checks if a stack value for `key` exists.
 *
 * @private
 * @name has
 * @memberOf Stack
 * @param {string} key The key of the entry to check.
 * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
 */
function stackHas(key) {
  return this.__data__.has(key);
}

module.exports = stackHas;


/***/ }),

/***/ 4309:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var ListCache = __webpack_require__(8407),
    Map = __webpack_require__(7071),
    MapCache = __webpack_require__(3369);

/** Used as the size to enable large array optimizations. */
var LARGE_ARRAY_SIZE = 200;

/**
 * Sets the stack `key` to `value`.
 *
 * @private
 * @name set
 * @memberOf Stack
 * @param {string} key The key of the value to set.
 * @param {*} value The value to set.
 * @returns {Object} Returns the stack cache instance.
 */
function stackSet(key, value) {
  var data = this.__data__;
  if (data instanceof ListCache) {
    var pairs = data.__data__;
    if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
      pairs.push([key, value]);
      this.size = ++data.size;
      return this;
    }
    data = this.__data__ = new MapCache(pairs);
  }
  data.set(key, value);
  this.size = data.size;
  return this;
}

module.exports = stackSet;


/***/ }),

/***/ 346:
/***/ ((module) => {

/** Used for built-in method references. */
var funcProto = Function.prototype;

/** Used to resolve the decompiled source of functions. */
var funcToString = funcProto.toString;

/**
 * Converts `func` to its source code.
 *
 * @private
 * @param {Function} func The function to convert.
 * @returns {string} Returns the source code.
 */
function toSource(func) {
  if (func != null) {
    try {
      return funcToString.call(func);
    } catch (e) {}
    try {
      return (func + '');
    } catch (e) {}
  }
  return '';
}

module.exports = toSource;


/***/ }),

/***/ 7813:
/***/ ((module) => {

/**
 * Performs a
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * comparison between two values to determine if they are equivalent.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.eq(object, object);
 * // => true
 *
 * _.eq(object, other);
 * // => false
 *
 * _.eq('a', 'a');
 * // => true
 *
 * _.eq('a', Object('a'));
 * // => false
 *
 * _.eq(NaN, NaN);
 * // => true
 */
function eq(value, other) {
  return value === other || (value !== value && other !== other);
}

module.exports = eq;


/***/ }),

/***/ 5694:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsArguments = __webpack_require__(9454),
    isObjectLike = __webpack_require__(7005);

/** Used for built-in method references. */
var objectProto = Object.prototype;

/** Used to check objects for own properties. */
var hasOwnProperty = objectProto.hasOwnProperty;

/** Built-in value references. */
var propertyIsEnumerable = objectProto.propertyIsEnumerable;

/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */
var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
    !propertyIsEnumerable.call(value, 'callee');
};

module.exports = isArguments;


/***/ }),

/***/ 1469:
/***/ ((module) => {

/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */
var isArray = Array.isArray;

module.exports = isArray;


/***/ }),

/***/ 8612:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var isFunction = __webpack_require__(3560),
    isLength = __webpack_require__(1780);

/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */
function isArrayLike(value) {
  return value != null && isLength(value.length) && !isFunction(value);
}

module.exports = isArrayLike;


/***/ }),

/***/ 4144:
/***/ ((module, exports, __webpack_require__) => {

/* module decorator */ module = __webpack_require__.nmd(module);
var root = __webpack_require__(5639),
    stubFalse = __webpack_require__(5062);

/** Detect free variable `exports`. */
var freeExports =  true && exports && !exports.nodeType && exports;

/** Detect free variable `module`. */
var freeModule = freeExports && "object" == 'object' && module && !module.nodeType && module;

/** Detect the popular CommonJS extension `module.exports`. */
var moduleExports = freeModule && freeModule.exports === freeExports;

/** Built-in value references. */
var Buffer = moduleExports ? root.Buffer : undefined;

/* Built-in method references for those with the same name as other `lodash` methods. */
var nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined;

/**
 * Checks if `value` is a buffer.
 *
 * @static
 * @memberOf _
 * @since 4.3.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
 * @example
 *
 * _.isBuffer(new Buffer(2));
 * // => true
 *
 * _.isBuffer(new Uint8Array(2));
 * // => false
 */
var isBuffer = nativeIsBuffer || stubFalse;

module.exports = isBuffer;


/***/ }),

/***/ 8446:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsEqual = __webpack_require__(939);

/**
 * Performs a deep comparison between two values to determine if they are
 * equivalent.
 *
 * **Note:** This method supports comparing arrays, array buffers, booleans,
 * date objects, error objects, maps, numbers, `Object` objects, regexes,
 * sets, strings, symbols, and typed arrays. `Object` objects are compared
 * by their own, not inherited, enumerable properties. Functions and DOM
 * nodes are compared by strict equality, i.e. `===`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to compare.
 * @param {*} other The other value to compare.
 * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
 * @example
 *
 * var object = { 'a': 1 };
 * var other = { 'a': 1 };
 *
 * _.isEqual(object, other);
 * // => true
 *
 * object === other;
 * // => false
 */
function isEqual(value, other) {
  return baseIsEqual(value, other);
}

module.exports = isEqual;


/***/ }),

/***/ 3560:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseGetTag = __webpack_require__(4239),
    isObject = __webpack_require__(3218);

/** `Object#toString` result references. */
var asyncTag = '[object AsyncFunction]',
    funcTag = '[object Function]',
    genTag = '[object GeneratorFunction]',
    proxyTag = '[object Proxy]';

/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */
function isFunction(value) {
  if (!isObject(value)) {
    return false;
  }
  // The use of `Object#toString` avoids issues with the `typeof` operator
  // in Safari 9 which returns 'object' for typed arrays and other constructors.
  var tag = baseGetTag(value);
  return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
}

module.exports = isFunction;


/***/ }),

/***/ 1780:
/***/ ((module) => {

/** Used as references for various `Number` constants. */
var MAX_SAFE_INTEGER = 9007199254740991;

/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */
function isLength(value) {
  return typeof value == 'number' &&
    value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}

module.exports = isLength;


/***/ }),

/***/ 3218:
/***/ ((module) => {

/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */
function isObject(value) {
  var type = typeof value;
  return value != null && (type == 'object' || type == 'function');
}

module.exports = isObject;


/***/ }),

/***/ 7005:
/***/ ((module) => {

/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */
function isObjectLike(value) {
  return value != null && typeof value == 'object';
}

module.exports = isObjectLike;


/***/ }),

/***/ 6719:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var baseIsTypedArray = __webpack_require__(8749),
    baseUnary = __webpack_require__(1717),
    nodeUtil = __webpack_require__(1167);

/* Node.js helper references. */
var nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

/**
 * Checks if `value` is classified as a typed array.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
 * @example
 *
 * _.isTypedArray(new Uint8Array);
 * // => true
 *
 * _.isTypedArray([]);
 * // => false
 */
var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

module.exports = isTypedArray;


/***/ }),

/***/ 3674:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

var arrayLikeKeys = __webpack_require__(4636),
    baseKeys = __webpack_require__(280),
    isArrayLike = __webpack_require__(8612);

/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */
function keys(object) {
  return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}

module.exports = keys;


/***/ }),

/***/ 479:
/***/ ((module) => {

/**
 * This method returns a new empty array.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {Array} Returns the new empty array.
 * @example
 *
 * var arrays = _.times(2, _.stubArray);
 *
 * console.log(arrays);
 * // => [[], []]
 *
 * console.log(arrays[0] === arrays[1]);
 * // => false
 */
function stubArray() {
  return [];
}

module.exports = stubArray;


/***/ }),

/***/ 5062:
/***/ ((module) => {

/**
 * This method returns `false`.
 *
 * @static
 * @memberOf _
 * @since 4.13.0
 * @category Util
 * @returns {boolean} Returns `false`.
 * @example
 *
 * _.times(2, _.stubFalse);
 * // => [false, false]
 */
function stubFalse() {
  return false;
}

module.exports = stubFalse;


/***/ }),

/***/ 9921:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
var __webpack_unused_export__;
/** @license React v16.13.1
 * react-is.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

var b="function"===typeof Symbol&&Symbol.for,c=b?Symbol.for("react.element"):60103,d=b?Symbol.for("react.portal"):60106,e=b?Symbol.for("react.fragment"):60107,f=b?Symbol.for("react.strict_mode"):60108,g=b?Symbol.for("react.profiler"):60114,h=b?Symbol.for("react.provider"):60109,k=b?Symbol.for("react.context"):60110,l=b?Symbol.for("react.async_mode"):60111,m=b?Symbol.for("react.concurrent_mode"):60111,n=b?Symbol.for("react.forward_ref"):60112,p=b?Symbol.for("react.suspense"):60113,q=b?
Symbol.for("react.suspense_list"):60120,r=b?Symbol.for("react.memo"):60115,t=b?Symbol.for("react.lazy"):60116,v=b?Symbol.for("react.block"):60121,w=b?Symbol.for("react.fundamental"):60117,x=b?Symbol.for("react.responder"):60118,y=b?Symbol.for("react.scope"):60119;
function z(a){if("object"===typeof a&&null!==a){var u=a.$$typeof;switch(u){case c:switch(a=a.type,a){case l:case m:case e:case g:case f:case p:return a;default:switch(a=a&&a.$$typeof,a){case k:case n:case t:case r:case h:return a;default:return u}}case d:return u}}}function A(a){return z(a)===m}__webpack_unused_export__=l;__webpack_unused_export__=m;__webpack_unused_export__=k;__webpack_unused_export__=h;__webpack_unused_export__=c;__webpack_unused_export__=n;__webpack_unused_export__=e;__webpack_unused_export__=t;__webpack_unused_export__=r;__webpack_unused_export__=d;
__webpack_unused_export__=g;__webpack_unused_export__=f;__webpack_unused_export__=p;__webpack_unused_export__=function(a){return A(a)||z(a)===l};__webpack_unused_export__=A;__webpack_unused_export__=function(a){return z(a)===k};__webpack_unused_export__=function(a){return z(a)===h};__webpack_unused_export__=function(a){return"object"===typeof a&&null!==a&&a.$$typeof===c};__webpack_unused_export__=function(a){return z(a)===n};exports.isFragment=function(a){return z(a)===e};__webpack_unused_export__=function(a){return z(a)===t};
exports.isMemo=function(a){return z(a)===r};__webpack_unused_export__=function(a){return z(a)===d};__webpack_unused_export__=function(a){return z(a)===g};__webpack_unused_export__=function(a){return z(a)===f};__webpack_unused_export__=function(a){return z(a)===p};
__webpack_unused_export__=function(a){return"string"===typeof a||"function"===typeof a||a===e||a===m||a===g||a===f||a===p||a===q||"object"===typeof a&&null!==a&&(a.$$typeof===t||a.$$typeof===r||a.$$typeof===h||a.$$typeof===k||a.$$typeof===n||a.$$typeof===w||a.$$typeof===x||a.$$typeof===y||a.$$typeof===v)};__webpack_unused_export__=z;


/***/ }),

/***/ 9864:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";


if (true) {
  module.exports = __webpack_require__(9921);
} else {}


/***/ }),

/***/ 3086:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __webpack_require__(5305);
var has = Object.prototype.hasOwnProperty;
var hasNativeMap = typeof Map !== "undefined";

/**
 * A data structure which is a combination of an array and a set. Adding a new
 * member is O(1), testing for membership is O(1), and finding the index of an
 * element is O(1). Removing elements from the set is not supported. Only
 * strings are supported for membership.
 */
function ArraySet() {
  this._array = [];
  this._set = hasNativeMap ? new Map() : Object.create(null);
}

/**
 * Static method for creating ArraySet instances from an existing array.
 */
ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
  var set = new ArraySet();
  for (var i = 0, len = aArray.length; i < len; i++) {
    set.add(aArray[i], aAllowDuplicates);
  }
  return set;
};

/**
 * Return how many unique items are in this ArraySet. If duplicates have been
 * added, than those do not count towards the size.
 *
 * @returns Number
 */
ArraySet.prototype.size = function ArraySet_size() {
  return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
};

/**
 * Add the given string to this set.
 *
 * @param String aStr
 */
ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
  var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
  var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
  var idx = this._array.length;
  if (!isDuplicate || aAllowDuplicates) {
    this._array.push(aStr);
  }
  if (!isDuplicate) {
    if (hasNativeMap) {
      this._set.set(aStr, idx);
    } else {
      this._set[sStr] = idx;
    }
  }
};

/**
 * Is the given string a member of this set?
 *
 * @param String aStr
 */
ArraySet.prototype.has = function ArraySet_has(aStr) {
  if (hasNativeMap) {
    return this._set.has(aStr);
  } else {
    var sStr = util.toSetString(aStr);
    return has.call(this._set, sStr);
  }
};

/**
 * What is the index of the given string in the array?
 *
 * @param String aStr
 */
ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
  if (hasNativeMap) {
    var idx = this._set.get(aStr);
    if (idx >= 0) {
        return idx;
    }
  } else {
    var sStr = util.toSetString(aStr);
    if (has.call(this._set, sStr)) {
      return this._set[sStr];
    }
  }

  throw new Error('"' + aStr + '" is not in the set.');
};

/**
 * What is the element at the given index?
 *
 * @param Number aIdx
 */
ArraySet.prototype.at = function ArraySet_at(aIdx) {
  if (aIdx >= 0 && aIdx < this._array.length) {
    return this._array[aIdx];
  }
  throw new Error('No element indexed by ' + aIdx);
};

/**
 * Returns the array representation of this set (which has the proper indices
 * indicated by indexOf). Note that this is a copy of the internal array used
 * for storing the members so that no one can mess with internal state.
 */
ArraySet.prototype.toArray = function ArraySet_toArray() {
  return this._array.slice();
};

exports.I = ArraySet;


/***/ }),

/***/ 4520:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 *
 * Based on the Base 64 VLQ implementation in Closure Compiler:
 * https://code.google.com/p/closure-compiler/source/browse/trunk/src/com/google/debugging/sourcemap/Base64VLQ.java
 *
 * Copyright 2011 The Closure Compiler Authors. All rights reserved.
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are
 * met:
 *
 *  * Redistributions of source code must retain the above copyright
 *    notice, this list of conditions and the following disclaimer.
 *  * Redistributions in binary form must reproduce the above
 *    copyright notice, this list of conditions and the following
 *    disclaimer in the documentation and/or other materials provided
 *    with the distribution.
 *  * Neither the name of Google Inc. nor the names of its
 *    contributors may be used to endorse or promote products derived
 *    from this software without specific prior written permission.
 *
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
 * "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
 * LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
 * A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
 * OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 * SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
 * LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
 * DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 * THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 * (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
 * OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 */

var base64 = __webpack_require__(3167);

// A single base 64 digit can contain 6 bits of data. For the base 64 variable
// length quantities we use in the source map spec, the first bit is the sign,
// the next four bits are the actual value, and the 6th bit is the
// continuation bit. The continuation bit tells us whether there are more
// digits in this value following this digit.
//
//   Continuation
//   |    Sign
//   |    |
//   V    V
//   101011

var VLQ_BASE_SHIFT = 5;

// binary: 100000
var VLQ_BASE = 1 << VLQ_BASE_SHIFT;

// binary: 011111
var VLQ_BASE_MASK = VLQ_BASE - 1;

// binary: 100000
var VLQ_CONTINUATION_BIT = VLQ_BASE;

/**
 * Converts from a two-complement value to a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   1 becomes 2 (10 binary), -1 becomes 3 (11 binary)
 *   2 becomes 4 (100 binary), -2 becomes 5 (101 binary)
 */
function toVLQSigned(aValue) {
  return aValue < 0
    ? ((-aValue) << 1) + 1
    : (aValue << 1) + 0;
}

/**
 * Converts to a two-complement value from a value where the sign bit is
 * placed in the least significant bit.  For example, as decimals:
 *   2 (10 binary) becomes 1, 3 (11 binary) becomes -1
 *   4 (100 binary) becomes 2, 5 (101 binary) becomes -2
 */
function fromVLQSigned(aValue) {
  var isNegative = (aValue & 1) === 1;
  var shifted = aValue >> 1;
  return isNegative
    ? -shifted
    : shifted;
}

/**
 * Returns the base 64 VLQ encoded value.
 */
exports.encode = function base64VLQ_encode(aValue) {
  var encoded = "";
  var digit;

  var vlq = toVLQSigned(aValue);

  do {
    digit = vlq & VLQ_BASE_MASK;
    vlq >>>= VLQ_BASE_SHIFT;
    if (vlq > 0) {
      // There are still more digits in this value, so we must make sure the
      // continuation bit is marked.
      digit |= VLQ_CONTINUATION_BIT;
    }
    encoded += base64.encode(digit);
  } while (vlq > 0);

  return encoded;
};

/**
 * Decodes the next base 64 VLQ value from the given string and returns the
 * value and the rest of the string via the out parameter.
 */
exports.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
  var strLen = aStr.length;
  var result = 0;
  var shift = 0;
  var continuation, digit;

  do {
    if (aIndex >= strLen) {
      throw new Error("Expected more digits in base 64 VLQ value.");
    }

    digit = base64.decode(aStr.charCodeAt(aIndex++));
    if (digit === -1) {
      throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
    }

    continuation = !!(digit & VLQ_CONTINUATION_BIT);
    digit &= VLQ_BASE_MASK;
    result = result + (digit << shift);
    shift += VLQ_BASE_SHIFT;
  } while (continuation);

  aOutParam.value = fromVLQSigned(result);
  aOutParam.rest = aIndex;
};


/***/ }),

/***/ 3167:
/***/ ((__unused_webpack_module, exports) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var intToCharMap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'.split('');

/**
 * Encode an integer in the range of 0 to 63 to a single base 64 digit.
 */
exports.encode = function (number) {
  if (0 <= number && number < intToCharMap.length) {
    return intToCharMap[number];
  }
  throw new TypeError("Must be between 0 and 63: " + number);
};

/**
 * Decode a single base 64 character code digit to an integer. Returns -1 on
 * failure.
 */
exports.decode = function (charCode) {
  var bigA = 65;     // 'A'
  var bigZ = 90;     // 'Z'

  var littleA = 97;  // 'a'
  var littleZ = 122; // 'z'

  var zero = 48;     // '0'
  var nine = 57;     // '9'

  var plus = 43;     // '+'
  var slash = 47;    // '/'

  var littleOffset = 26;
  var numberOffset = 52;

  // 0 - 25: ABCDEFGHIJKLMNOPQRSTUVWXYZ
  if (bigA <= charCode && charCode <= bigZ) {
    return (charCode - bigA);
  }

  // 26 - 51: abcdefghijklmnopqrstuvwxyz
  if (littleA <= charCode && charCode <= littleZ) {
    return (charCode - littleA + littleOffset);
  }

  // 52 - 61: 0123456789
  if (zero <= charCode && charCode <= nine) {
    return (charCode - zero + numberOffset);
  }

  // 62: +
  if (charCode == plus) {
    return 62;
  }

  // 63: /
  if (charCode == slash) {
    return 63;
  }

  // Invalid base64 digit.
  return -1;
};


/***/ }),

/***/ 4688:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2014 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var util = __webpack_require__(5305);

/**
 * Determine whether mappingB is after mappingA with respect to generated
 * position.
 */
function generatedPositionAfter(mappingA, mappingB) {
  // Optimized for most common case
  var lineA = mappingA.generatedLine;
  var lineB = mappingB.generatedLine;
  var columnA = mappingA.generatedColumn;
  var columnB = mappingB.generatedColumn;
  return lineB > lineA || lineB == lineA && columnB >= columnA ||
         util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
}

/**
 * A data structure to provide a sorted view of accumulated mappings in a
 * performance conscious manner. It trades a neglibable overhead in general
 * case for a large speedup in case of mappings being added in order.
 */
function MappingList() {
  this._array = [];
  this._sorted = true;
  // Serves as infimum
  this._last = {generatedLine: -1, generatedColumn: 0};
}

/**
 * Iterate through internal items. This method takes the same arguments that
 * `Array.prototype.forEach` takes.
 *
 * NOTE: The order of the mappings is NOT guaranteed.
 */
MappingList.prototype.unsortedForEach =
  function MappingList_forEach(aCallback, aThisArg) {
    this._array.forEach(aCallback, aThisArg);
  };

/**
 * Add the given source mapping.
 *
 * @param Object aMapping
 */
MappingList.prototype.add = function MappingList_add(aMapping) {
  if (generatedPositionAfter(this._last, aMapping)) {
    this._last = aMapping;
    this._array.push(aMapping);
  } else {
    this._sorted = false;
    this._array.push(aMapping);
  }
};

/**
 * Returns the flat, sorted array of mappings. The mappings are sorted by
 * generated position.
 *
 * WARNING: This method returns internal data without copying, for
 * performance. The return value must NOT be mutated, and should be treated as
 * an immutable borrow. If you want to take ownership, you must make your own
 * copy.
 */
MappingList.prototype.toArray = function MappingList_toArray() {
  if (!this._sorted) {
    this._array.sort(util.compareByGeneratedPositionsInflated);
    this._sorted = true;
  }
  return this._array;
};

exports.H = MappingList;


/***/ }),

/***/ 4508:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

var base64VLQ = __webpack_require__(4520);
var util = __webpack_require__(5305);
var ArraySet = (__webpack_require__(3086)/* .ArraySet */ .I);
var MappingList = (__webpack_require__(4688)/* .MappingList */ .H);

/**
 * An instance of the SourceMapGenerator represents a source map which is
 * being built incrementally. You may pass an object with the following
 * properties:
 *
 *   - file: The filename of the generated source.
 *   - sourceRoot: A root for all relative URLs in this source map.
 */
function SourceMapGenerator(aArgs) {
  if (!aArgs) {
    aArgs = {};
  }
  this._file = util.getArg(aArgs, 'file', null);
  this._sourceRoot = util.getArg(aArgs, 'sourceRoot', null);
  this._skipValidation = util.getArg(aArgs, 'skipValidation', false);
  this._sources = new ArraySet();
  this._names = new ArraySet();
  this._mappings = new MappingList();
  this._sourcesContents = null;
}

SourceMapGenerator.prototype._version = 3;

/**
 * Creates a new SourceMapGenerator based on a SourceMapConsumer
 *
 * @param aSourceMapConsumer The SourceMap.
 */
SourceMapGenerator.fromSourceMap =
  function SourceMapGenerator_fromSourceMap(aSourceMapConsumer) {
    var sourceRoot = aSourceMapConsumer.sourceRoot;
    var generator = new SourceMapGenerator({
      file: aSourceMapConsumer.file,
      sourceRoot: sourceRoot
    });
    aSourceMapConsumer.eachMapping(function (mapping) {
      var newMapping = {
        generated: {
          line: mapping.generatedLine,
          column: mapping.generatedColumn
        }
      };

      if (mapping.source != null) {
        newMapping.source = mapping.source;
        if (sourceRoot != null) {
          newMapping.source = util.relative(sourceRoot, newMapping.source);
        }

        newMapping.original = {
          line: mapping.originalLine,
          column: mapping.originalColumn
        };

        if (mapping.name != null) {
          newMapping.name = mapping.name;
        }
      }

      generator.addMapping(newMapping);
    });
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var sourceRelative = sourceFile;
      if (sourceRoot !== null) {
        sourceRelative = util.relative(sourceRoot, sourceFile);
      }

      if (!generator._sources.has(sourceRelative)) {
        generator._sources.add(sourceRelative);
      }

      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        generator.setSourceContent(sourceFile, content);
      }
    });
    return generator;
  };

/**
 * Add a single mapping from original source line and column to the generated
 * source's line and column for this source map being created. The mapping
 * object should have the following properties:
 *
 *   - generated: An object with the generated line and column positions.
 *   - original: An object with the original line and column positions.
 *   - source: The original source file (relative to the sourceRoot).
 *   - name: An optional original token name for this mapping.
 */
SourceMapGenerator.prototype.addMapping =
  function SourceMapGenerator_addMapping(aArgs) {
    var generated = util.getArg(aArgs, 'generated');
    var original = util.getArg(aArgs, 'original', null);
    var source = util.getArg(aArgs, 'source', null);
    var name = util.getArg(aArgs, 'name', null);

    if (!this._skipValidation) {
      this._validateMapping(generated, original, source, name);
    }

    if (source != null) {
      source = String(source);
      if (!this._sources.has(source)) {
        this._sources.add(source);
      }
    }

    if (name != null) {
      name = String(name);
      if (!this._names.has(name)) {
        this._names.add(name);
      }
    }

    this._mappings.add({
      generatedLine: generated.line,
      generatedColumn: generated.column,
      originalLine: original != null && original.line,
      originalColumn: original != null && original.column,
      source: source,
      name: name
    });
  };

/**
 * Set the source content for a source file.
 */
SourceMapGenerator.prototype.setSourceContent =
  function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
    var source = aSourceFile;
    if (this._sourceRoot != null) {
      source = util.relative(this._sourceRoot, source);
    }

    if (aSourceContent != null) {
      // Add the source content to the _sourcesContents map.
      // Create a new _sourcesContents map if the property is null.
      if (!this._sourcesContents) {
        this._sourcesContents = Object.create(null);
      }
      this._sourcesContents[util.toSetString(source)] = aSourceContent;
    } else if (this._sourcesContents) {
      // Remove the source file from the _sourcesContents map.
      // If the _sourcesContents map is empty, set the property to null.
      delete this._sourcesContents[util.toSetString(source)];
      if (Object.keys(this._sourcesContents).length === 0) {
        this._sourcesContents = null;
      }
    }
  };

/**
 * Applies the mappings of a sub-source-map for a specific source file to the
 * source map being generated. Each mapping to the supplied source file is
 * rewritten using the supplied source map. Note: The resolution for the
 * resulting mappings is the minimium of this map and the supplied map.
 *
 * @param aSourceMapConsumer The source map to be applied.
 * @param aSourceFile Optional. The filename of the source file.
 *        If omitted, SourceMapConsumer's file property will be used.
 * @param aSourceMapPath Optional. The dirname of the path to the source map
 *        to be applied. If relative, it is relative to the SourceMapConsumer.
 *        This parameter is needed when the two source maps aren't in the same
 *        directory, and the source map to be applied contains relative source
 *        paths. If so, those relative source paths need to be rewritten
 *        relative to the SourceMapGenerator.
 */
SourceMapGenerator.prototype.applySourceMap =
  function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
    var sourceFile = aSourceFile;
    // If aSourceFile is omitted, we will use the file property of the SourceMap
    if (aSourceFile == null) {
      if (aSourceMapConsumer.file == null) {
        throw new Error(
          'SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, ' +
          'or the source map\'s "file" property. Both were omitted.'
        );
      }
      sourceFile = aSourceMapConsumer.file;
    }
    var sourceRoot = this._sourceRoot;
    // Make "sourceFile" relative if an absolute Url is passed.
    if (sourceRoot != null) {
      sourceFile = util.relative(sourceRoot, sourceFile);
    }
    // Applying the SourceMap can add and remove items from the sources and
    // the names array.
    var newSources = new ArraySet();
    var newNames = new ArraySet();

    // Find mappings for the "sourceFile"
    this._mappings.unsortedForEach(function (mapping) {
      if (mapping.source === sourceFile && mapping.originalLine != null) {
        // Check if it can be mapped by the source map, then update the mapping.
        var original = aSourceMapConsumer.originalPositionFor({
          line: mapping.originalLine,
          column: mapping.originalColumn
        });
        if (original.source != null) {
          // Copy mapping
          mapping.source = original.source;
          if (aSourceMapPath != null) {
            mapping.source = util.join(aSourceMapPath, mapping.source)
          }
          if (sourceRoot != null) {
            mapping.source = util.relative(sourceRoot, mapping.source);
          }
          mapping.originalLine = original.line;
          mapping.originalColumn = original.column;
          if (original.name != null) {
            mapping.name = original.name;
          }
        }
      }

      var source = mapping.source;
      if (source != null && !newSources.has(source)) {
        newSources.add(source);
      }

      var name = mapping.name;
      if (name != null && !newNames.has(name)) {
        newNames.add(name);
      }

    }, this);
    this._sources = newSources;
    this._names = newNames;

    // Copy sourcesContents of applied map.
    aSourceMapConsumer.sources.forEach(function (sourceFile) {
      var content = aSourceMapConsumer.sourceContentFor(sourceFile);
      if (content != null) {
        if (aSourceMapPath != null) {
          sourceFile = util.join(aSourceMapPath, sourceFile);
        }
        if (sourceRoot != null) {
          sourceFile = util.relative(sourceRoot, sourceFile);
        }
        this.setSourceContent(sourceFile, content);
      }
    }, this);
  };

/**
 * A mapping can have one of the three levels of data:
 *
 *   1. Just the generated position.
 *   2. The Generated position, original position, and original source.
 *   3. Generated and original position, original source, as well as a name
 *      token.
 *
 * To maintain consistency, we validate that any new mapping being added falls
 * in to one of these categories.
 */
SourceMapGenerator.prototype._validateMapping =
  function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource,
                                              aName) {
    // When aOriginal is truthy but has empty values for .line and .column,
    // it is most likely a programmer error. In this case we throw a very
    // specific error message to try to guide them the right way.
    // For example: https://github.com/Polymer/polymer-bundler/pull/519
    if (aOriginal && typeof aOriginal.line !== 'number' && typeof aOriginal.column !== 'number') {
        throw new Error(
            'original.line and original.column are not numbers -- you probably meant to omit ' +
            'the original mapping entirely and only map the generated position. If so, pass ' +
            'null for the original mapping instead of an object with empty or null values.'
        );
    }

    if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
        && aGenerated.line > 0 && aGenerated.column >= 0
        && !aOriginal && !aSource && !aName) {
      // Case 1.
      return;
    }
    else if (aGenerated && 'line' in aGenerated && 'column' in aGenerated
             && aOriginal && 'line' in aOriginal && 'column' in aOriginal
             && aGenerated.line > 0 && aGenerated.column >= 0
             && aOriginal.line > 0 && aOriginal.column >= 0
             && aSource) {
      // Cases 2 and 3.
      return;
    }
    else {
      throw new Error('Invalid mapping: ' + JSON.stringify({
        generated: aGenerated,
        source: aSource,
        original: aOriginal,
        name: aName
      }));
    }
  };

/**
 * Serialize the accumulated mappings in to the stream of base 64 VLQs
 * specified by the source map format.
 */
SourceMapGenerator.prototype._serializeMappings =
  function SourceMapGenerator_serializeMappings() {
    var previousGeneratedColumn = 0;
    var previousGeneratedLine = 1;
    var previousOriginalColumn = 0;
    var previousOriginalLine = 0;
    var previousName = 0;
    var previousSource = 0;
    var result = '';
    var next;
    var mapping;
    var nameIdx;
    var sourceIdx;

    var mappings = this._mappings.toArray();
    for (var i = 0, len = mappings.length; i < len; i++) {
      mapping = mappings[i];
      next = ''

      if (mapping.generatedLine !== previousGeneratedLine) {
        previousGeneratedColumn = 0;
        while (mapping.generatedLine !== previousGeneratedLine) {
          next += ';';
          previousGeneratedLine++;
        }
      }
      else {
        if (i > 0) {
          if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
            continue;
          }
          next += ',';
        }
      }

      next += base64VLQ.encode(mapping.generatedColumn
                                 - previousGeneratedColumn);
      previousGeneratedColumn = mapping.generatedColumn;

      if (mapping.source != null) {
        sourceIdx = this._sources.indexOf(mapping.source);
        next += base64VLQ.encode(sourceIdx - previousSource);
        previousSource = sourceIdx;

        // lines are stored 0-based in SourceMap spec version 3
        next += base64VLQ.encode(mapping.originalLine - 1
                                   - previousOriginalLine);
        previousOriginalLine = mapping.originalLine - 1;

        next += base64VLQ.encode(mapping.originalColumn
                                   - previousOriginalColumn);
        previousOriginalColumn = mapping.originalColumn;

        if (mapping.name != null) {
          nameIdx = this._names.indexOf(mapping.name);
          next += base64VLQ.encode(nameIdx - previousName);
          previousName = nameIdx;
        }
      }

      result += next;
    }

    return result;
  };

SourceMapGenerator.prototype._generateSourcesContent =
  function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
    return aSources.map(function (source) {
      if (!this._sourcesContents) {
        return null;
      }
      if (aSourceRoot != null) {
        source = util.relative(aSourceRoot, source);
      }
      var key = util.toSetString(source);
      return Object.prototype.hasOwnProperty.call(this._sourcesContents, key)
        ? this._sourcesContents[key]
        : null;
    }, this);
  };

/**
 * Externalize the source map.
 */
SourceMapGenerator.prototype.toJSON =
  function SourceMapGenerator_toJSON() {
    var map = {
      version: this._version,
      sources: this._sources.toArray(),
      names: this._names.toArray(),
      mappings: this._serializeMappings()
    };
    if (this._file != null) {
      map.file = this._file;
    }
    if (this._sourceRoot != null) {
      map.sourceRoot = this._sourceRoot;
    }
    if (this._sourcesContents) {
      map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
    }

    return map;
  };

/**
 * Render the source map being generated to a string.
 */
SourceMapGenerator.prototype.toString =
  function SourceMapGenerator_toString() {
    return JSON.stringify(this.toJSON());
  };

exports.h = SourceMapGenerator;


/***/ }),

/***/ 5305:
/***/ ((__unused_webpack_module, exports) => {

/* -*- Mode: js; js-indent-level: 2; -*- */
/*
 * Copyright 2011 Mozilla Foundation and contributors
 * Licensed under the New BSD license. See LICENSE or:
 * http://opensource.org/licenses/BSD-3-Clause
 */

/**
 * This is a helper function for getting values from parameter/options
 * objects.
 *
 * @param args The object we are extracting values from
 * @param name The name of the property we are getting.
 * @param defaultValue An optional value to return if the property is missing
 * from the object. If this is not specified and the property is missing, an
 * error will be thrown.
 */
function getArg(aArgs, aName, aDefaultValue) {
  if (aName in aArgs) {
    return aArgs[aName];
  } else if (arguments.length === 3) {
    return aDefaultValue;
  } else {
    throw new Error('"' + aName + '" is a required argument.');
  }
}
exports.getArg = getArg;

var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
var dataUrlRegexp = /^data:.+\,.+$/;

function urlParse(aUrl) {
  var match = aUrl.match(urlRegexp);
  if (!match) {
    return null;
  }
  return {
    scheme: match[1],
    auth: match[2],
    host: match[3],
    port: match[4],
    path: match[5]
  };
}
exports.urlParse = urlParse;

function urlGenerate(aParsedUrl) {
  var url = '';
  if (aParsedUrl.scheme) {
    url += aParsedUrl.scheme + ':';
  }
  url += '//';
  if (aParsedUrl.auth) {
    url += aParsedUrl.auth + '@';
  }
  if (aParsedUrl.host) {
    url += aParsedUrl.host;
  }
  if (aParsedUrl.port) {
    url += ":" + aParsedUrl.port
  }
  if (aParsedUrl.path) {
    url += aParsedUrl.path;
  }
  return url;
}
exports.urlGenerate = urlGenerate;

var MAX_CACHED_INPUTS = 32;

/**
 * Takes some function `f(input) -> result` and returns a memoized version of
 * `f`.
 *
 * We keep at most `MAX_CACHED_INPUTS` memoized results of `f` alive. The
 * memoization is a dumb-simple, linear least-recently-used cache.
 */
function lruMemoize(f) {
  var cache = [];

  return function(input) {
    for (var i = 0; i < cache.length; i++) {
      if (cache[i].input === input) {
        var temp = cache[0];
        cache[0] = cache[i];
        cache[i] = temp;
        return cache[0].result;
      }
    }

    var result = f(input);

    cache.unshift({
      input,
      result,
    });

    if (cache.length > MAX_CACHED_INPUTS) {
      cache.pop();
    }

    return result;
  };
}

/**
 * Normalizes a path, or the path portion of a URL:
 *
 * - Replaces consecutive slashes with one slash.
 * - Removes unnecessary '.' parts.
 * - Removes unnecessary '<dir>/..' parts.
 *
 * Based on code in the Node.js 'path' core module.
 *
 * @param aPath The path or url to normalize.
 */
var normalize = lruMemoize(function normalize(aPath) {
  var path = aPath;
  var url = urlParse(aPath);
  if (url) {
    if (!url.path) {
      return aPath;
    }
    path = url.path;
  }
  var isAbsolute = exports.isAbsolute(path);
  // Split the path into parts between `/` characters. This is much faster than
  // using `.split(/\/+/g)`.
  var parts = [];
  var start = 0;
  var i = 0;
  while (true) {
    start = i;
    i = path.indexOf("/", start);
    if (i === -1) {
      parts.push(path.slice(start));
      break;
    } else {
      parts.push(path.slice(start, i));
      while (i < path.length && path[i] === "/") {
        i++;
      }
    }
  }

  for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
    part = parts[i];
    if (part === '.') {
      parts.splice(i, 1);
    } else if (part === '..') {
      up++;
    } else if (up > 0) {
      if (part === '') {
        // The first part is blank if the path is absolute. Trying to go
        // above the root is a no-op. Therefore we can remove all '..' parts
        // directly after the root.
        parts.splice(i + 1, up);
        up = 0;
      } else {
        parts.splice(i, 2);
        up--;
      }
    }
  }
  path = parts.join('/');

  if (path === '') {
    path = isAbsolute ? '/' : '.';
  }

  if (url) {
    url.path = path;
    return urlGenerate(url);
  }
  return path;
});
exports.normalize = normalize;

/**
 * Joins two paths/URLs.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be joined with the root.
 *
 * - If aPath is a URL or a data URI, aPath is returned, unless aPath is a
 *   scheme-relative URL: Then the scheme of aRoot, if any, is prepended
 *   first.
 * - Otherwise aPath is a path. If aRoot is a URL, then its path portion
 *   is updated with the result and aRoot is returned. Otherwise the result
 *   is returned.
 *   - If aPath is absolute, the result is aPath.
 *   - Otherwise the two paths are joined with a slash.
 * - Joining for example 'http://' and 'www.example.com' is also supported.
 */
function join(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }
  if (aPath === "") {
    aPath = ".";
  }
  var aPathUrl = urlParse(aPath);
  var aRootUrl = urlParse(aRoot);
  if (aRootUrl) {
    aRoot = aRootUrl.path || '/';
  }

  // `join(foo, '//www.example.org')`
  if (aPathUrl && !aPathUrl.scheme) {
    if (aRootUrl) {
      aPathUrl.scheme = aRootUrl.scheme;
    }
    return urlGenerate(aPathUrl);
  }

  if (aPathUrl || aPath.match(dataUrlRegexp)) {
    return aPath;
  }

  // `join('http://', 'www.example.com')`
  if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
    aRootUrl.host = aPath;
    return urlGenerate(aRootUrl);
  }

  var joined = aPath.charAt(0) === '/'
    ? aPath
    : normalize(aRoot.replace(/\/+$/, '') + '/' + aPath);

  if (aRootUrl) {
    aRootUrl.path = joined;
    return urlGenerate(aRootUrl);
  }
  return joined;
}
exports.join = join;

exports.isAbsolute = function (aPath) {
  return aPath.charAt(0) === '/' || urlRegexp.test(aPath);
};

/**
 * Make a path relative to a URL or another path.
 *
 * @param aRoot The root path or URL.
 * @param aPath The path or URL to be made relative to aRoot.
 */
function relative(aRoot, aPath) {
  if (aRoot === "") {
    aRoot = ".";
  }

  aRoot = aRoot.replace(/\/$/, '');

  // It is possible for the path to be above the root. In this case, simply
  // checking whether the root is a prefix of the path won't work. Instead, we
  // need to remove components from the root one by one, until either we find
  // a prefix that fits, or we run out of components to remove.
  var level = 0;
  while (aPath.indexOf(aRoot + '/') !== 0) {
    var index = aRoot.lastIndexOf("/");
    if (index < 0) {
      return aPath;
    }

    // If the only part of the root that is left is the scheme (i.e. http://,
    // file:///, etc.), one or more slashes (/), or simply nothing at all, we
    // have exhausted all components, so the path is not relative to the root.
    aRoot = aRoot.slice(0, index);
    if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
      return aPath;
    }

    ++level;
  }

  // Make sure we add a "../" for each component we removed from the root.
  return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
}
exports.relative = relative;

var supportsNullProto = (function () {
  var obj = Object.create(null);
  return !('__proto__' in obj);
}());

function identity (s) {
  return s;
}

/**
 * Because behavior goes wacky when you set `__proto__` on objects, we
 * have to prefix all the strings in our set with an arbitrary character.
 *
 * See https://github.com/mozilla/source-map/pull/31 and
 * https://github.com/mozilla/source-map/issues/30
 *
 * @param String aStr
 */
function toSetString(aStr) {
  if (isProtoString(aStr)) {
    return '$' + aStr;
  }

  return aStr;
}
exports.toSetString = supportsNullProto ? identity : toSetString;

function fromSetString(aStr) {
  if (isProtoString(aStr)) {
    return aStr.slice(1);
  }

  return aStr;
}
exports.fromSetString = supportsNullProto ? identity : fromSetString;

function isProtoString(s) {
  if (!s) {
    return false;
  }

  var length = s.length;

  if (length < 9 /* "__proto__".length */) {
    return false;
  }

  if (s.charCodeAt(length - 1) !== 95  /* '_' */ ||
      s.charCodeAt(length - 2) !== 95  /* '_' */ ||
      s.charCodeAt(length - 3) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 4) !== 116 /* 't' */ ||
      s.charCodeAt(length - 5) !== 111 /* 'o' */ ||
      s.charCodeAt(length - 6) !== 114 /* 'r' */ ||
      s.charCodeAt(length - 7) !== 112 /* 'p' */ ||
      s.charCodeAt(length - 8) !== 95  /* '_' */ ||
      s.charCodeAt(length - 9) !== 95  /* '_' */) {
    return false;
  }

  for (var i = length - 10; i >= 0; i--) {
    if (s.charCodeAt(i) !== 36 /* '$' */) {
      return false;
    }
  }

  return true;
}

/**
 * Comparator between two mappings where the original positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same original source/line/column, but different generated
 * line and column the same. Useful when searching for a mapping with a
 * stubbed out mapping.
 */
function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
  var cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0 || onlyCompareOriginal) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByOriginalPositions = compareByOriginalPositions;

function compareByOriginalPositionsNoSource(mappingA, mappingB, onlyCompareOriginal) {
  var cmp

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0 || onlyCompareOriginal) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByOriginalPositionsNoSource = compareByOriginalPositionsNoSource;

/**
 * Comparator between two mappings with deflated source and name indices where
 * the generated positions are compared.
 *
 * Optionally pass in `true` as `onlyCompareGenerated` to consider two
 * mappings with the same generated line and column, but different
 * source/name/original line and column the same. Useful when searching for a
 * mapping with a stubbed out mapping.
 */
function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0 || onlyCompareGenerated) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;

function compareByGeneratedPositionsDeflatedNoLine(mappingA, mappingB, onlyCompareGenerated) {
  var cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0 || onlyCompareGenerated) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsDeflatedNoLine = compareByGeneratedPositionsDeflatedNoLine;

function strcmp(aStr1, aStr2) {
  if (aStr1 === aStr2) {
    return 0;
  }

  if (aStr1 === null) {
    return 1; // aStr2 !== null
  }

  if (aStr2 === null) {
    return -1; // aStr1 !== null
  }

  if (aStr1 > aStr2) {
    return 1;
  }

  return -1;
}

/**
 * Comparator between two mappings with inflated source and name strings where
 * the generated positions are compared.
 */
function compareByGeneratedPositionsInflated(mappingA, mappingB) {
  var cmp = mappingA.generatedLine - mappingB.generatedLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.generatedColumn - mappingB.generatedColumn;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = strcmp(mappingA.source, mappingB.source);
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalLine - mappingB.originalLine;
  if (cmp !== 0) {
    return cmp;
  }

  cmp = mappingA.originalColumn - mappingB.originalColumn;
  if (cmp !== 0) {
    return cmp;
  }

  return strcmp(mappingA.name, mappingB.name);
}
exports.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;

/**
 * Strip any JSON XSSI avoidance prefix from the string (as documented
 * in the source maps specification), and then parse the string as
 * JSON.
 */
function parseSourceMapInput(str) {
  return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ''));
}
exports.parseSourceMapInput = parseSourceMapInput;

/**
 * Compute the URL of a source given the the source root, the source's
 * URL, and the source map's URL.
 */
function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
  sourceURL = sourceURL || '';

  if (sourceRoot) {
    // This follows what Chrome does.
    if (sourceRoot[sourceRoot.length - 1] !== '/' && sourceURL[0] !== '/') {
      sourceRoot += '/';
    }
    // The spec says:
    //   Line 4: An optional source root, useful for relocating source
    //   files on a server or removing repeated values in the
    //   sources entry.  This value is prepended to the individual
    //   entries in the source field.
    sourceURL = sourceRoot + sourceURL;
  }

  // Historically, SourceMapConsumer did not take the sourceMapURL as
  // a parameter.  This mode is still somewhat supported, which is why
  // this code block is conditional.  However, it's preferable to pass
  // the source map URL to SourceMapConsumer, so that this function
  // can implement the source URL resolution algorithm as outlined in
  // the spec.  This block is basically the equivalent of:
  //    new URL(sourceURL, sourceMapURL).toString()
  // ... except it avoids using URL, which wasn't available in the
  // older releases of node still supported by this library.
  //
  // The spec says:
  //   If the sources are not absolute URLs after prepending of the
  //   sourceRoot, the sources are resolved relative to the
  //   SourceMap (like resolving script src in a html document).
  if (sourceMapURL) {
    var parsed = urlParse(sourceMapURL);
    if (!parsed) {
      throw new Error("sourceMapURL could not be parsed");
    }
    if (parsed.path) {
      // Strip the last path component, but keep the "/".
      var index = parsed.path.lastIndexOf('/');
      if (index >= 0) {
        parsed.path = parsed.path.substring(0, index + 1);
      }
    }
    sourceURL = join(urlGenerate(parsed), sourceURL);
  }

  return normalize(sourceURL);
}
exports.computeSourceURL = computeSourceURL;


/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		var cachedModule = __webpack_module_cache__[moduleId];
/******/ 		if (cachedModule !== undefined) {
/******/ 			return cachedModule.exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			id: moduleId,
/******/ 			loaded: false,
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = __webpack_modules__;
/******/ 	
/************************************************************************/
/******/ 	/* webpack/runtime/chunk loaded */
/******/ 	(() => {
/******/ 		var deferred = [];
/******/ 		__webpack_require__.O = (result, chunkIds, fn, priority) => {
/******/ 			if(chunkIds) {
/******/ 				priority = priority || 0;
/******/ 				for(var i = deferred.length; i > 0 && deferred[i - 1][2] > priority; i--) deferred[i] = deferred[i - 1];
/******/ 				deferred[i] = [chunkIds, fn, priority];
/******/ 				return;
/******/ 			}
/******/ 			var notFulfilled = Infinity;
/******/ 			for (var i = 0; i < deferred.length; i++) {
/******/ 				var [chunkIds, fn, priority] = deferred[i];
/******/ 				var fulfilled = true;
/******/ 				for (var j = 0; j < chunkIds.length; j++) {
/******/ 					if ((priority & 1 === 0 || notFulfilled >= priority) && Object.keys(__webpack_require__.O).every((key) => (__webpack_require__.O[key](chunkIds[j])))) {
/******/ 						chunkIds.splice(j--, 1);
/******/ 					} else {
/******/ 						fulfilled = false;
/******/ 						if(priority < notFulfilled) notFulfilled = priority;
/******/ 					}
/******/ 				}
/******/ 				if(fulfilled) {
/******/ 					deferred.splice(i--, 1)
/******/ 					var r = fn();
/******/ 					if (r !== undefined) result = r;
/******/ 				}
/******/ 			}
/******/ 			return result;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/compat get default export */
/******/ 	(() => {
/******/ 		// getDefaultExport function for compatibility with non-harmony modules
/******/ 		__webpack_require__.n = (module) => {
/******/ 			var getter = module && module.__esModule ?
/******/ 				() => (module['default']) :
/******/ 				() => (module);
/******/ 			__webpack_require__.d(getter, { a: getter });
/******/ 			return getter;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/define property getters */
/******/ 	(() => {
/******/ 		// define getter functions for harmony exports
/******/ 		__webpack_require__.d = (exports, definition) => {
/******/ 			for(var key in definition) {
/******/ 				if(__webpack_require__.o(definition, key) && !__webpack_require__.o(exports, key)) {
/******/ 					Object.defineProperty(exports, key, { enumerable: true, get: definition[key] });
/******/ 				}
/******/ 			}
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/global */
/******/ 	(() => {
/******/ 		__webpack_require__.g = (function() {
/******/ 			if (typeof globalThis === 'object') return globalThis;
/******/ 			try {
/******/ 				return this || new Function('return this')();
/******/ 			} catch (e) {
/******/ 				if (typeof window === 'object') return window;
/******/ 			}
/******/ 		})();
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/hasOwnProperty shorthand */
/******/ 	(() => {
/******/ 		__webpack_require__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/make namespace object */
/******/ 	(() => {
/******/ 		// define __esModule on exports
/******/ 		__webpack_require__.r = (exports) => {
/******/ 			if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 				Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 			}
/******/ 			Object.defineProperty(exports, '__esModule', { value: true });
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/node module decorator */
/******/ 	(() => {
/******/ 		__webpack_require__.nmd = (module) => {
/******/ 			module.paths = [];
/******/ 			if (!module.children) module.children = [];
/******/ 			return module;
/******/ 		};
/******/ 	})();
/******/ 	
/******/ 	/* webpack/runtime/jsonp chunk loading */
/******/ 	(() => {
/******/ 		// no baseURI
/******/ 		
/******/ 		// object to store loaded and loading chunks
/******/ 		// undefined = chunk not loaded, null = chunk preloaded/prefetched
/******/ 		// [resolve, reject, Promise] = chunk loading, 0 = chunk loaded
/******/ 		var installedChunks = {
/******/ 			346: 0,
/******/ 			812: 0
/******/ 		};
/******/ 		
/******/ 		// no chunk on demand loading
/******/ 		
/******/ 		// no prefetching
/******/ 		
/******/ 		// no preloaded
/******/ 		
/******/ 		// no HMR
/******/ 		
/******/ 		// no HMR manifest
/******/ 		
/******/ 		__webpack_require__.O.j = (chunkId) => (installedChunks[chunkId] === 0);
/******/ 		
/******/ 		// install a JSONP callback for chunk loading
/******/ 		var webpackJsonpCallback = (parentChunkLoadingFunction, data) => {
/******/ 			var [chunkIds, moreModules, runtime] = data;
/******/ 			// add "moreModules" to the modules object,
/******/ 			// then flag all "chunkIds" as loaded and fire callback
/******/ 			var moduleId, chunkId, i = 0;
/******/ 			if(chunkIds.some((id) => (installedChunks[id] !== 0))) {
/******/ 				for(moduleId in moreModules) {
/******/ 					if(__webpack_require__.o(moreModules, moduleId)) {
/******/ 						__webpack_require__.m[moduleId] = moreModules[moduleId];
/******/ 					}
/******/ 				}
/******/ 				if(runtime) var result = runtime(__webpack_require__);
/******/ 			}
/******/ 			if(parentChunkLoadingFunction) parentChunkLoadingFunction(data);
/******/ 			for(;i < chunkIds.length; i++) {
/******/ 				chunkId = chunkIds[i];
/******/ 				if(__webpack_require__.o(installedChunks, chunkId) && installedChunks[chunkId]) {
/******/ 					installedChunks[chunkId][0]();
/******/ 				}
/******/ 				installedChunks[chunkId] = 0;
/******/ 			}
/******/ 			return __webpack_require__.O(result);
/******/ 		}
/******/ 		
/******/ 		var chunkLoadingGlobal = self["webpackChunkblockart_blocks"] = self["webpackChunkblockart_blocks"] || [];
/******/ 		chunkLoadingGlobal.forEach(webpackJsonpCallback.bind(null, 0));
/******/ 		chunkLoadingGlobal.push = webpackJsonpCallback.bind(null, chunkLoadingGlobal.push.bind(chunkLoadingGlobal));
/******/ 	})();
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module depends on other loaded chunks and execution need to be delayed
/******/ 	var __webpack_exports__ = __webpack_require__.O(undefined, [812], () => (__webpack_require__(7221)))
/******/ 	__webpack_exports__ = __webpack_require__.O(__webpack_exports__);
/******/ 	
/******/ })()
;